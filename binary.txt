
build/kernel8.elf:	file format elf64-littleaarch64


Disassembly of section .text.boot:

ffff000000000000 <_start>:
; 	mrs x0, mpidr_el1
ffff000000000000: a0 00 38 d5  	mrs	x0, MPIDR_EL1
; 	and x0, x0, #0xFF
ffff000000000004: 00 1c 40 92  	and	x0, x0, #0xff
; 	cbz x0, init_exception_level
ffff000000000008: 60 01 00 b4  	cbz	x0, 0xffff000000000034 <init_exception_level>
; 	sub x0, x0, #1
ffff00000000000c: 00 04 00 d1  	sub	x0, x0, #1
; 	cbz x0, cpu2
ffff000000000010: 40 00 00 b4  	cbz	x0, 0xffff000000000018 <cpu2>
; 	b proc_hang
ffff000000000014: 06 00 00 14  	b	0xffff00000000002c <proc_hang>

ffff000000000018 <cpu2>:
; 	wfe 
ffff000000000018: 5f 20 03 d5  	wfe
; 	b cpu2
ffff00000000001c: ff ff ff 17  	b	0xffff000000000018 <cpu2>
; 	mov sp, #START_OF_KERNEL_STACK
ffff000000000020: ff 03 6a b2  	orr	sp, xzr, #0x400000
; 	add sp, sp, #4096
ffff000000000024: ff 07 40 91  	add	sp, sp, #1, lsl #12
; 	bl kmain2
ffff000000000028: 84 06 00 94  	bl	0xffff000000001a38 <kmain2>

ffff00000000002c <proc_hang>:
; 	wfe
ffff00000000002c: 5f 20 03 d5  	wfe
; 	b proc_hang
ffff000000000030: ff ff ff 17  	b	0xffff00000000002c <proc_hang>

ffff000000000034 <init_exception_level>:
; 	ldr x0, =SCTLR_VALUE_MMU_DISABLED
ffff000000000034: 20 08 00 58  	ldr	x0, 0xffff000000000138 <$d>
; 	msr sctlr_el1, x0
ffff000000000038: 00 10 18 d5  	msr	SCTLR_EL1, x0
; 	ldr x0, =HCR_VALUE
ffff00000000003c: 20 08 00 58  	ldr	x0, 0xffff000000000140 <$d+0x8>
; 	msr hcr_el2, x0
ffff000000000040: 00 11 1c d5  	msr	HCR_EL2, x0
; 	ldr    x0, =SCR_VALUE
ffff000000000044: 20 08 00 58  	ldr	x0, 0xffff000000000148 <$d+0x10>
;     msr    scr_el3, x0
ffff000000000048: 00 11 1e d5  	msr	SCR_EL3, x0
; 	ldr    x0, =SPSR_VALUE
ffff00000000004c: 20 08 00 58  	ldr	x0, 0xffff000000000150 <$d+0x18>
;     msr    spsr_el3, x0
ffff000000000050: 00 40 1e d5  	msr	SPSR_EL3, x0
; 	adr x0, master
ffff000000000054: 60 00 00 10  	adr	x0, #12
; 	msr elr_el3, x0
ffff000000000058: 20 40 1e d5  	msr	ELR_EL3, x0
; 	eret
ffff00000000005c: e0 03 9f d6  	eret

ffff000000000060 <master>:
; 	adr x0, bss_begin
ffff000000000060: c0 a5 02 10  	adr	x0, #21688
; 	adr x1, bss_end
ffff000000000064: e1 0b 22 10  	adr	x1, #278908
; 	sub x1, x1, x0
ffff000000000068: 21 00 00 cb  	sub	x1, x1, x0
; 	bl memzero
ffff00000000006c: a9 10 00 94  	bl	0xffff000000004310 <memzero>
; 	adrp x0, kernel_page_table_start
ffff000000000070: 20 02 00 b0  	adrp	x0, #282624
; 	mov x1, #4096 * 3
ffff000000000074: 01 00 86 d2  	mov	x1, #12288
; 	bl memzero
ffff000000000078: a6 10 00 94  	bl	0xffff000000004310 <memzero>
; 	adrp x0, kernel_page_table_start 
ffff00000000007c: 20 02 00 b0  	adrp	x0, #282624
; 	add x0, x0, #PAGE_SIZE 
ffff000000000080: 00 04 40 91  	add	x0, x0, #1, lsl #12
; 	orr x0, x0, 0b11 
ffff000000000084: 00 04 40 b2  	orr	x0, x0, #0x3
; 	adrp x1, kernel_page_table_start 
ffff000000000088: 21 02 00 b0  	adrp	x1, #282624
; 	str x0, [x1]
ffff00000000008c: 20 00 00 f9  	str	x0, [x1]
; 	adrp x0, kernel_page_table_start
ffff000000000090: 20 02 00 b0  	adrp	x0, #282624
; 	add x0, x0, #PAGE_SIZE
ffff000000000094: 00 04 40 91  	add	x0, x0, #1, lsl #12
; 	add x1, x0, #PAGE_SIZE
ffff000000000098: 01 04 40 91  	add	x1, x0, #1, lsl #12
; 	orr x1, x1, 0b11
ffff00000000009c: 21 04 40 b2  	orr	x1, x1, #0x3
; 	str x1, [x0]
ffff0000000000a0: 01 00 00 f9  	str	x1, [x0]
; 	ldr    x0, =(MAIR_VALUE)
ffff0000000000a4: a0 05 00 58  	ldr	x0, 0xffff000000000158 <$d+0x20>
;     msr    mair_el1, x0
ffff0000000000a8: 00 a2 18 d5  	msr	MAIR_EL1, x0
; 	mov x0, #0
ffff0000000000ac: 00 00 80 d2  	mov	x0, #0
; 	adrp x1, kernel_page_table_start
ffff0000000000b0: 21 02 00 b0  	adrp	x1, #282624
; 	add x1, x1, #PAGE_SIZE
ffff0000000000b4: 21 04 40 91  	add	x1, x1, #1, lsl #12
; 	add x1, x1, #PAGE_SIZE
ffff0000000000b8: 21 04 40 91  	add	x1, x1, #1, lsl #12
; 	mov x2, #0
ffff0000000000bc: 02 00 80 d2  	mov	x2, #0
; 	mov x3, #MMU_FLAGS
ffff0000000000c0: a3 80 80 d2  	mov	x3, #1029
; 	orr x2, x2, x3
ffff0000000000c4: 42 00 03 aa  	orr	x2, x2, x3

ffff0000000000c8 <vmap_loop>:
; 	str x2, [x1, x0, lsl #3]
ffff0000000000c8: 22 78 20 f8  	str	x2, [x1, x0, lsl #3]
; 	mov x9, #1
ffff0000000000cc: 29 00 80 d2  	mov	x9, #1
; 	lsl x9, x9, #21
ffff0000000000d0: 29 a9 6b d3  	lsl	x9, x9, #21
; 	add x2, x2, x9
ffff0000000000d4: 42 00 09 8b  	add	x2, x2, x9
; 	add x0, x0, #1
ffff0000000000d8: 00 04 00 91  	add	x0, x0, #1
; 	mov x9, #512 
ffff0000000000dc: 09 40 80 d2  	mov	x9, #512
; 	cmp x0, x9
ffff0000000000e0: 1f 00 09 eb  	cmp	x0, x9
; 	b.ls vmap_loop
ffff0000000000e4: 29 ff ff 54  	b.ls	0xffff0000000000c8 <vmap_loop>
; 	mov x0, #VA_START
ffff0000000000e8: e0 ff ff d2  	mov	x0, #-281474976710656
; 	mov x1, #START_OF_KERNEL_STACK
ffff0000000000ec: 01 08 a0 d2  	mov	x1, #4194304
; 	add sp, x0, x1
ffff0000000000f0: 1f 60 21 8b  	add	sp, x0, x1
; 	adrp x0, kernel_page_table_start
ffff0000000000f4: 20 02 00 b0  	adrp	x0, #282624
; 	msr ttbr1_el1, x0
ffff0000000000f8: 20 20 18 d5  	msr	TTBR1_EL1, x0
; 	ldr    x0, =(TCR_VALUE)
ffff0000000000fc: 20 03 00 58  	ldr	x0, 0xffff000000000160 <$d+0x28>
;     msr    tcr_el1, x0
ffff000000000100: 40 20 18 d5  	msr	TCR_EL1, x0
; 	ldr    x0, =(MAIR_VALUE)
ffff000000000104: a0 02 00 58  	ldr	x0, 0xffff000000000158 <$d+0x20>
;     msr    mair_el1, x0
ffff000000000108: 00 a2 18 d5  	msr	MAIR_EL1, x0
; 	bl init_interrupt_request_table
ffff00000000010c: 76 10 00 94  	bl	0xffff0000000042e4 <init_interrupt_request_table>
; 	mov sp, #START_OF_KERNEL_STACK
ffff000000000110: ff 03 6a b2  	orr	sp, xzr, #0x400000
;     bl kmain
ffff000000000114: 71 06 00 94  	bl	0xffff000000001ad8 <kmain>
; 	ldr x0, =kmain
ffff000000000118: 80 02 00 58  	ldr	x0, 0xffff000000000168 <$d+0x30>
; 	mov x1, #SCTLR_MMU_ENABLED
ffff00000000011c: 21 00 80 d2  	mov	x1, #1
; 	msr    sctlr_el1, x1
ffff000000000120: 01 10 18 d5  	msr	SCTLR_EL1, x1
; 	br x0
ffff000000000124: 00 00 1f d6  	br	x0
; 	b proc_hang
ffff000000000128: c1 ff ff 17  	b	0xffff00000000002c <proc_hang>

ffff00000000012c <getExceptionLevel>:
; 	mrs x0, CURRENTEL
ffff00000000012c: 40 42 38 d5  	mrs	x0, CurrentEL
; 	lsr x0, x0, #2
ffff000000000130: 00 fc 42 d3  	lsr	x0, x0, #2
; 	ret
ffff000000000134: c0 03 5f d6  	ret

ffff000000000138 <$d>:
ffff000000000138:	00 08 d0 30	.word	0x30d00800
ffff00000000013c:	00 00 00 00	.word	0x00000000
ffff000000000140:	00 00 00 80	.word	0x80000000
ffff000000000144:	00 00 00 00	.word	0x00000000
ffff000000000148:	31 04 00 00	.word	0x00000431
ffff00000000014c:	00 00 00 00	.word	0x00000000
ffff000000000150:	c5 01 00 00	.word	0x000001c5
ffff000000000154:	00 00 00 00	.word	0x00000000
ffff000000000158:	00 44 00 00	.word	0x00004400
ffff00000000015c:	00 00 00 00	.word	0x00000000
ffff000000000160:	10 00 10 80	.word	0x80100010
ffff000000000164:	00 00 00 00	.word	0x00000000
ffff000000000168:	d8 1a 00 00	.word	0x00001ad8
ffff00000000016c:	00 00 ff ff	.word	0xffff0000

Disassembly of section .text:

ffff000000000800 <show_unknown_interrupt_msg>:
; void show_unknown_interrupt_msg(int index, unsigned long cause, unsigned long address) {
ffff000000000800: fd 7b bd a9  	stp	x29, x30, [sp, #-48]!
ffff000000000804: fd 03 00 91  	mov	x29, sp
ffff000000000808: e0 2f 00 b9  	str	w0, [sp, #44]
ffff00000000080c: e1 13 00 f9  	str	x1, [sp, #32]
ffff000000000810: e2 0f 00 f9  	str	x2, [sp, #24]
;     kprintf("Unexpected Interrupt! Index %d, Cause %d, Address %d\n", index, cause, address);
ffff000000000814: e3 0f 40 f9  	ldr	x3, [sp, #24]
ffff000000000818: e2 13 40 f9  	ldr	x2, [sp, #32]
ffff00000000081c: e1 2f 40 b9  	ldr	w1, [sp, #44]
ffff000000000820: 20 00 00 90  	adrp	x0, #16384
ffff000000000824: 00 00 0d 91  	add	x0, x0, #832
ffff000000000828: 0a 04 00 94  	bl	0xffff000000001850 <kprintf>
; }
ffff00000000082c: 1f 20 03 d5  	nop
ffff000000000830: fd 7b c3 a8  	ldp	x29, x30, [sp], #48
ffff000000000834: c0 03 5f d6  	ret

ffff000000000838 <handle_irq>:
; void handle_irq() {
ffff000000000838: fd 7b be a9  	stp	x29, x30, [sp, #-32]!
ffff00000000083c: fd 03 00 91  	mov	x29, sp
;     disable_irq();
ffff000000000840: ad 0e 00 94  	bl	0xffff0000000042f4 <disable_irq>
;     klog("[time=%d] IRQ Recieved\n", get32(TIMER_CLO));
ffff000000000844: 80 00 86 d2  	mov	x0, #12292
ffff000000000848: 00 e0 a7 f2  	movk	x0, #16128, lsl #16
ffff00000000084c: b8 0e 00 94  	bl	0xffff00000000432c <get32>
ffff000000000850: e1 03 00 2a  	mov	w1, w0
ffff000000000854: 20 00 00 90  	adrp	x0, #16384
ffff000000000858: 00 e0 0d 91  	add	x0, x0, #888
ffff00000000085c: 1d 04 00 94  	bl	0xffff0000000018d0 <klog>
;     unsigned int irq = get32(IRQ_PENDING_1);
ffff000000000860: 80 40 96 d2  	mov	x0, #45572
ffff000000000864: 00 e0 a7 f2  	movk	x0, #16128, lsl #16
ffff000000000868: b1 0e 00 94  	bl	0xffff00000000432c <get32>
ffff00000000086c: e0 1f 00 b9  	str	w0, [sp, #28]
;     if (irq & PRIMARY_TIMER_IRQ) {
ffff000000000870: e0 1f 40 b9  	ldr	w0, [sp, #28]
ffff000000000874: 00 00 1f 12  	and	w0, w0, #0x2
ffff000000000878: 1f 00 00 71  	cmp	w0, #0
ffff00000000087c: 40 01 00 54  	b.eq	0xffff0000000008a4 <handle_irq+0x6c>
;         klog("[time=%d] It was determined that the IRQ was from the primary system timer\n", get32(TIMER_CLO));
ffff000000000880: 80 00 86 d2  	mov	x0, #12292
ffff000000000884: 00 e0 a7 f2  	movk	x0, #16128, lsl #16
ffff000000000888: a9 0e 00 94  	bl	0xffff00000000432c <get32>
ffff00000000088c: e1 03 00 2a  	mov	w1, w0
ffff000000000890: 20 00 00 90  	adrp	x0, #16384
ffff000000000894: 00 40 0e 91  	add	x0, x0, #912
ffff000000000898: 0e 04 00 94  	bl	0xffff0000000018d0 <klog>
;         handle_timer_irq();
ffff00000000089c: 1c 09 00 94  	bl	0xffff000000002d0c <handle_timer_irq>
ffff0000000008a0: 11 00 00 14  	b	0xffff0000000008e4 <handle_irq+0xac>
;     } else if (irq & SECONDARY_TIMER_IRQ) {
ffff0000000008a4: e0 1f 40 b9  	ldr	w0, [sp, #28]
ffff0000000008a8: 00 00 1d 12  	and	w0, w0, #0x8
ffff0000000008ac: 1f 00 00 71  	cmp	w0, #0
ffff0000000008b0: 20 01 00 54  	b.eq	0xffff0000000008d4 <handle_irq+0x9c>
;         klog("Secondary Timer Interrupt Recieved, This can be used in the future\n");
ffff0000000008b4: 20 00 00 90  	adrp	x0, #16384
ffff0000000008b8: 00 80 0f 91  	add	x0, x0, #992
ffff0000000008bc: 05 04 00 94  	bl	0xffff0000000018d0 <klog>
;         put32(TIMER_CS, SECONDARY_TIMER_IRQ);
ffff0000000008c0: 01 01 80 52  	mov	w1, #8
ffff0000000008c4: 00 00 86 d2  	mov	x0, #12288
ffff0000000008c8: 00 e0 a7 f2  	movk	x0, #16128, lsl #16
ffff0000000008cc: 9a 0e 00 94  	bl	0xffff000000004334 <put32>
ffff0000000008d0: 05 00 00 14  	b	0xffff0000000008e4 <handle_irq+0xac>
;         kprintf("Unknown pending irq: %d\n", irq);
ffff0000000008d4: e1 1f 40 b9  	ldr	w1, [sp, #28]
ffff0000000008d8: 20 00 00 90  	adrp	x0, #16384
ffff0000000008dc: 00 a0 10 91  	add	x0, x0, #1064
ffff0000000008e0: dc 03 00 94  	bl	0xffff000000001850 <kprintf>
;     enable_irq();    
ffff0000000008e4: 82 0e 00 94  	bl	0xffff0000000042ec <enable_irq>
;     return;
ffff0000000008e8: 1f 20 03 d5  	nop
; }
ffff0000000008ec: fd 7b c2 a8  	ldp	x29, x30, [sp], #32
ffff0000000008f0: c0 03 5f d6  	ret

ffff0000000008f4 <init_rpi_interrupt_handler>:
; void init_rpi_interrupt_handler() {
ffff0000000008f4: fd 7b bf a9  	stp	x29, x30, [sp, #-16]!
ffff0000000008f8: fd 03 00 91  	mov	x29, sp
;     put32(IRQ_ER_1, (1 << 1) | (1 << 3));
ffff0000000008fc: 41 01 80 52  	mov	w1, #10
ffff000000000900: 00 42 96 d2  	mov	x0, #45584
ffff000000000904: 00 e0 a7 f2  	movk	x0, #16128, lsl #16
ffff000000000908: 8b 0e 00 94  	bl	0xffff000000004334 <put32>
; }
ffff00000000090c: 1f 20 03 d5  	nop
ffff000000000910: fd 7b c1 a8  	ldp	x29, x30, [sp], #16
ffff000000000914: c0 03 5f d6  	ret

ffff000000000918 <assert>:
; void assert(bool cond) {
ffff000000000918: fd 7b be a9  	stp	x29, x30, [sp, #-32]!
ffff00000000091c: fd 03 00 91  	mov	x29, sp
ffff000000000920: e0 7f 00 39  	strb	w0, [sp, #31]
;     if (!(cond)) {
ffff000000000924: e0 7f 40 39  	ldrb	w0, [sp, #31]
ffff000000000928: 00 00 00 52  	eor	w0, w0, #0x1
ffff00000000092c: 00 1c 00 12  	and	w0, w0, #0xff
ffff000000000930: 1f 00 00 71  	cmp	w0, #0
ffff000000000934: a0 00 00 54  	b.eq	0xffff000000000948 <assert+0x30>
;         kprintf("Bad assertion!\n");
ffff000000000938: 20 00 00 90  	adrp	x0, #16384
ffff00000000093c: 00 20 11 91  	add	x0, x0, #1096
ffff000000000940: c4 03 00 94  	bl	0xffff000000001850 <kprintf>
;         __asm__ __volatile__ ("b proc_hang");
ffff000000000944: ba fd ff 17  	b	0xffff00000000002c <proc_hang>
; }
ffff000000000948: 1f 20 03 d5  	nop
ffff00000000094c: fd 7b c2 a8  	ldp	x29, x30, [sp], #32
ffff000000000950: c0 03 5f d6  	ret

ffff000000000954 <assertWithLine>:
; void assertWithLine(bool cond, int line) {
ffff000000000954: fd 7b be a9  	stp	x29, x30, [sp, #-32]!
ffff000000000958: fd 03 00 91  	mov	x29, sp
ffff00000000095c: e0 7f 00 39  	strb	w0, [sp, #31]
ffff000000000960: e1 1b 00 b9  	str	w1, [sp, #24]
;     if (!(cond)) {
ffff000000000964: e0 7f 40 39  	ldrb	w0, [sp, #31]
ffff000000000968: 00 00 00 52  	eor	w0, w0, #0x1
ffff00000000096c: 00 1c 00 12  	and	w0, w0, #0xff
ffff000000000970: 1f 00 00 71  	cmp	w0, #0
ffff000000000974: c0 00 00 54  	b.eq	0xffff00000000098c <assertWithLine+0x38>
;         kprintf("Bad assertion from line %d\n!", line);
ffff000000000978: e1 1b 40 b9  	ldr	w1, [sp, #24]
ffff00000000097c: 20 00 00 90  	adrp	x0, #16384
ffff000000000980: 00 60 11 91  	add	x0, x0, #1112
ffff000000000984: b3 03 00 94  	bl	0xffff000000001850 <kprintf>
;         __asm__ __volatile__ ("b proc_hang");
ffff000000000988: a9 fd ff 17  	b	0xffff00000000002c <proc_hang>
; }
ffff00000000098c: 1f 20 03 d5  	nop
ffff000000000990: fd 7b c2 a8  	ldp	x29, x30, [sp], #32
ffff000000000994: c0 03 5f d6  	ret

ffff000000000998 <myPower>:
; static inline int myPower(int a, int b) {
ffff000000000998: ff 83 00 d1  	sub	sp, sp, #32
ffff00000000099c: e0 0f 00 b9  	str	w0, [sp, #12]
ffff0000000009a0: e1 0b 00 b9  	str	w1, [sp, #8]
;     int res = a;
ffff0000000009a4: e0 0f 40 b9  	ldr	w0, [sp, #12]
ffff0000000009a8: e0 1f 00 b9  	str	w0, [sp, #28]
;     int curr_power = 1;
ffff0000000009ac: 20 00 80 52  	mov	w0, #1
ffff0000000009b0: e0 1b 00 b9  	str	w0, [sp, #24]
;     while (curr_power++ < b) res *= a;
ffff0000000009b4: 05 00 00 14  	b	0xffff0000000009c8 <myPower+0x30>
ffff0000000009b8: e1 1f 40 b9  	ldr	w1, [sp, #28]
ffff0000000009bc: e0 0f 40 b9  	ldr	w0, [sp, #12]
ffff0000000009c0: 20 7c 00 1b  	mul	w0, w1, w0
ffff0000000009c4: e0 1f 00 b9  	str	w0, [sp, #28]
ffff0000000009c8: e0 1b 40 b9  	ldr	w0, [sp, #24]
ffff0000000009cc: 01 04 00 11  	add	w1, w0, #1
ffff0000000009d0: e1 1b 00 b9  	str	w1, [sp, #24]
ffff0000000009d4: e1 0b 40 b9  	ldr	w1, [sp, #8]
ffff0000000009d8: 3f 00 00 6b  	cmp	w1, w0
ffff0000000009dc: ec fe ff 54  	b.gt	0xffff0000000009b8 <myPower+0x20>
;     return res;
ffff0000000009e0: e0 1f 40 b9  	ldr	w0, [sp, #28]
; }
ffff0000000009e4: ff 83 00 91  	add	sp, sp, #32
ffff0000000009e8: c0 03 5f d6  	ret

ffff0000000009ec <size2level>:
; static inline int size2level (ssize_t size) {
ffff0000000009ec: ff 83 00 d1  	sub	sp, sp, #32
ffff0000000009f0: e0 07 00 f9  	str	x0, [sp, #8]
;     if (size <= MIN_ALLOC) return 0;
ffff0000000009f4: e0 07 40 f9  	ldr	x0, [sp, #8]
ffff0000000009f8: 1f 80 00 f1  	cmp	x0, #32
ffff0000000009fc: 6c 00 00 54  	b.gt	0xffff000000000a08 <size2level+0x1c>
ffff000000000a00: 00 00 80 52  	mov	w0, #0
ffff000000000a04: 15 00 00 14  	b	0xffff000000000a58 <size2level+0x6c>
;     if (size > MAX_ALLOC) return -1;
ffff000000000a08: e0 07 40 f9  	ldr	x0, [sp, #8]
ffff000000000a0c: 1f 00 20 f1  	cmp	x0, #2048
ffff000000000a10: 6d 00 00 54  	b.le	0xffff000000000a1c <size2level+0x30>
ffff000000000a14: 00 00 80 12  	mov	w0, #-1
ffff000000000a18: 10 00 00 14  	b	0xffff000000000a58 <size2level+0x6c>
;     int currSize = MIN_ALLOC;
ffff000000000a1c: 00 04 80 52  	mov	w0, #32
ffff000000000a20: e0 1f 00 b9  	str	w0, [sp, #28]
;     int idx = 0; 
ffff000000000a24: ff 1b 00 b9  	str	wzr, [sp, #24]
;     while (size > currSize) {
ffff000000000a28: 07 00 00 14  	b	0xffff000000000a44 <size2level+0x58>
;         currSize *= 2;
ffff000000000a2c: e0 1f 40 b9  	ldr	w0, [sp, #28]
ffff000000000a30: 00 78 1f 53  	lsl	w0, w0, #1
ffff000000000a34: e0 1f 00 b9  	str	w0, [sp, #28]
;         idx++;
ffff000000000a38: e0 1b 40 b9  	ldr	w0, [sp, #24]
ffff000000000a3c: 00 04 00 11  	add	w0, w0, #1
ffff000000000a40: e0 1b 00 b9  	str	w0, [sp, #24]
;     while (size > currSize) {
ffff000000000a44: e0 1f 80 b9  	ldrsw	x0, [sp, #28]
ffff000000000a48: e1 07 40 f9  	ldr	x1, [sp, #8]
ffff000000000a4c: 3f 00 00 eb  	cmp	x1, x0
ffff000000000a50: ec fe ff 54  	b.gt	0xffff000000000a2c <size2level+0x40>
;     return idx;
ffff000000000a54: e0 1b 40 b9  	ldr	w0, [sp, #24]
; }
ffff000000000a58: ff 83 00 91  	add	sp, sp, #32
ffff000000000a5c: c0 03 5f d6  	ret

ffff000000000a60 <alloc_super>:
; struct superblock_bookkeeping * alloc_super (int power) {
ffff000000000a60: fd 7b ba a9  	stp	x29, x30, [sp, #-96]!
ffff000000000a64: fd 03 00 91  	mov	x29, sp
ffff000000000a68: e0 1f 00 b9  	str	w0, [sp, #28]
;     int free_objects = 0, bytes_per_object = 0;
ffff000000000a6c: ff 5f 00 b9  	str	wzr, [sp, #92]
ffff000000000a70: ff 4f 00 b9  	str	wzr, [sp, #76]
;     page = alloc_page();
ffff000000000a74: 02 05 00 94  	bl	0xffff000000001e7c <alloc_page>
ffff000000000a78: e0 23 00 f9  	str	x0, [sp, #64]
;     if (page == 0x0) {
ffff000000000a7c: e0 23 40 f9  	ldr	x0, [sp, #64]
ffff000000000a80: 1f 00 00 f1  	cmp	x0, #0
ffff000000000a84: 21 01 00 54  	b.ne	0xffff000000000aa8 <alloc_super+0x48>
;         kprintf("Internel Error in KMalloc()");
ffff000000000a88: 20 00 00 90  	adrp	x0, #16384
ffff000000000a8c: 00 e0 11 91  	add	x0, x0, #1144
ffff000000000a90: 70 03 00 94  	bl	0xffff000000001850 <kprintf>
;         assert(page);
ffff000000000a94: e0 23 40 f9  	ldr	x0, [sp, #64]
ffff000000000a98: 1f 00 00 f1  	cmp	x0, #0
ffff000000000a9c: e0 07 9f 1a  	cset	w0, ne
ffff000000000aa0: 00 1c 00 12  	and	w0, w0, #0xff
ffff000000000aa4: 9d ff ff 97  	bl	0xffff000000000918 <assert>
;     sb = (struct superblock*) page;
ffff000000000aa8: e0 23 40 f9  	ldr	x0, [sp, #64]
ffff000000000aac: e0 1f 00 f9  	str	x0, [sp, #56]
;     sb->bkeep.next = levels[power].next;
ffff000000000ab0: 20 00 00 b0  	adrp	x0, #20480
ffff000000000ab4: 02 60 14 91  	add	x2, x0, #1304
ffff000000000ab8: e1 1f 80 b9  	ldrsw	x1, [sp, #28]
ffff000000000abc: e0 03 01 aa  	mov	x0, x1
ffff000000000ac0: 00 f8 7f d3  	lsl	x0, x0, #1
ffff000000000ac4: 00 00 01 8b  	add	x0, x0, x1
ffff000000000ac8: 00 f0 7d d3  	lsl	x0, x0, #3
ffff000000000acc: 40 00 00 8b  	add	x0, x2, x0
ffff000000000ad0: 01 00 40 f9  	ldr	x1, [x0]
ffff000000000ad4: e0 1f 40 f9  	ldr	x0, [sp, #56]
ffff000000000ad8: 01 00 00 f9  	str	x1, [x0]
;     levels[power].next = &sb->bkeep;
ffff000000000adc: e2 1f 40 f9  	ldr	x2, [sp, #56]
ffff000000000ae0: 20 00 00 b0  	adrp	x0, #20480
ffff000000000ae4: 03 60 14 91  	add	x3, x0, #1304
ffff000000000ae8: e1 1f 80 b9  	ldrsw	x1, [sp, #28]
ffff000000000aec: e0 03 01 aa  	mov	x0, x1
ffff000000000af0: 00 f8 7f d3  	lsl	x0, x0, #1
ffff000000000af4: 00 00 01 8b  	add	x0, x0, x1
ffff000000000af8: 00 f0 7d d3  	lsl	x0, x0, #3
ffff000000000afc: 60 00 00 8b  	add	x0, x3, x0
ffff000000000b00: 02 00 00 f9  	str	x2, [x0]
;     levels[power].whole_superblocks++;
ffff000000000b04: 20 00 00 b0  	adrp	x0, #20480
ffff000000000b08: 02 60 14 91  	add	x2, x0, #1304
ffff000000000b0c: e1 1f 80 b9  	ldrsw	x1, [sp, #28]
ffff000000000b10: e0 03 01 aa  	mov	x0, x1
ffff000000000b14: 00 f8 7f d3  	lsl	x0, x0, #1
ffff000000000b18: 00 00 01 8b  	add	x0, x0, x1
ffff000000000b1c: 00 f0 7d d3  	lsl	x0, x0, #3
ffff000000000b20: 40 00 00 8b  	add	x0, x2, x0
ffff000000000b24: 00 08 40 f9  	ldr	x0, [x0, #16]
ffff000000000b28: 02 04 00 91  	add	x2, x0, #1
ffff000000000b2c: 20 00 00 b0  	adrp	x0, #20480
ffff000000000b30: 03 60 14 91  	add	x3, x0, #1304
ffff000000000b34: e1 1f 80 b9  	ldrsw	x1, [sp, #28]
ffff000000000b38: e0 03 01 aa  	mov	x0, x1
ffff000000000b3c: 00 f8 7f d3  	lsl	x0, x0, #1
ffff000000000b40: 00 00 01 8b  	add	x0, x0, x1
ffff000000000b44: 00 f0 7d d3  	lsl	x0, x0, #3
ffff000000000b48: 60 00 00 8b  	add	x0, x3, x0
ffff000000000b4c: 02 08 00 f9  	str	x2, [x0, #16]
;     sb->bkeep.level = power;
ffff000000000b50: e0 1f 40 b9  	ldr	w0, [sp, #28]
ffff000000000b54: 01 1c 00 12  	and	w1, w0, #0xff
ffff000000000b58: e0 1f 40 f9  	ldr	x0, [sp, #56]
ffff000000000b5c: 01 44 00 39  	strb	w1, [x0, #17]
;     sb->bkeep.free_list = NULL;
ffff000000000b60: e0 1f 40 f9  	ldr	x0, [sp, #56]
ffff000000000b64: 1f 04 00 f9  	str	xzr, [x0, #8]
;     int truePower = power + 5;
ffff000000000b68: e0 1f 40 b9  	ldr	w0, [sp, #28]
ffff000000000b6c: 00 14 00 11  	add	w0, w0, #5
ffff000000000b70: e0 37 00 b9  	str	w0, [sp, #52]
;     bytes_per_object = myPower(2, truePower);
ffff000000000b74: e1 37 40 b9  	ldr	w1, [sp, #52]
ffff000000000b78: 40 00 80 52  	mov	w0, #2
ffff000000000b7c: 87 ff ff 97  	bl	0xffff000000000998 <myPower>
ffff000000000b80: e0 4f 00 b9  	str	w0, [sp, #76]
;     int bytes_in_superblock = SUPER_BLOCK_SIZE;
ffff000000000b84: 00 00 82 52  	mov	w0, #4096
ffff000000000b88: e0 33 00 b9  	str	w0, [sp, #48]
;     bytes_in_superblock -= bytes_per_object; // for the bookkeeping entry
ffff000000000b8c: e1 33 40 b9  	ldr	w1, [sp, #48]
ffff000000000b90: e0 4f 40 b9  	ldr	w0, [sp, #76]
ffff000000000b94: 20 00 00 4b  	sub	w0, w1, w0
ffff000000000b98: e0 33 00 b9  	str	w0, [sp, #48]
;     free_objects = ((int) (bytes_in_superblock / bytes_per_object));
ffff000000000b9c: e1 33 40 b9  	ldr	w1, [sp, #48]
ffff000000000ba0: e0 4f 40 b9  	ldr	w0, [sp, #76]
ffff000000000ba4: 20 0c c0 1a  	sdiv	w0, w1, w0
ffff000000000ba8: e0 5f 00 b9  	str	w0, [sp, #92]
;     levels[power].free_objects += free_objects;
ffff000000000bac: 20 00 00 b0  	adrp	x0, #20480
ffff000000000bb0: 02 60 14 91  	add	x2, x0, #1304
ffff000000000bb4: e1 1f 80 b9  	ldrsw	x1, [sp, #28]
ffff000000000bb8: e0 03 01 aa  	mov	x0, x1
ffff000000000bbc: 00 f8 7f d3  	lsl	x0, x0, #1
ffff000000000bc0: 00 00 01 8b  	add	x0, x0, x1
ffff000000000bc4: 00 f0 7d d3  	lsl	x0, x0, #3
ffff000000000bc8: 40 00 00 8b  	add	x0, x2, x0
ffff000000000bcc: 01 04 40 f9  	ldr	x1, [x0, #8]
ffff000000000bd0: e0 5f 80 b9  	ldrsw	x0, [sp, #92]
ffff000000000bd4: 22 00 00 8b  	add	x2, x1, x0
ffff000000000bd8: 20 00 00 b0  	adrp	x0, #20480
ffff000000000bdc: 03 60 14 91  	add	x3, x0, #1304
ffff000000000be0: e1 1f 80 b9  	ldrsw	x1, [sp, #28]
ffff000000000be4: e0 03 01 aa  	mov	x0, x1
ffff000000000be8: 00 f8 7f d3  	lsl	x0, x0, #1
ffff000000000bec: 00 00 01 8b  	add	x0, x0, x1
ffff000000000bf0: 00 f0 7d d3  	lsl	x0, x0, #3
ffff000000000bf4: 60 00 00 8b  	add	x0, x3, x0
ffff000000000bf8: 02 04 00 f9  	str	x2, [x0, #8]
;     sb->bkeep.free_count = free_objects;
ffff000000000bfc: e0 5f 40 b9  	ldr	w0, [sp, #92]
ffff000000000c00: 01 1c 00 12  	and	w1, w0, #0xff
ffff000000000c04: e0 1f 40 f9  	ldr	x0, [sp, #56]
ffff000000000c08: 01 40 00 39  	strb	w1, [x0, #16]
;     cursor = (char *) sb;
ffff000000000c0c: e0 1f 40 f9  	ldr	x0, [sp, #56]
ffff000000000c10: e0 2b 00 f9  	str	x0, [sp, #80]
;     for (cursor += bytes_per_object; free_objects--; cursor += bytes_per_object) {
ffff000000000c14: e0 4f 80 b9  	ldrsw	x0, [sp, #76]
ffff000000000c18: e1 2b 40 f9  	ldr	x1, [sp, #80]
ffff000000000c1c: 20 00 00 8b  	add	x0, x1, x0
ffff000000000c20: e0 2b 00 f9  	str	x0, [sp, #80]
ffff000000000c24: 0e 00 00 14  	b	0xffff000000000c5c <alloc_super+0x1fc>
;         struct object* tmp = (struct object *) cursor;
ffff000000000c28: e0 2b 40 f9  	ldr	x0, [sp, #80]
ffff000000000c2c: e0 17 00 f9  	str	x0, [sp, #40]
;         tmp->next = sb->bkeep.free_list;
ffff000000000c30: e0 1f 40 f9  	ldr	x0, [sp, #56]
ffff000000000c34: 01 04 40 f9  	ldr	x1, [x0, #8]
ffff000000000c38: e0 17 40 f9  	ldr	x0, [sp, #40]
ffff000000000c3c: 01 00 00 f9  	str	x1, [x0]
;         sb->bkeep.free_list = tmp;
ffff000000000c40: e0 1f 40 f9  	ldr	x0, [sp, #56]
ffff000000000c44: e1 17 40 f9  	ldr	x1, [sp, #40]
ffff000000000c48: 01 04 00 f9  	str	x1, [x0, #8]
;     for (cursor += bytes_per_object; free_objects--; cursor += bytes_per_object) {
ffff000000000c4c: e0 4f 80 b9  	ldrsw	x0, [sp, #76]
ffff000000000c50: e1 2b 40 f9  	ldr	x1, [sp, #80]
ffff000000000c54: 20 00 00 8b  	add	x0, x1, x0
ffff000000000c58: e0 2b 00 f9  	str	x0, [sp, #80]
ffff000000000c5c: e0 5f 40 b9  	ldr	w0, [sp, #92]
ffff000000000c60: 01 04 00 51  	sub	w1, w0, #1
ffff000000000c64: e1 5f 00 b9  	str	w1, [sp, #92]
ffff000000000c68: 1f 00 00 71  	cmp	w0, #0
ffff000000000c6c: e1 fd ff 54  	b.ne	0xffff000000000c28 <alloc_super+0x1c8>
;     return &sb->bkeep;
ffff000000000c70: e0 1f 40 f9  	ldr	x0, [sp, #56]
; }
ffff000000000c74: fd 7b c6 a8  	ldp	x29, x30, [sp], #96
ffff000000000c78: c0 03 5f d6  	ret

ffff000000000c7c <kmalloc>:
; void *kmalloc(size_t size) {
ffff000000000c7c: fd 7b ba a9  	stp	x29, x30, [sp, #-96]!
ffff000000000c80: fd 03 00 91  	mov	x29, sp
ffff000000000c84: f3 0b 00 f9  	str	x19, [sp, #16]
ffff000000000c88: e0 17 00 f9  	str	x0, [sp, #40]
;     void *rv = NULL;
ffff000000000c8c: ff 2b 00 f9  	str	xzr, [sp, #80]
;     int power = size2level(size);
ffff000000000c90: e0 17 40 f9  	ldr	x0, [sp, #40]
ffff000000000c94: 56 ff ff 97  	bl	0xffff0000000009ec <size2level>
ffff000000000c98: e0 4f 00 b9  	str	w0, [sp, #76]
;     if (size > MAX_ALLOC) {
ffff000000000c9c: e0 17 40 f9  	ldr	x0, [sp, #40]
ffff000000000ca0: 1f 00 20 f1  	cmp	x0, #2048
ffff000000000ca4: c9 00 00 54  	b.ls	0xffff000000000cbc <kmalloc+0x40>
;         kprintf("Cannot alloc with a size this large!\n");
ffff000000000ca8: 20 00 00 90  	adrp	x0, #16384
ffff000000000cac: 00 60 12 91  	add	x0, x0, #1176
ffff000000000cb0: e8 02 00 94  	bl	0xffff000000001850 <kprintf>
;         return 0x0;
ffff000000000cb4: 00 00 80 d2  	mov	x0, #0
ffff000000000cb8: 53 00 00 14  	b	0xffff000000000e04 <kmalloc+0x188>
;     pool = &levels[power];
ffff000000000cbc: e1 4f 80 b9  	ldrsw	x1, [sp, #76]
ffff000000000cc0: e0 03 01 aa  	mov	x0, x1
ffff000000000cc4: 00 f8 7f d3  	lsl	x0, x0, #1
ffff000000000cc8: 00 00 01 8b  	add	x0, x0, x1
ffff000000000ccc: 00 f0 7d d3  	lsl	x0, x0, #3
ffff000000000cd0: 21 00 00 b0  	adrp	x1, #20480
ffff000000000cd4: 21 60 14 91  	add	x1, x1, #1304
ffff000000000cd8: 00 00 01 8b  	add	x0, x0, x1
ffff000000000cdc: e0 23 00 f9  	str	x0, [sp, #64]
;     if (!pool->free_objects) {
ffff000000000ce0: e0 23 40 f9  	ldr	x0, [sp, #64]
ffff000000000ce4: 00 04 40 f9  	ldr	x0, [x0, #8]
ffff000000000ce8: 1f 00 00 f1  	cmp	x0, #0
ffff000000000cec: a1 00 00 54  	b.ne	0xffff000000000d00 <kmalloc+0x84>
;         bkeep = alloc_super(power);
ffff000000000cf0: e0 4f 40 b9  	ldr	w0, [sp, #76]
ffff000000000cf4: 5b ff ff 97  	bl	0xffff000000000a60 <alloc_super>
ffff000000000cf8: e0 2f 00 f9  	str	x0, [sp, #88]
ffff000000000cfc: 33 00 00 14  	b	0xffff000000000dc8 <kmalloc+0x14c>
;         bkeep = pool->next;
ffff000000000d00: e0 23 40 f9  	ldr	x0, [sp, #64]
ffff000000000d04: 00 00 40 f9  	ldr	x0, [x0]
ffff000000000d08: e0 2f 00 f9  	str	x0, [sp, #88]
;     for ( ; bkeep != NULL; bkeep = bkeep->next) {
ffff000000000d0c: 2f 00 00 14  	b	0xffff000000000dc8 <kmalloc+0x14c>
;         if (bkeep->free_count) {
ffff000000000d10: e0 2f 40 f9  	ldr	x0, [sp, #88]
ffff000000000d14: 00 40 40 39  	ldrb	w0, [x0, #16]
ffff000000000d18: 1f 00 00 71  	cmp	w0, #0
ffff000000000d1c: 00 05 00 54  	b.eq	0xffff000000000dbc <kmalloc+0x140>
;             struct object *cursor = bkeep->free_list;
ffff000000000d20: e0 2f 40 f9  	ldr	x0, [sp, #88]
ffff000000000d24: 00 04 40 f9  	ldr	x0, [x0, #8]
ffff000000000d28: e0 1f 00 f9  	str	x0, [sp, #56]
;             rv = cursor;
ffff000000000d2c: e0 1f 40 f9  	ldr	x0, [sp, #56]
ffff000000000d30: e0 2b 00 f9  	str	x0, [sp, #80]
;             bkeep->free_list = cursor->next;
ffff000000000d34: e0 1f 40 f9  	ldr	x0, [sp, #56]
ffff000000000d38: 01 00 40 f9  	ldr	x1, [x0]
ffff000000000d3c: e0 2f 40 f9  	ldr	x0, [sp, #88]
ffff000000000d40: 01 04 00 f9  	str	x1, [x0, #8]
;             if (bkeep->free_count + 1 == (SUPER_BLOCK_SIZE/ ((int) myPower(2,(power + 5))))) {
ffff000000000d44: e0 2f 40 f9  	ldr	x0, [sp, #88]
ffff000000000d48: 00 40 40 39  	ldrb	w0, [x0, #16]
ffff000000000d4c: 13 04 00 11  	add	w19, w0, #1
ffff000000000d50: e0 4f 40 b9  	ldr	w0, [sp, #76]
ffff000000000d54: 00 14 00 11  	add	w0, w0, #5
ffff000000000d58: e1 03 00 2a  	mov	w1, w0
ffff000000000d5c: 40 00 80 52  	mov	w0, #2
ffff000000000d60: 0e ff ff 97  	bl	0xffff000000000998 <myPower>
ffff000000000d64: e1 03 00 2a  	mov	w1, w0
ffff000000000d68: 00 00 82 52  	mov	w0, #4096
ffff000000000d6c: 00 0c c1 1a  	sdiv	w0, w0, w1
ffff000000000d70: 7f 02 00 6b  	cmp	w19, w0
ffff000000000d74: c1 00 00 54  	b.ne	0xffff000000000d8c <kmalloc+0x110>
;                 pool->whole_superblocks--;
ffff000000000d78: e0 23 40 f9  	ldr	x0, [sp, #64]
ffff000000000d7c: 00 08 40 f9  	ldr	x0, [x0, #16]
ffff000000000d80: 01 04 00 d1  	sub	x1, x0, #1
ffff000000000d84: e0 23 40 f9  	ldr	x0, [sp, #64]
ffff000000000d88: 01 08 00 f9  	str	x1, [x0, #16]
;             pool->free_objects--;
ffff000000000d8c: e0 23 40 f9  	ldr	x0, [sp, #64]
ffff000000000d90: 00 04 40 f9  	ldr	x0, [x0, #8]
ffff000000000d94: 01 04 00 d1  	sub	x1, x0, #1
ffff000000000d98: e0 23 40 f9  	ldr	x0, [sp, #64]
ffff000000000d9c: 01 04 00 f9  	str	x1, [x0, #8]
;             bkeep->free_count--;
ffff000000000da0: e0 2f 40 f9  	ldr	x0, [sp, #88]
ffff000000000da4: 00 40 40 39  	ldrb	w0, [x0, #16]
ffff000000000da8: 00 04 00 51  	sub	w0, w0, #1
ffff000000000dac: 01 1c 00 12  	and	w1, w0, #0xff
ffff000000000db0: e0 2f 40 f9  	ldr	x0, [sp, #88]
ffff000000000db4: 01 40 00 39  	strb	w1, [x0, #16]
;             break;
ffff000000000db8: 07 00 00 14  	b	0xffff000000000dd4 <kmalloc+0x158>
;     for ( ; bkeep != NULL; bkeep = bkeep->next) {
ffff000000000dbc: e0 2f 40 f9  	ldr	x0, [sp, #88]
ffff000000000dc0: 00 00 40 f9  	ldr	x0, [x0]
ffff000000000dc4: e0 2f 00 f9  	str	x0, [sp, #88]
ffff000000000dc8: e0 2f 40 f9  	ldr	x0, [sp, #88]
ffff000000000dcc: 1f 00 00 f1  	cmp	x0, #0
ffff000000000dd0: 01 fa ff 54  	b.ne	0xffff000000000d10 <kmalloc+0x94>
;     if (rv == NULL) {
ffff000000000dd4: e0 2b 40 f9  	ldr	x0, [sp, #80]
ffff000000000dd8: 1f 00 00 f1  	cmp	x0, #0
ffff000000000ddc: 21 01 00 54  	b.ne	0xffff000000000e00 <kmalloc+0x184>
;         kprintf("Something went wrong with kmalloc!\n");
ffff000000000de0: 20 00 00 90  	adrp	x0, #16384
ffff000000000de4: 00 00 13 91  	add	x0, x0, #1216
ffff000000000de8: 9a 02 00 94  	bl	0xffff000000001850 <kprintf>
;         assert(rv != NULL);
ffff000000000dec: e0 2b 40 f9  	ldr	x0, [sp, #80]
ffff000000000df0: 1f 00 00 f1  	cmp	x0, #0
ffff000000000df4: e0 07 9f 1a  	cset	w0, ne
ffff000000000df8: 00 1c 00 12  	and	w0, w0, #0xff
ffff000000000dfc: c7 fe ff 97  	bl	0xffff000000000918 <assert>
;     return rv;
ffff000000000e00: e0 2b 40 f9  	ldr	x0, [sp, #80]
; }
ffff000000000e04: f3 0b 40 f9  	ldr	x19, [sp, #16]
ffff000000000e08: fd 7b c6 a8  	ldp	x29, x30, [sp], #96
ffff000000000e0c: c0 03 5f d6  	ret

ffff000000000e10 <obj2bkeep>:
; struct superblock_bookkeeping * obj2bkeep (void *ptr) {
ffff000000000e10: ff 83 00 d1  	sub	sp, sp, #32
ffff000000000e14: e0 07 00 f9  	str	x0, [sp, #8]
;     uint64_t addr = (uint64_t) ptr;
ffff000000000e18: e0 07 40 f9  	ldr	x0, [sp, #8]
ffff000000000e1c: e0 0f 00 f9  	str	x0, [sp, #24]
;     addr &= SUPER_BLOCK_MASK;
ffff000000000e20: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff000000000e24: 00 cc 74 92  	and	x0, x0, #0xfffffffffffff000
ffff000000000e28: e0 0f 00 f9  	str	x0, [sp, #24]
;     return (struct superblock_bookkeeping *) addr;
ffff000000000e2c: e0 0f 40 f9  	ldr	x0, [sp, #24]
; }
ffff000000000e30: ff 83 00 91  	add	sp, sp, #32
ffff000000000e34: c0 03 5f d6  	ret

ffff000000000e38 <kfree>:
; void kfree(void *ptr) {
ffff000000000e38: fd 7b b9 a9  	stp	x29, x30, [sp, #-112]!
ffff000000000e3c: fd 03 00 91  	mov	x29, sp
ffff000000000e40: f3 0b 00 f9  	str	x19, [sp, #16]
ffff000000000e44: e0 17 00 f9  	str	x0, [sp, #40]
;     if (ptr == NULL) return;
ffff000000000e48: e0 17 40 f9  	ldr	x0, [sp, #40]
ffff000000000e4c: 1f 00 00 f1  	cmp	x0, #0
ffff000000000e50: 40 16 00 54  	b.eq	0xffff000000001118 <kfree+0x2e0>
;     struct superblock_bookkeeping *bkeep = obj2bkeep(ptr);
ffff000000000e54: e0 17 40 f9  	ldr	x0, [sp, #40]
ffff000000000e58: ee ff ff 97  	bl	0xffff000000000e10 <obj2bkeep>
ffff000000000e5c: e0 2f 00 f9  	str	x0, [sp, #88]
;     int power = bkeep->level;
ffff000000000e60: e0 2f 40 f9  	ldr	x0, [sp, #88]
ffff000000000e64: 00 44 40 39  	ldrb	w0, [x0, #17]
ffff000000000e68: e0 57 00 b9  	str	w0, [sp, #84]
;     bkeep->free_count++;
ffff000000000e6c: e0 2f 40 f9  	ldr	x0, [sp, #88]
ffff000000000e70: 00 40 40 39  	ldrb	w0, [x0, #16]
ffff000000000e74: 00 04 00 11  	add	w0, w0, #1
ffff000000000e78: 01 1c 00 12  	and	w1, w0, #0xff
ffff000000000e7c: e0 2f 40 f9  	ldr	x0, [sp, #88]
ffff000000000e80: 01 40 00 39  	strb	w1, [x0, #16]
;     struct object *obj = (struct object *) ptr;
ffff000000000e84: e0 17 40 f9  	ldr	x0, [sp, #40]
ffff000000000e88: e0 27 00 f9  	str	x0, [sp, #72]
;     obj->next = bkeep->free_list;
ffff000000000e8c: e0 2f 40 f9  	ldr	x0, [sp, #88]
ffff000000000e90: 01 04 40 f9  	ldr	x1, [x0, #8]
ffff000000000e94: e0 27 40 f9  	ldr	x0, [sp, #72]
ffff000000000e98: 01 00 00 f9  	str	x1, [x0]
;     bkeep->free_list = obj;
ffff000000000e9c: e0 2f 40 f9  	ldr	x0, [sp, #88]
ffff000000000ea0: e1 27 40 f9  	ldr	x1, [sp, #72]
ffff000000000ea4: 01 04 00 f9  	str	x1, [x0, #8]
;     levels[bkeep->level].free_objects++;
ffff000000000ea8: e0 2f 40 f9  	ldr	x0, [sp, #88]
ffff000000000eac: 00 44 40 39  	ldrb	w0, [x0, #17]
ffff000000000eb0: e4 03 00 2a  	mov	w4, w0
ffff000000000eb4: 20 00 00 b0  	adrp	x0, #20480
ffff000000000eb8: 02 60 14 91  	add	x2, x0, #1304
ffff000000000ebc: 81 7c 40 93  	sxtw	x1, w4
ffff000000000ec0: e0 03 01 aa  	mov	x0, x1
ffff000000000ec4: 00 f8 7f d3  	lsl	x0, x0, #1
ffff000000000ec8: 00 00 01 8b  	add	x0, x0, x1
ffff000000000ecc: 00 f0 7d d3  	lsl	x0, x0, #3
ffff000000000ed0: 40 00 00 8b  	add	x0, x2, x0
ffff000000000ed4: 00 04 40 f9  	ldr	x0, [x0, #8]
ffff000000000ed8: 02 04 00 91  	add	x2, x0, #1
ffff000000000edc: 20 00 00 b0  	adrp	x0, #20480
ffff000000000ee0: 03 60 14 91  	add	x3, x0, #1304
ffff000000000ee4: 81 7c 40 93  	sxtw	x1, w4
ffff000000000ee8: e0 03 01 aa  	mov	x0, x1
ffff000000000eec: 00 f8 7f d3  	lsl	x0, x0, #1
ffff000000000ef0: 00 00 01 8b  	add	x0, x0, x1
ffff000000000ef4: 00 f0 7d d3  	lsl	x0, x0, #3
ffff000000000ef8: 60 00 00 8b  	add	x0, x3, x0
ffff000000000efc: 02 04 00 f9  	str	x2, [x0, #8]
;     if ((bkeep->free_count + 1) == (SUPER_BLOCK_SIZE/myPower(2, 5 + bkeep->level))) {
ffff000000000f00: e0 2f 40 f9  	ldr	x0, [sp, #88]
ffff000000000f04: 00 40 40 39  	ldrb	w0, [x0, #16]
ffff000000000f08: 13 04 00 11  	add	w19, w0, #1
ffff000000000f0c: e0 2f 40 f9  	ldr	x0, [sp, #88]
ffff000000000f10: 00 44 40 39  	ldrb	w0, [x0, #17]
ffff000000000f14: 00 14 00 11  	add	w0, w0, #5
ffff000000000f18: e1 03 00 2a  	mov	w1, w0
ffff000000000f1c: 40 00 80 52  	mov	w0, #2
ffff000000000f20: 9e fe ff 97  	bl	0xffff000000000998 <myPower>
ffff000000000f24: e1 03 00 2a  	mov	w1, w0
ffff000000000f28: 00 00 82 52  	mov	w0, #4096
ffff000000000f2c: 00 0c c1 1a  	sdiv	w0, w0, w1
ffff000000000f30: 7f 02 00 6b  	cmp	w19, w0
ffff000000000f34: a1 0d 00 54  	b.ne	0xffff0000000010e8 <kfree+0x2b0>
;         levels[bkeep->level].whole_superblocks++;
ffff000000000f38: e0 2f 40 f9  	ldr	x0, [sp, #88]
ffff000000000f3c: 00 44 40 39  	ldrb	w0, [x0, #17]
ffff000000000f40: e4 03 00 2a  	mov	w4, w0
ffff000000000f44: 20 00 00 b0  	adrp	x0, #20480
ffff000000000f48: 02 60 14 91  	add	x2, x0, #1304
ffff000000000f4c: 81 7c 40 93  	sxtw	x1, w4
ffff000000000f50: e0 03 01 aa  	mov	x0, x1
ffff000000000f54: 00 f8 7f d3  	lsl	x0, x0, #1
ffff000000000f58: 00 00 01 8b  	add	x0, x0, x1
ffff000000000f5c: 00 f0 7d d3  	lsl	x0, x0, #3
ffff000000000f60: 40 00 00 8b  	add	x0, x2, x0
ffff000000000f64: 00 08 40 f9  	ldr	x0, [x0, #16]
ffff000000000f68: 02 04 00 91  	add	x2, x0, #1
ffff000000000f6c: 20 00 00 b0  	adrp	x0, #20480
ffff000000000f70: 03 60 14 91  	add	x3, x0, #1304
ffff000000000f74: 81 7c 40 93  	sxtw	x1, w4
ffff000000000f78: e0 03 01 aa  	mov	x0, x1
ffff000000000f7c: 00 f8 7f d3  	lsl	x0, x0, #1
ffff000000000f80: 00 00 01 8b  	add	x0, x0, x1
ffff000000000f84: 00 f0 7d d3  	lsl	x0, x0, #3
ffff000000000f88: 60 00 00 8b  	add	x0, x3, x0
ffff000000000f8c: 02 08 00 f9  	str	x2, [x0, #16]
;     while (levels[power].whole_superblocks > RESERVE_SUPERBLOCK_THRESHOLD) {
ffff000000000f90: 56 00 00 14  	b	0xffff0000000010e8 <kfree+0x2b0>
;         levels[power].whole_superblocks--;
ffff000000000f94: 20 00 00 b0  	adrp	x0, #20480
ffff000000000f98: 02 60 14 91  	add	x2, x0, #1304
ffff000000000f9c: e1 57 80 b9  	ldrsw	x1, [sp, #84]
ffff000000000fa0: e0 03 01 aa  	mov	x0, x1
ffff000000000fa4: 00 f8 7f d3  	lsl	x0, x0, #1
ffff000000000fa8: 00 00 01 8b  	add	x0, x0, x1
ffff000000000fac: 00 f0 7d d3  	lsl	x0, x0, #3
ffff000000000fb0: 40 00 00 8b  	add	x0, x2, x0
ffff000000000fb4: 00 08 40 f9  	ldr	x0, [x0, #16]
ffff000000000fb8: 02 04 00 d1  	sub	x2, x0, #1
ffff000000000fbc: 20 00 00 b0  	adrp	x0, #20480
ffff000000000fc0: 03 60 14 91  	add	x3, x0, #1304
ffff000000000fc4: e1 57 80 b9  	ldrsw	x1, [sp, #84]
ffff000000000fc8: e0 03 01 aa  	mov	x0, x1
ffff000000000fcc: 00 f8 7f d3  	lsl	x0, x0, #1
ffff000000000fd0: 00 00 01 8b  	add	x0, x0, x1
ffff000000000fd4: 00 f0 7d d3  	lsl	x0, x0, #3
ffff000000000fd8: 60 00 00 8b  	add	x0, x3, x0
ffff000000000fdc: 02 08 00 f9  	str	x2, [x0, #16]
;         struct superblock_bookkeeping *ptr = levels[power].next;
ffff000000000fe0: 20 00 00 b0  	adrp	x0, #20480
ffff000000000fe4: 02 60 14 91  	add	x2, x0, #1304
ffff000000000fe8: e1 57 80 b9  	ldrsw	x1, [sp, #84]
ffff000000000fec: e0 03 01 aa  	mov	x0, x1
ffff000000000ff0: 00 f8 7f d3  	lsl	x0, x0, #1
ffff000000000ff4: 00 00 01 8b  	add	x0, x0, x1
ffff000000000ff8: 00 f0 7d d3  	lsl	x0, x0, #3
ffff000000000ffc: 40 00 00 8b  	add	x0, x2, x0
ffff000000001000: 00 00 40 f9  	ldr	x0, [x0]
ffff000000001004: e0 37 00 f9  	str	x0, [sp, #104]
;         int numItemsToBeFullyFree = SUPER_BLOCK_SIZE/myPower(2, power + 5) - 1;
ffff000000001008: e0 57 40 b9  	ldr	w0, [sp, #84]
ffff00000000100c: 00 14 00 11  	add	w0, w0, #5
ffff000000001010: e1 03 00 2a  	mov	w1, w0
ffff000000001014: 40 00 80 52  	mov	w0, #2
ffff000000001018: 60 fe ff 97  	bl	0xffff000000000998 <myPower>
ffff00000000101c: e1 03 00 2a  	mov	w1, w0
ffff000000001020: 00 00 82 52  	mov	w0, #4096
ffff000000001024: 00 0c c1 1a  	sdiv	w0, w0, w1
ffff000000001028: 00 04 00 51  	sub	w0, w0, #1
ffff00000000102c: e0 47 00 b9  	str	w0, [sp, #68]
;         if (ptr->free_count == numItemsToBeFullyFree) {
ffff000000001030: e0 37 40 f9  	ldr	x0, [sp, #104]
ffff000000001034: 00 40 40 39  	ldrb	w0, [x0, #16]
ffff000000001038: e1 03 00 2a  	mov	w1, w0
ffff00000000103c: e0 47 40 b9  	ldr	w0, [sp, #68]
ffff000000001040: 1f 00 01 6b  	cmp	w0, w1
ffff000000001044: 21 02 00 54  	b.ne	0xffff000000001088 <kfree+0x250>
;             struct superblock_bookkeeping *copy = ptr;
ffff000000001048: e0 37 40 f9  	ldr	x0, [sp, #104]
ffff00000000104c: e0 1f 00 f9  	str	x0, [sp, #56]
;             levels[power].next = ptr->next;
ffff000000001050: e0 37 40 f9  	ldr	x0, [sp, #104]
ffff000000001054: 02 00 40 f9  	ldr	x2, [x0]
ffff000000001058: 20 00 00 90  	adrp	x0, #16384
ffff00000000105c: 03 60 14 91  	add	x3, x0, #1304
ffff000000001060: e1 57 80 b9  	ldrsw	x1, [sp, #84]
ffff000000001064: e0 03 01 aa  	mov	x0, x1
ffff000000001068: 00 f8 7f d3  	lsl	x0, x0, #1
ffff00000000106c: 00 00 01 8b  	add	x0, x0, x1
ffff000000001070: 00 f0 7d d3  	lsl	x0, x0, #3
ffff000000001074: 60 00 00 8b  	add	x0, x3, x0
ffff000000001078: 02 00 00 f9  	str	x2, [x0]
;             free_page(copy);
ffff00000000107c: e0 1f 40 f9  	ldr	x0, [sp, #56]
ffff000000001080: af 03 00 94  	bl	0xffff000000001f3c <free_page>
ffff000000001084: 19 00 00 14  	b	0xffff0000000010e8 <kfree+0x2b0>
;             struct superblock_bookkeeping *prev = ptr;
ffff000000001088: e0 37 40 f9  	ldr	x0, [sp, #104]
ffff00000000108c: e0 33 00 f9  	str	x0, [sp, #96]
;             ptr = ptr->next;
ffff000000001090: e0 37 40 f9  	ldr	x0, [sp, #104]
ffff000000001094: 00 00 40 f9  	ldr	x0, [x0]
ffff000000001098: e0 37 00 f9  	str	x0, [sp, #104]
;             while (ptr->free_count != numItemsToBeFullyFree) {
ffff00000000109c: 07 00 00 14  	b	0xffff0000000010b8 <kfree+0x280>
;                 ptr = ptr->next;
ffff0000000010a0: e0 37 40 f9  	ldr	x0, [sp, #104]
ffff0000000010a4: 00 00 40 f9  	ldr	x0, [x0]
ffff0000000010a8: e0 37 00 f9  	str	x0, [sp, #104]
;                 prev = prev->next;
ffff0000000010ac: e0 33 40 f9  	ldr	x0, [sp, #96]
ffff0000000010b0: 00 00 40 f9  	ldr	x0, [x0]
ffff0000000010b4: e0 33 00 f9  	str	x0, [sp, #96]
;             while (ptr->free_count != numItemsToBeFullyFree) {
ffff0000000010b8: e0 37 40 f9  	ldr	x0, [sp, #104]
ffff0000000010bc: 00 40 40 39  	ldrb	w0, [x0, #16]
ffff0000000010c0: e1 03 00 2a  	mov	w1, w0
ffff0000000010c4: e0 47 40 b9  	ldr	w0, [sp, #68]
ffff0000000010c8: 1f 00 01 6b  	cmp	w0, w1
ffff0000000010cc: a1 fe ff 54  	b.ne	0xffff0000000010a0 <kfree+0x268>
;             prev->next = ptr->next;
ffff0000000010d0: e0 37 40 f9  	ldr	x0, [sp, #104]
ffff0000000010d4: 01 00 40 f9  	ldr	x1, [x0]
ffff0000000010d8: e0 33 40 f9  	ldr	x0, [sp, #96]
ffff0000000010dc: 01 00 00 f9  	str	x1, [x0]
;             free_page(ptr);
ffff0000000010e0: e0 37 40 f9  	ldr	x0, [sp, #104]
ffff0000000010e4: 96 03 00 94  	bl	0xffff000000001f3c <free_page>
;     while (levels[power].whole_superblocks > RESERVE_SUPERBLOCK_THRESHOLD) {
ffff0000000010e8: 20 00 00 90  	adrp	x0, #16384
ffff0000000010ec: 02 60 14 91  	add	x2, x0, #1304
ffff0000000010f0: e1 57 80 b9  	ldrsw	x1, [sp, #84]
ffff0000000010f4: e0 03 01 aa  	mov	x0, x1
ffff0000000010f8: 00 f8 7f d3  	lsl	x0, x0, #1
ffff0000000010fc: 00 00 01 8b  	add	x0, x0, x1
ffff000000001100: 00 f0 7d d3  	lsl	x0, x0, #3
ffff000000001104: 40 00 00 8b  	add	x0, x2, x0
ffff000000001108: 00 08 40 f9  	ldr	x0, [x0, #16]
ffff00000000110c: 1f 08 00 f1  	cmp	x0, #2
ffff000000001110: 28 f4 ff 54  	b.hi	0xffff000000000f94 <kfree+0x15c>
ffff000000001114: 02 00 00 14  	b	0xffff00000000111c <kfree+0x2e4>
;     if (ptr == NULL) return;
ffff000000001118: 1f 20 03 d5  	nop
; }
ffff00000000111c: f3 0b 40 f9  	ldr	x19, [sp, #16]
ffff000000001120: fd 7b c7 a8  	ldp	x29, x30, [sp], #112
ffff000000001124: c0 03 5f d6  	ret

ffff000000001128 <kmalloc_test>:
; void kmalloc_test() {
ffff000000001128: fd 7b b7 a9  	stp	x29, x30, [sp, #-144]!
ffff00000000112c: fd 03 00 91  	mov	x29, sp
ffff000000001130: f3 0b 00 f9  	str	x19, [sp, #16]
;     void *prev = NULL;
ffff000000001134: ff 47 00 f9  	str	xzr, [sp, #136]
;     for (int i = 0; i < 2500; ++i) {
ffff000000001138: ff 87 00 b9  	str	wzr, [sp, #132]
ffff00000000113c: 17 00 00 14  	b	0xffff000000001198 <kmalloc_test+0x70>
;         void *new = kmalloc(64);
ffff000000001140: 00 08 80 d2  	mov	x0, #64
ffff000000001144: ce fe ff 97  	bl	0xffff000000000c7c <kmalloc>
ffff000000001148: e0 13 00 f9  	str	x0, [sp, #32]
;         if (i == 0) prev = new+64;
ffff00000000114c: e0 87 40 b9  	ldr	w0, [sp, #132]
ffff000000001150: 1f 00 00 71  	cmp	w0, #0
ffff000000001154: 81 00 00 54  	b.ne	0xffff000000001164 <kmalloc_test+0x3c>
ffff000000001158: e0 13 40 f9  	ldr	x0, [sp, #32]
ffff00000000115c: 00 00 01 91  	add	x0, x0, #64
ffff000000001160: e0 47 00 f9  	str	x0, [sp, #136]
;         if (prev - new != 64) 
ffff000000001164: e1 47 40 f9  	ldr	x1, [sp, #136]
ffff000000001168: e0 13 40 f9  	ldr	x0, [sp, #32]
ffff00000000116c: 20 00 00 cb  	sub	x0, x1, x0
ffff000000001170: 1f 00 01 f1  	cmp	x0, #64
ffff000000001174: 80 00 00 54  	b.eq	0xffff000000001184 <kmalloc_test+0x5c>
;             kprintf("There should have been a call to alloc_page()");
ffff000000001178: 00 00 00 f0  	adrp	x0, #12288
ffff00000000117c: 00 a0 13 91  	add	x0, x0, #1256
ffff000000001180: b4 01 00 94  	bl	0xffff000000001850 <kprintf>
;         prev = new;
ffff000000001184: e0 13 40 f9  	ldr	x0, [sp, #32]
ffff000000001188: e0 47 00 f9  	str	x0, [sp, #136]
;     for (int i = 0; i < 2500; ++i) {
ffff00000000118c: e0 87 40 b9  	ldr	w0, [sp, #132]
ffff000000001190: 00 04 00 11  	add	w0, w0, #1
ffff000000001194: e0 87 00 b9  	str	w0, [sp, #132]
ffff000000001198: e0 87 40 b9  	ldr	w0, [sp, #132]
ffff00000000119c: 1f 0c 27 71  	cmp	w0, #2499
ffff0000000011a0: 0d fd ff 54  	b.le	0xffff000000001140 <kmalloc_test+0x18>
;     void *a = kmalloc(32);
ffff0000000011a4: 00 04 80 d2  	mov	x0, #32
ffff0000000011a8: b5 fe ff 97  	bl	0xffff000000000c7c <kmalloc>
ffff0000000011ac: e0 3f 00 f9  	str	x0, [sp, #120]
;     void *b = kmalloc(32);
ffff0000000011b0: 00 04 80 d2  	mov	x0, #32
ffff0000000011b4: b2 fe ff 97  	bl	0xffff000000000c7c <kmalloc>
ffff0000000011b8: e0 3b 00 f9  	str	x0, [sp, #112]
;     void *c = kmalloc(32);
ffff0000000011bc: 00 04 80 d2  	mov	x0, #32
ffff0000000011c0: af fe ff 97  	bl	0xffff000000000c7c <kmalloc>
ffff0000000011c4: e0 37 00 f9  	str	x0, [sp, #104]
;     void *d = kmalloc(32);
ffff0000000011c8: 00 04 80 d2  	mov	x0, #32
ffff0000000011cc: ac fe ff 97  	bl	0xffff000000000c7c <kmalloc>
ffff0000000011d0: e0 33 00 f9  	str	x0, [sp, #96]
;     void *e = kmalloc(32);
ffff0000000011d4: 00 04 80 d2  	mov	x0, #32
ffff0000000011d8: a9 fe ff 97  	bl	0xffff000000000c7c <kmalloc>
ffff0000000011dc: e0 2f 00 f9  	str	x0, [sp, #88]
;     void *f = kmalloc(32);
ffff0000000011e0: 00 04 80 d2  	mov	x0, #32
ffff0000000011e4: a6 fe ff 97  	bl	0xffff000000000c7c <kmalloc>
ffff0000000011e8: e0 2b 00 f9  	str	x0, [sp, #80]
;     void *g = kmalloc(32);
ffff0000000011ec: 00 04 80 d2  	mov	x0, #32
ffff0000000011f0: a3 fe ff 97  	bl	0xffff000000000c7c <kmalloc>
ffff0000000011f4: e0 27 00 f9  	str	x0, [sp, #72]
;     void *h = kmalloc(32);
ffff0000000011f8: 00 04 80 d2  	mov	x0, #32
ffff0000000011fc: a0 fe ff 97  	bl	0xffff000000000c7c <kmalloc>
ffff000000001200: e0 23 00 f9  	str	x0, [sp, #64]
;     void *i = kmalloc(32);
ffff000000001204: 00 04 80 d2  	mov	x0, #32
ffff000000001208: 9d fe ff 97  	bl	0xffff000000000c7c <kmalloc>
ffff00000000120c: e0 1f 00 f9  	str	x0, [sp, #56]
;     void *j = kmalloc(32);
ffff000000001210: 00 04 80 d2  	mov	x0, #32
ffff000000001214: 9a fe ff 97  	bl	0xffff000000000c7c <kmalloc>
ffff000000001218: e0 1b 00 f9  	str	x0, [sp, #48]
;     void *k = kmalloc(32);
ffff00000000121c: 00 04 80 d2  	mov	x0, #32
ffff000000001220: 97 fe ff 97  	bl	0xffff000000000c7c <kmalloc>
ffff000000001224: e0 17 00 f9  	str	x0, [sp, #40]
;     kfree(a);
ffff000000001228: e0 3f 40 f9  	ldr	x0, [sp, #120]
ffff00000000122c: 03 ff ff 97  	bl	0xffff000000000e38 <kfree>
;     assert(a == kmalloc(32));
ffff000000001230: 00 04 80 d2  	mov	x0, #32
ffff000000001234: 92 fe ff 97  	bl	0xffff000000000c7c <kmalloc>
ffff000000001238: e1 03 00 aa  	mov	x1, x0
ffff00000000123c: e0 3f 40 f9  	ldr	x0, [sp, #120]
ffff000000001240: 1f 00 01 eb  	cmp	x0, x1
ffff000000001244: e0 17 9f 1a  	cset	w0, eq
ffff000000001248: 00 1c 00 12  	and	w0, w0, #0xff
ffff00000000124c: b3 fd ff 97  	bl	0xffff000000000918 <assert>
;     a = kmalloc(32);
ffff000000001250: 00 04 80 d2  	mov	x0, #32
ffff000000001254: 8a fe ff 97  	bl	0xffff000000000c7c <kmalloc>
ffff000000001258: e0 3f 00 f9  	str	x0, [sp, #120]
;     kfree(k);
ffff00000000125c: e0 17 40 f9  	ldr	x0, [sp, #40]
ffff000000001260: f6 fe ff 97  	bl	0xffff000000000e38 <kfree>
;     assert(k == kmalloc(32));
ffff000000001264: 00 04 80 d2  	mov	x0, #32
ffff000000001268: 85 fe ff 97  	bl	0xffff000000000c7c <kmalloc>
ffff00000000126c: e1 03 00 aa  	mov	x1, x0
ffff000000001270: e0 17 40 f9  	ldr	x0, [sp, #40]
ffff000000001274: 1f 00 01 eb  	cmp	x0, x1
ffff000000001278: e0 17 9f 1a  	cset	w0, eq
ffff00000000127c: 00 1c 00 12  	and	w0, w0, #0xff
ffff000000001280: a6 fd ff 97  	bl	0xffff000000000918 <assert>
;     k = kmalloc(32);
ffff000000001284: 00 04 80 d2  	mov	x0, #32
ffff000000001288: 7d fe ff 97  	bl	0xffff000000000c7c <kmalloc>
ffff00000000128c: e0 17 00 f9  	str	x0, [sp, #40]
;     kfree(b);
ffff000000001290: e0 3b 40 f9  	ldr	x0, [sp, #112]
ffff000000001294: e9 fe ff 97  	bl	0xffff000000000e38 <kfree>
;     kfree(c);
ffff000000001298: e0 37 40 f9  	ldr	x0, [sp, #104]
ffff00000000129c: e7 fe ff 97  	bl	0xffff000000000e38 <kfree>
;     kfree(d);
ffff0000000012a0: e0 33 40 f9  	ldr	x0, [sp, #96]
ffff0000000012a4: e5 fe ff 97  	bl	0xffff000000000e38 <kfree>
;     kfree(e);
ffff0000000012a8: e0 2f 40 f9  	ldr	x0, [sp, #88]
ffff0000000012ac: e3 fe ff 97  	bl	0xffff000000000e38 <kfree>
;     kfree(f);
ffff0000000012b0: e0 2b 40 f9  	ldr	x0, [sp, #80]
ffff0000000012b4: e1 fe ff 97  	bl	0xffff000000000e38 <kfree>
;     kfree(g);
ffff0000000012b8: e0 27 40 f9  	ldr	x0, [sp, #72]
ffff0000000012bc: df fe ff 97  	bl	0xffff000000000e38 <kfree>
;     kfree(h);
ffff0000000012c0: e0 23 40 f9  	ldr	x0, [sp, #64]
ffff0000000012c4: dd fe ff 97  	bl	0xffff000000000e38 <kfree>
;     kfree(i);
ffff0000000012c8: e0 1f 40 f9  	ldr	x0, [sp, #56]
ffff0000000012cc: db fe ff 97  	bl	0xffff000000000e38 <kfree>
;     kfree(j);
ffff0000000012d0: e0 1b 40 f9  	ldr	x0, [sp, #48]
ffff0000000012d4: d9 fe ff 97  	bl	0xffff000000000e38 <kfree>
;     assertWithLine(j == kmalloc(32), __LINE__);
ffff0000000012d8: 00 04 80 d2  	mov	x0, #32
ffff0000000012dc: 68 fe ff 97  	bl	0xffff000000000c7c <kmalloc>
ffff0000000012e0: e1 03 00 aa  	mov	x1, x0
ffff0000000012e4: e0 1b 40 f9  	ldr	x0, [sp, #48]
ffff0000000012e8: 1f 00 01 eb  	cmp	x0, x1
ffff0000000012ec: e0 17 9f 1a  	cset	w0, eq
ffff0000000012f0: 00 1c 00 12  	and	w0, w0, #0xff
ffff0000000012f4: 01 2c 80 52  	mov	w1, #352
ffff0000000012f8: 97 fd ff 97  	bl	0xffff000000000954 <assertWithLine>
;     assertWithLine(i == kmalloc(32), __LINE__);
ffff0000000012fc: 00 04 80 d2  	mov	x0, #32
ffff000000001300: 5f fe ff 97  	bl	0xffff000000000c7c <kmalloc>
ffff000000001304: e1 03 00 aa  	mov	x1, x0
ffff000000001308: e0 1f 40 f9  	ldr	x0, [sp, #56]
ffff00000000130c: 1f 00 01 eb  	cmp	x0, x1
ffff000000001310: e0 17 9f 1a  	cset	w0, eq
ffff000000001314: 00 1c 00 12  	and	w0, w0, #0xff
ffff000000001318: 21 2c 80 52  	mov	w1, #353
ffff00000000131c: 8e fd ff 97  	bl	0xffff000000000954 <assertWithLine>
;     assertWithLine(h == kmalloc(32), __LINE__);
ffff000000001320: 00 04 80 d2  	mov	x0, #32
ffff000000001324: 56 fe ff 97  	bl	0xffff000000000c7c <kmalloc>
ffff000000001328: e1 03 00 aa  	mov	x1, x0
ffff00000000132c: e0 23 40 f9  	ldr	x0, [sp, #64]
ffff000000001330: 1f 00 01 eb  	cmp	x0, x1
ffff000000001334: e0 17 9f 1a  	cset	w0, eq
ffff000000001338: 00 1c 00 12  	and	w0, w0, #0xff
ffff00000000133c: 41 2c 80 52  	mov	w1, #354
ffff000000001340: 85 fd ff 97  	bl	0xffff000000000954 <assertWithLine>
;     assertWithLine(g == kmalloc(32), __LINE__);
ffff000000001344: 00 04 80 d2  	mov	x0, #32
ffff000000001348: 4d fe ff 97  	bl	0xffff000000000c7c <kmalloc>
ffff00000000134c: e1 03 00 aa  	mov	x1, x0
ffff000000001350: e0 27 40 f9  	ldr	x0, [sp, #72]
ffff000000001354: 1f 00 01 eb  	cmp	x0, x1
ffff000000001358: e0 17 9f 1a  	cset	w0, eq
ffff00000000135c: 00 1c 00 12  	and	w0, w0, #0xff
ffff000000001360: 61 2c 80 52  	mov	w1, #355
ffff000000001364: 7c fd ff 97  	bl	0xffff000000000954 <assertWithLine>
;     assertWithLine(f == kmalloc(32), __LINE__);
ffff000000001368: 00 04 80 d2  	mov	x0, #32
ffff00000000136c: 44 fe ff 97  	bl	0xffff000000000c7c <kmalloc>
ffff000000001370: e1 03 00 aa  	mov	x1, x0
ffff000000001374: e0 2b 40 f9  	ldr	x0, [sp, #80]
ffff000000001378: 1f 00 01 eb  	cmp	x0, x1
ffff00000000137c: e0 17 9f 1a  	cset	w0, eq
ffff000000001380: 00 1c 00 12  	and	w0, w0, #0xff
ffff000000001384: 81 2c 80 52  	mov	w1, #356
ffff000000001388: 73 fd ff 97  	bl	0xffff000000000954 <assertWithLine>
;     assertWithLine(e == kmalloc(32), __LINE__);
ffff00000000138c: 00 04 80 d2  	mov	x0, #32
ffff000000001390: 3b fe ff 97  	bl	0xffff000000000c7c <kmalloc>
ffff000000001394: e1 03 00 aa  	mov	x1, x0
ffff000000001398: e0 2f 40 f9  	ldr	x0, [sp, #88]
ffff00000000139c: 1f 00 01 eb  	cmp	x0, x1
ffff0000000013a0: e0 17 9f 1a  	cset	w0, eq
ffff0000000013a4: 00 1c 00 12  	and	w0, w0, #0xff
ffff0000000013a8: a1 2c 80 52  	mov	w1, #357
ffff0000000013ac: 6a fd ff 97  	bl	0xffff000000000954 <assertWithLine>
;     assertWithLine(d == kmalloc(32), __LINE__);
ffff0000000013b0: 00 04 80 d2  	mov	x0, #32
ffff0000000013b4: 32 fe ff 97  	bl	0xffff000000000c7c <kmalloc>
ffff0000000013b8: e1 03 00 aa  	mov	x1, x0
ffff0000000013bc: e0 33 40 f9  	ldr	x0, [sp, #96]
ffff0000000013c0: 1f 00 01 eb  	cmp	x0, x1
ffff0000000013c4: e0 17 9f 1a  	cset	w0, eq
ffff0000000013c8: 00 1c 00 12  	and	w0, w0, #0xff
ffff0000000013cc: c1 2c 80 52  	mov	w1, #358
ffff0000000013d0: 61 fd ff 97  	bl	0xffff000000000954 <assertWithLine>
;     assertWithLine(c == kmalloc(32), __LINE__);
ffff0000000013d4: 00 04 80 d2  	mov	x0, #32
ffff0000000013d8: 29 fe ff 97  	bl	0xffff000000000c7c <kmalloc>
ffff0000000013dc: e1 03 00 aa  	mov	x1, x0
ffff0000000013e0: e0 37 40 f9  	ldr	x0, [sp, #104]
ffff0000000013e4: 1f 00 01 eb  	cmp	x0, x1
ffff0000000013e8: e0 17 9f 1a  	cset	w0, eq
ffff0000000013ec: 00 1c 00 12  	and	w0, w0, #0xff
ffff0000000013f0: e1 2c 80 52  	mov	w1, #359
ffff0000000013f4: 58 fd ff 97  	bl	0xffff000000000954 <assertWithLine>
;     assertWithLine(b == kmalloc(32), __LINE__);
ffff0000000013f8: 00 04 80 d2  	mov	x0, #32
ffff0000000013fc: 20 fe ff 97  	bl	0xffff000000000c7c <kmalloc>
ffff000000001400: e1 03 00 aa  	mov	x1, x0
ffff000000001404: e0 3b 40 f9  	ldr	x0, [sp, #112]
ffff000000001408: 1f 00 01 eb  	cmp	x0, x1
ffff00000000140c: e0 17 9f 1a  	cset	w0, eq
ffff000000001410: 00 1c 00 12  	and	w0, w0, #0xff
ffff000000001414: 01 2d 80 52  	mov	w1, #360
ffff000000001418: 4f fd ff 97  	bl	0xffff000000000954 <assertWithLine>
;     assertWithLine(kmalloc(64) - kmalloc(64) == 64, __LINE__);
ffff00000000141c: 00 08 80 d2  	mov	x0, #64
ffff000000001420: 17 fe ff 97  	bl	0xffff000000000c7c <kmalloc>
ffff000000001424: f3 03 00 aa  	mov	x19, x0
ffff000000001428: 00 08 80 d2  	mov	x0, #64
ffff00000000142c: 14 fe ff 97  	bl	0xffff000000000c7c <kmalloc>
ffff000000001430: 60 02 00 cb  	sub	x0, x19, x0
ffff000000001434: 1f 00 01 f1  	cmp	x0, #64
ffff000000001438: e0 17 9f 1a  	cset	w0, eq
ffff00000000143c: 00 1c 00 12  	and	w0, w0, #0xff
ffff000000001440: 21 2d 80 52  	mov	w1, #361
ffff000000001444: 44 fd ff 97  	bl	0xffff000000000954 <assertWithLine>
;     assertWithLine(kmalloc(128) - kmalloc(128) == 128, __LINE__);
ffff000000001448: 00 10 80 d2  	mov	x0, #128
ffff00000000144c: 0c fe ff 97  	bl	0xffff000000000c7c <kmalloc>
ffff000000001450: f3 03 00 aa  	mov	x19, x0
ffff000000001454: 00 10 80 d2  	mov	x0, #128
ffff000000001458: 09 fe ff 97  	bl	0xffff000000000c7c <kmalloc>
ffff00000000145c: 60 02 00 cb  	sub	x0, x19, x0
ffff000000001460: 1f 00 02 f1  	cmp	x0, #128
ffff000000001464: e0 17 9f 1a  	cset	w0, eq
ffff000000001468: 00 1c 00 12  	and	w0, w0, #0xff
ffff00000000146c: 41 2d 80 52  	mov	w1, #362
ffff000000001470: 39 fd ff 97  	bl	0xffff000000000954 <assertWithLine>
;     assertWithLine(kmalloc(256) - kmalloc(256) == 256, __LINE__);
ffff000000001474: 00 20 80 d2  	mov	x0, #256
ffff000000001478: 01 fe ff 97  	bl	0xffff000000000c7c <kmalloc>
ffff00000000147c: f3 03 00 aa  	mov	x19, x0
ffff000000001480: 00 20 80 d2  	mov	x0, #256
ffff000000001484: fe fd ff 97  	bl	0xffff000000000c7c <kmalloc>
ffff000000001488: 60 02 00 cb  	sub	x0, x19, x0
ffff00000000148c: 1f 00 04 f1  	cmp	x0, #256
ffff000000001490: e0 17 9f 1a  	cset	w0, eq
ffff000000001494: 00 1c 00 12  	and	w0, w0, #0xff
ffff000000001498: 61 2d 80 52  	mov	w1, #363
ffff00000000149c: 2e fd ff 97  	bl	0xffff000000000954 <assertWithLine>
;     assertWithLine(kmalloc(512) - kmalloc(512) == 512, __LINE__);
ffff0000000014a0: 00 40 80 d2  	mov	x0, #512
ffff0000000014a4: f6 fd ff 97  	bl	0xffff000000000c7c <kmalloc>
ffff0000000014a8: f3 03 00 aa  	mov	x19, x0
ffff0000000014ac: 00 40 80 d2  	mov	x0, #512
ffff0000000014b0: f3 fd ff 97  	bl	0xffff000000000c7c <kmalloc>
ffff0000000014b4: 60 02 00 cb  	sub	x0, x19, x0
ffff0000000014b8: 1f 00 08 f1  	cmp	x0, #512
ffff0000000014bc: e0 17 9f 1a  	cset	w0, eq
ffff0000000014c0: 00 1c 00 12  	and	w0, w0, #0xff
ffff0000000014c4: 81 2d 80 52  	mov	w1, #364
ffff0000000014c8: 23 fd ff 97  	bl	0xffff000000000954 <assertWithLine>
;     assertWithLine(kmalloc(1024) - kmalloc(1024) == 1024, __LINE__);
ffff0000000014cc: 00 80 80 d2  	mov	x0, #1024
ffff0000000014d0: eb fd ff 97  	bl	0xffff000000000c7c <kmalloc>
ffff0000000014d4: f3 03 00 aa  	mov	x19, x0
ffff0000000014d8: 00 80 80 d2  	mov	x0, #1024
ffff0000000014dc: e8 fd ff 97  	bl	0xffff000000000c7c <kmalloc>
ffff0000000014e0: 60 02 00 cb  	sub	x0, x19, x0
ffff0000000014e4: 1f 00 10 f1  	cmp	x0, #1024
ffff0000000014e8: e0 17 9f 1a  	cset	w0, eq
ffff0000000014ec: 00 1c 00 12  	and	w0, w0, #0xff
ffff0000000014f0: a1 2d 80 52  	mov	w1, #365
ffff0000000014f4: 18 fd ff 97  	bl	0xffff000000000954 <assertWithLine>
;     assertWithLine(kmalloc(2048) - kmalloc(2048) == -PAGE_SIZE, __LINE__);
ffff0000000014f8: 00 00 81 d2  	mov	x0, #2048
ffff0000000014fc: e0 fd ff 97  	bl	0xffff000000000c7c <kmalloc>
ffff000000001500: f3 03 00 aa  	mov	x19, x0
ffff000000001504: 00 00 81 d2  	mov	x0, #2048
ffff000000001508: dd fd ff 97  	bl	0xffff000000000c7c <kmalloc>
ffff00000000150c: 60 02 00 cb  	sub	x0, x19, x0
ffff000000001510: 1f 04 40 b1  	cmn	x0, #1, lsl #12
ffff000000001514: e0 17 9f 1a  	cset	w0, eq
ffff000000001518: 00 1c 00 12  	and	w0, w0, #0xff
ffff00000000151c: c1 2d 80 52  	mov	w1, #366
ffff000000001520: 0d fd ff 97  	bl	0xffff000000000954 <assertWithLine>
; }
ffff000000001524: 1f 20 03 d5  	nop
ffff000000001528: f3 0b 40 f9  	ldr	x19, [sp, #16]
ffff00000000152c: fd 7b c9 a8  	ldp	x29, x30, [sp], #144
ffff000000001530: c0 03 5f d6  	ret

ffff000000001534 <print_digits>:
; void print_digits(long n) {
ffff000000001534: fd 7b be a9  	stp	x29, x30, [sp, #-32]!
ffff000000001538: fd 03 00 91  	mov	x29, sp
ffff00000000153c: e0 0f 00 f9  	str	x0, [sp, #24]
;   if (n < 0) {
ffff000000001540: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff000000001544: 1f 00 00 f1  	cmp	x0, #0
ffff000000001548: ca 00 00 54  	b.ge	0xffff000000001560 <print_digits+0x2c>
;     uart_send('-');
ffff00000000154c: a0 05 80 52  	mov	w0, #45
ffff000000001550: 30 07 00 94  	bl	0xffff000000003210 <uart_send>
;     n = -n;
ffff000000001554: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff000000001558: e0 03 00 cb  	neg	x0, x0
ffff00000000155c: e0 0f 00 f9  	str	x0, [sp, #24]
;   if (n >= 10) {
ffff000000001560: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff000000001564: 1f 24 00 f1  	cmp	x0, #9
ffff000000001568: 2d 01 00 54  	b.le	0xffff00000000158c <print_digits+0x58>
;     print_digits(n / 10);
ffff00000000156c: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff000000001570: e1 e7 03 b2  	mov	x1, #7378697629483820646
ffff000000001574: e1 cc 8c f2  	movk	x1, #26215
ffff000000001578: 01 7c 41 9b  	smulh	x1, x0, x1
ffff00000000157c: 21 fc 42 93  	asr	x1, x1, #2
ffff000000001580: 00 fc 7f 93  	asr	x0, x0, #63
ffff000000001584: 20 00 00 cb  	sub	x0, x1, x0
ffff000000001588: eb ff ff 97  	bl	0xffff000000001534 <print_digits>
;   uart_send(n % 10 + '0');
ffff00000000158c: e1 0f 40 f9  	ldr	x1, [sp, #24]
ffff000000001590: e0 e7 03 b2  	mov	x0, #7378697629483820646
ffff000000001594: e0 cc 8c f2  	movk	x0, #26215
ffff000000001598: 20 7c 40 9b  	smulh	x0, x1, x0
ffff00000000159c: 02 fc 42 93  	asr	x2, x0, #2
ffff0000000015a0: 20 fc 7f 93  	asr	x0, x1, #63
ffff0000000015a4: 42 00 00 cb  	sub	x2, x2, x0
ffff0000000015a8: e0 03 02 aa  	mov	x0, x2
ffff0000000015ac: 00 f4 7e d3  	lsl	x0, x0, #2
ffff0000000015b0: 00 00 02 8b  	add	x0, x0, x2
ffff0000000015b4: 00 f8 7f d3  	lsl	x0, x0, #1
ffff0000000015b8: 22 00 00 cb  	sub	x2, x1, x0
ffff0000000015bc: 40 1c 00 12  	and	w0, w2, #0xff
ffff0000000015c0: 00 c0 00 11  	add	w0, w0, #48
ffff0000000015c4: 00 1c 00 12  	and	w0, w0, #0xff
ffff0000000015c8: 12 07 00 94  	bl	0xffff000000003210 <uart_send>
; }
ffff0000000015cc: 1f 20 03 d5  	nop
ffff0000000015d0: fd 7b c2 a8  	ldp	x29, x30, [sp], #32
ffff0000000015d4: c0 03 5f d6  	ret

ffff0000000015d8 <kwriter>:
; void kwriter(char *str, va_list ap) {
ffff0000000015d8: fd 7b ba a9  	stp	x29, x30, [sp, #-96]!
ffff0000000015dc: fd 03 00 91  	mov	x29, sp
ffff0000000015e0: f3 0b 00 f9  	str	x19, [sp, #16]
ffff0000000015e4: e0 17 00 f9  	str	x0, [sp, #40]
ffff0000000015e8: f3 03 01 aa  	mov	x19, x1
;     bool isNextSpecial = false;
ffff0000000015ec: ff 7f 01 39  	strb	wzr, [sp, #95]
;     while (*str != '\0') {
ffff0000000015f0: 91 00 00 14  	b	0xffff000000001834 <kwriter+0x25c>
;         if (*str == '%') {
ffff0000000015f4: e0 17 40 f9  	ldr	x0, [sp, #40]
ffff0000000015f8: 00 00 40 39  	ldrb	w0, [x0]
ffff0000000015fc: 1f 94 00 71  	cmp	w0, #37
ffff000000001600: e1 00 00 54  	b.ne	0xffff00000000161c <kwriter+0x44>
;             isNextSpecial = true;
ffff000000001604: 20 00 80 52  	mov	w0, #1
ffff000000001608: e0 7f 01 39  	strb	w0, [sp, #95]
;             str++;
ffff00000000160c: e0 17 40 f9  	ldr	x0, [sp, #40]
ffff000000001610: 00 04 00 91  	add	x0, x0, #1
ffff000000001614: e0 17 00 f9  	str	x0, [sp, #40]
;             continue;
ffff000000001618: 87 00 00 14  	b	0xffff000000001834 <kwriter+0x25c>
;         if (isNextSpecial) {
ffff00000000161c: e0 7f 41 39  	ldrb	w0, [sp, #95]
ffff000000001620: 1f 00 00 71  	cmp	w0, #0
ffff000000001624: c0 0f 00 54  	b.eq	0xffff00000000181c <kwriter+0x244>
;             isNextSpecial = false;
ffff000000001628: ff 7f 01 39  	strb	wzr, [sp, #95]
;             if (*str == 'd') {
ffff00000000162c: e0 17 40 f9  	ldr	x0, [sp, #40]
ffff000000001630: 00 00 40 39  	ldrb	w0, [x0]
ffff000000001634: 1f 90 01 71  	cmp	w0, #100
ffff000000001638: 41 03 00 54  	b.ne	0xffff0000000016a0 <kwriter+0xc8>
;                 long val = va_arg(ap, long);
ffff00000000163c: 61 1a 40 b9  	ldr	w1, [x19, #24]
ffff000000001640: 60 02 40 f9  	ldr	x0, [x19]
ffff000000001644: 3f 00 00 71  	cmp	w1, #0
ffff000000001648: ab 00 00 54  	b.lt	0xffff00000000165c <kwriter+0x84>
ffff00000000164c: 01 3c 00 91  	add	x1, x0, #15
ffff000000001650: 21 f0 7d 92  	and	x1, x1, #0xfffffffffffffff8
ffff000000001654: 61 02 00 f9  	str	x1, [x19]
ffff000000001658: 0d 00 00 14  	b	0xffff00000000168c <kwriter+0xb4>
ffff00000000165c: 22 20 00 11  	add	w2, w1, #8
ffff000000001660: 62 1a 00 b9  	str	w2, [x19, #24]
ffff000000001664: 62 1a 40 b9  	ldr	w2, [x19, #24]
ffff000000001668: 5f 00 00 71  	cmp	w2, #0
ffff00000000166c: ad 00 00 54  	b.le	0xffff000000001680 <kwriter+0xa8>
ffff000000001670: 01 3c 00 91  	add	x1, x0, #15
ffff000000001674: 21 f0 7d 92  	and	x1, x1, #0xfffffffffffffff8
ffff000000001678: 61 02 00 f9  	str	x1, [x19]
ffff00000000167c: 04 00 00 14  	b	0xffff00000000168c <kwriter+0xb4>
ffff000000001680: 62 06 40 f9  	ldr	x2, [x19, #8]
ffff000000001684: 20 7c 40 93  	sxtw	x0, w1
ffff000000001688: 40 00 00 8b  	add	x0, x2, x0
ffff00000000168c: 00 00 40 f9  	ldr	x0, [x0]
ffff000000001690: e0 1f 00 f9  	str	x0, [sp, #56]
;                 print_digits(val);
ffff000000001694: e0 1f 40 f9  	ldr	x0, [sp, #56]
ffff000000001698: a7 ff ff 97  	bl	0xffff000000001534 <print_digits>
ffff00000000169c: 5c 00 00 14  	b	0xffff00000000180c <kwriter+0x234>
;             } else if (*str == 'c') {
ffff0000000016a0: e0 17 40 f9  	ldr	x0, [sp, #40]
ffff0000000016a4: 00 00 40 39  	ldrb	w0, [x0]
ffff0000000016a8: 1f 8c 01 71  	cmp	w0, #99
ffff0000000016ac: 41 03 00 54  	b.ne	0xffff000000001714 <kwriter+0x13c>
;                 char c = (char) va_arg(ap, int);
ffff0000000016b0: 61 1a 40 b9  	ldr	w1, [x19, #24]
ffff0000000016b4: 60 02 40 f9  	ldr	x0, [x19]
ffff0000000016b8: 3f 00 00 71  	cmp	w1, #0
ffff0000000016bc: ab 00 00 54  	b.lt	0xffff0000000016d0 <kwriter+0xf8>
ffff0000000016c0: 01 2c 00 91  	add	x1, x0, #11
ffff0000000016c4: 21 f0 7d 92  	and	x1, x1, #0xfffffffffffffff8
ffff0000000016c8: 61 02 00 f9  	str	x1, [x19]
ffff0000000016cc: 0d 00 00 14  	b	0xffff000000001700 <kwriter+0x128>
ffff0000000016d0: 22 20 00 11  	add	w2, w1, #8
ffff0000000016d4: 62 1a 00 b9  	str	w2, [x19, #24]
ffff0000000016d8: 62 1a 40 b9  	ldr	w2, [x19, #24]
ffff0000000016dc: 5f 00 00 71  	cmp	w2, #0
ffff0000000016e0: ad 00 00 54  	b.le	0xffff0000000016f4 <kwriter+0x11c>
ffff0000000016e4: 01 2c 00 91  	add	x1, x0, #11
ffff0000000016e8: 21 f0 7d 92  	and	x1, x1, #0xfffffffffffffff8
ffff0000000016ec: 61 02 00 f9  	str	x1, [x19]
ffff0000000016f0: 04 00 00 14  	b	0xffff000000001700 <kwriter+0x128>
ffff0000000016f4: 62 06 40 f9  	ldr	x2, [x19, #8]
ffff0000000016f8: 20 7c 40 93  	sxtw	x0, w1
ffff0000000016fc: 40 00 00 8b  	add	x0, x2, x0
ffff000000001700: 00 00 40 b9  	ldr	w0, [x0]
ffff000000001704: e0 1f 01 39  	strb	w0, [sp, #71]
;                 uart_send(c);
ffff000000001708: e0 1f 41 39  	ldrb	w0, [sp, #71]
ffff00000000170c: c1 06 00 94  	bl	0xffff000000003210 <uart_send>
ffff000000001710: 3f 00 00 14  	b	0xffff00000000180c <kwriter+0x234>
;             } else if (*str == 's') {
ffff000000001714: e0 17 40 f9  	ldr	x0, [sp, #40]
ffff000000001718: 00 00 40 39  	ldrb	w0, [x0]
ffff00000000171c: 1f cc 01 71  	cmp	w0, #115
ffff000000001720: 41 03 00 54  	b.ne	0xffff000000001788 <kwriter+0x1b0>
;                 char *s = va_arg(ap, char *);
ffff000000001724: 61 1a 40 b9  	ldr	w1, [x19, #24]
ffff000000001728: 60 02 40 f9  	ldr	x0, [x19]
ffff00000000172c: 3f 00 00 71  	cmp	w1, #0
ffff000000001730: ab 00 00 54  	b.lt	0xffff000000001744 <kwriter+0x16c>
ffff000000001734: 01 3c 00 91  	add	x1, x0, #15
ffff000000001738: 21 f0 7d 92  	and	x1, x1, #0xfffffffffffffff8
ffff00000000173c: 61 02 00 f9  	str	x1, [x19]
ffff000000001740: 0d 00 00 14  	b	0xffff000000001774 <kwriter+0x19c>
ffff000000001744: 22 20 00 11  	add	w2, w1, #8
ffff000000001748: 62 1a 00 b9  	str	w2, [x19, #24]
ffff00000000174c: 62 1a 40 b9  	ldr	w2, [x19, #24]
ffff000000001750: 5f 00 00 71  	cmp	w2, #0
ffff000000001754: ad 00 00 54  	b.le	0xffff000000001768 <kwriter+0x190>
ffff000000001758: 01 3c 00 91  	add	x1, x0, #15
ffff00000000175c: 21 f0 7d 92  	and	x1, x1, #0xfffffffffffffff8
ffff000000001760: 61 02 00 f9  	str	x1, [x19]
ffff000000001764: 04 00 00 14  	b	0xffff000000001774 <kwriter+0x19c>
ffff000000001768: 62 06 40 f9  	ldr	x2, [x19, #8]
ffff00000000176c: 20 7c 40 93  	sxtw	x0, w1
ffff000000001770: 40 00 00 8b  	add	x0, x2, x0
ffff000000001774: 00 00 40 f9  	ldr	x0, [x0]
ffff000000001778: e0 27 00 f9  	str	x0, [sp, #72]
;                 uart_send_string(s);   
ffff00000000177c: e0 27 40 f9  	ldr	x0, [sp, #72]
ffff000000001780: c7 06 00 94  	bl	0xffff00000000329c <uart_send_string>
ffff000000001784: 22 00 00 14  	b	0xffff00000000180c <kwriter+0x234>
;             } else if (*str == 'p') {
ffff000000001788: e0 17 40 f9  	ldr	x0, [sp, #40]
ffff00000000178c: 00 00 40 39  	ldrb	w0, [x0]
ffff000000001790: 1f c0 01 71  	cmp	w0, #112
ffff000000001794: 41 03 00 54  	b.ne	0xffff0000000017fc <kwriter+0x224>
;                 void *ptr = va_arg(ap, void *);
ffff000000001798: 61 1a 40 b9  	ldr	w1, [x19, #24]
ffff00000000179c: 60 02 40 f9  	ldr	x0, [x19]
ffff0000000017a0: 3f 00 00 71  	cmp	w1, #0
ffff0000000017a4: ab 00 00 54  	b.lt	0xffff0000000017b8 <kwriter+0x1e0>
ffff0000000017a8: 01 3c 00 91  	add	x1, x0, #15
ffff0000000017ac: 21 f0 7d 92  	and	x1, x1, #0xfffffffffffffff8
ffff0000000017b0: 61 02 00 f9  	str	x1, [x19]
ffff0000000017b4: 0d 00 00 14  	b	0xffff0000000017e8 <kwriter+0x210>
ffff0000000017b8: 22 20 00 11  	add	w2, w1, #8
ffff0000000017bc: 62 1a 00 b9  	str	w2, [x19, #24]
ffff0000000017c0: 62 1a 40 b9  	ldr	w2, [x19, #24]
ffff0000000017c4: 5f 00 00 71  	cmp	w2, #0
ffff0000000017c8: ad 00 00 54  	b.le	0xffff0000000017dc <kwriter+0x204>
ffff0000000017cc: 01 3c 00 91  	add	x1, x0, #15
ffff0000000017d0: 21 f0 7d 92  	and	x1, x1, #0xfffffffffffffff8
ffff0000000017d4: 61 02 00 f9  	str	x1, [x19]
ffff0000000017d8: 04 00 00 14  	b	0xffff0000000017e8 <kwriter+0x210>
ffff0000000017dc: 62 06 40 f9  	ldr	x2, [x19, #8]
ffff0000000017e0: 20 7c 40 93  	sxtw	x0, w1
ffff0000000017e4: 40 00 00 8b  	add	x0, x2, x0
ffff0000000017e8: 00 00 40 f9  	ldr	x0, [x0]
ffff0000000017ec: e0 2b 00 f9  	str	x0, [sp, #80]
;                 print_digits((int64_t) ptr);
ffff0000000017f0: e0 2b 40 f9  	ldr	x0, [sp, #80]
ffff0000000017f4: 50 ff ff 97  	bl	0xffff000000001534 <print_digits>
ffff0000000017f8: 05 00 00 14  	b	0xffff00000000180c <kwriter+0x234>
;                 uart_send_string("ERROR: Bad formatting sent to printf...\n");
ffff0000000017fc: 00 00 00 f0  	adrp	x0, #12288
ffff000000001800: 00 60 14 91  	add	x0, x0, #1304
ffff000000001804: a6 06 00 94  	bl	0xffff00000000329c <uart_send_string>
;                 return;
ffff000000001808: 0f 00 00 14  	b	0xffff000000001844 <kwriter+0x26c>
;             str++;
ffff00000000180c: e0 17 40 f9  	ldr	x0, [sp, #40]
ffff000000001810: 00 04 00 91  	add	x0, x0, #1
ffff000000001814: e0 17 00 f9  	str	x0, [sp, #40]
;             continue;
ffff000000001818: 07 00 00 14  	b	0xffff000000001834 <kwriter+0x25c>
;         uart_send(*str);
ffff00000000181c: e0 17 40 f9  	ldr	x0, [sp, #40]
ffff000000001820: 00 00 40 39  	ldrb	w0, [x0]
ffff000000001824: 7b 06 00 94  	bl	0xffff000000003210 <uart_send>
;         str++;
ffff000000001828: e0 17 40 f9  	ldr	x0, [sp, #40]
ffff00000000182c: 00 04 00 91  	add	x0, x0, #1
ffff000000001830: e0 17 00 f9  	str	x0, [sp, #40]
;     while (*str != '\0') {
ffff000000001834: e0 17 40 f9  	ldr	x0, [sp, #40]
ffff000000001838: 00 00 40 39  	ldrb	w0, [x0]
ffff00000000183c: 1f 00 00 71  	cmp	w0, #0
ffff000000001840: a1 ed ff 54  	b.ne	0xffff0000000015f4 <kwriter+0x1c>
; }
ffff000000001844: f3 0b 40 f9  	ldr	x19, [sp, #16]
ffff000000001848: fd 7b c6 a8  	ldp	x29, x30, [sp], #96
ffff00000000184c: c0 03 5f d6  	ret

ffff000000001850 <kprintf>:
; void kprintf(char *str, ...) {
ffff000000001850: fd 7b b6 a9  	stp	x29, x30, [sp, #-160]!
ffff000000001854: fd 03 00 91  	mov	x29, sp
ffff000000001858: e0 1f 00 f9  	str	x0, [sp, #56]
ffff00000000185c: e1 37 00 f9  	str	x1, [sp, #104]
ffff000000001860: e2 3b 00 f9  	str	x2, [sp, #112]
ffff000000001864: e3 3f 00 f9  	str	x3, [sp, #120]
ffff000000001868: e4 43 00 f9  	str	x4, [sp, #128]
ffff00000000186c: e5 47 00 f9  	str	x5, [sp, #136]
ffff000000001870: e6 4b 00 f9  	str	x6, [sp, #144]
ffff000000001874: e7 4f 00 f9  	str	x7, [sp, #152]
;     va_start(ap, str);
ffff000000001878: e0 83 02 91  	add	x0, sp, #160
ffff00000000187c: e0 23 00 f9  	str	x0, [sp, #64]
ffff000000001880: e0 83 02 91  	add	x0, sp, #160
ffff000000001884: e0 27 00 f9  	str	x0, [sp, #72]
ffff000000001888: e0 83 01 91  	add	x0, sp, #96
ffff00000000188c: e0 2b 00 f9  	str	x0, [sp, #80]
ffff000000001890: e0 06 80 12  	mov	w0, #-56
ffff000000001894: e0 5b 00 b9  	str	w0, [sp, #88]
ffff000000001898: ff 5f 00 b9  	str	wzr, [sp, #92]
;     kwriter(str, ap);
ffff00000000189c: e2 43 00 91  	add	x2, sp, #16
ffff0000000018a0: e3 03 01 91  	add	x3, sp, #64
ffff0000000018a4: 60 04 40 a9  	ldp	x0, x1, [x3]
ffff0000000018a8: 40 04 00 a9  	stp	x0, x1, [x2]
ffff0000000018ac: 60 04 41 a9  	ldp	x0, x1, [x3, #16]
ffff0000000018b0: 40 04 01 a9  	stp	x0, x1, [x2, #16]
ffff0000000018b4: e0 43 00 91  	add	x0, sp, #16
ffff0000000018b8: e1 03 00 aa  	mov	x1, x0
ffff0000000018bc: e0 1f 40 f9  	ldr	x0, [sp, #56]
ffff0000000018c0: 46 ff ff 97  	bl	0xffff0000000015d8 <kwriter>
; }
ffff0000000018c4: 1f 20 03 d5  	nop
ffff0000000018c8: fd 7b ca a8  	ldp	x29, x30, [sp], #160
ffff0000000018cc: c0 03 5f d6  	ret

ffff0000000018d0 <klog>:
; void klog(char *str, ...) {
ffff0000000018d0: fd 7b b6 a9  	stp	x29, x30, [sp, #-160]!
ffff0000000018d4: fd 03 00 91  	mov	x29, sp
ffff0000000018d8: e0 1f 00 f9  	str	x0, [sp, #56]
ffff0000000018dc: e1 37 00 f9  	str	x1, [sp, #104]
ffff0000000018e0: e2 3b 00 f9  	str	x2, [sp, #112]
ffff0000000018e4: e3 3f 00 f9  	str	x3, [sp, #120]
ffff0000000018e8: e4 43 00 f9  	str	x4, [sp, #128]
ffff0000000018ec: e5 47 00 f9  	str	x5, [sp, #136]
ffff0000000018f0: e6 4b 00 f9  	str	x6, [sp, #144]
ffff0000000018f4: e7 4f 00 f9  	str	x7, [sp, #152]
;     if (!LOGGING_ENABLED) return;
ffff0000000018f8: 20 00 00 90  	adrp	x0, #16384
ffff0000000018fc: 00 40 14 91  	add	x0, x0, #1296
ffff000000001900: 00 00 40 39  	ldrb	w0, [x0]
ffff000000001904: 00 00 00 52  	eor	w0, w0, #0x1
ffff000000001908: 00 1c 00 12  	and	w0, w0, #0xff
ffff00000000190c: 1f 00 00 71  	cmp	w0, #0
ffff000000001910: a1 02 00 54  	b.ne	0xffff000000001964 <klog+0x94>
;     va_start(ap, str);
ffff000000001914: e0 83 02 91  	add	x0, sp, #160
ffff000000001918: e0 23 00 f9  	str	x0, [sp, #64]
ffff00000000191c: e0 83 02 91  	add	x0, sp, #160
ffff000000001920: e0 27 00 f9  	str	x0, [sp, #72]
ffff000000001924: e0 83 01 91  	add	x0, sp, #96
ffff000000001928: e0 2b 00 f9  	str	x0, [sp, #80]
ffff00000000192c: e0 06 80 12  	mov	w0, #-56
ffff000000001930: e0 5b 00 b9  	str	w0, [sp, #88]
ffff000000001934: ff 5f 00 b9  	str	wzr, [sp, #92]
;     kwriter(str, ap);
ffff000000001938: e2 43 00 91  	add	x2, sp, #16
ffff00000000193c: e3 03 01 91  	add	x3, sp, #64
ffff000000001940: 60 04 40 a9  	ldp	x0, x1, [x3]
ffff000000001944: 40 04 00 a9  	stp	x0, x1, [x2]
ffff000000001948: 60 04 41 a9  	ldp	x0, x1, [x3, #16]
ffff00000000194c: 40 04 01 a9  	stp	x0, x1, [x2, #16]
ffff000000001950: e0 43 00 91  	add	x0, sp, #16
ffff000000001954: e1 03 00 aa  	mov	x1, x0
ffff000000001958: e0 1f 40 f9  	ldr	x0, [sp, #56]
ffff00000000195c: 1f ff ff 97  	bl	0xffff0000000015d8 <kwriter>
ffff000000001960: 02 00 00 14  	b	0xffff000000001968 <klog+0x98>
;     if (!LOGGING_ENABLED) return;
ffff000000001964: 1f 20 03 d5  	nop
; }
ffff000000001968: fd 7b ca a8  	ldp	x29, x30, [sp], #160
ffff00000000196c: c0 03 5f d6  	ret

ffff000000001970 <test_printf>:
; void test_printf() {
ffff000000001970: fd 7b be a9  	stp	x29, x30, [sp, #-32]!
ffff000000001974: fd 03 00 91  	mov	x29, sp
;   kprintf("Simple String\n");
ffff000000001978: 00 00 00 f0  	adrp	x0, #12288
ffff00000000197c: 00 20 15 91  	add	x0, x0, #1352
ffff000000001980: b4 ff ff 97  	bl	0xffff000000001850 <kprintf>
;   kprintf("This is a digit: %d\n", 5);
ffff000000001984: a1 00 80 52  	mov	w1, #5
ffff000000001988: 00 00 00 f0  	adrp	x0, #12288
ffff00000000198c: 00 60 15 91  	add	x0, x0, #1368
ffff000000001990: b0 ff ff 97  	bl	0xffff000000001850 <kprintf>
;   kprintf("This is two digits: %d and %d\n", 6, 7);
ffff000000001994: e2 00 80 52  	mov	w2, #7
ffff000000001998: c1 00 80 52  	mov	w1, #6
ffff00000000199c: 00 00 00 f0  	adrp	x0, #12288
ffff0000000019a0: 00 c0 15 91  	add	x0, x0, #1392
ffff0000000019a4: ab ff ff 97  	bl	0xffff000000001850 <kprintf>
;   kprintf("This is a negative digit: %d\n", -6);
ffff0000000019a8: a1 00 80 12  	mov	w1, #-6
ffff0000000019ac: 00 00 00 f0  	adrp	x0, #12288
ffff0000000019b0: 00 40 16 91  	add	x0, x0, #1424
ffff0000000019b4: a7 ff ff 97  	bl	0xffff000000001850 <kprintf>
;   kprintf("This is a wide digit:%d\n", 123456789);
ffff0000000019b8: a1 a2 99 52  	mov	w1, #52501
ffff0000000019bc: 61 eb a0 72  	movk	w1, #1883, lsl #16
ffff0000000019c0: 00 00 00 f0  	adrp	x0, #12288
ffff0000000019c4: 00 c0 16 91  	add	x0, x0, #1456
ffff0000000019c8: a2 ff ff 97  	bl	0xffff000000001850 <kprintf>
;   kprintf("This is a char: %c and this is a digit: %d\n", 'c', 34);
ffff0000000019cc: 42 04 80 52  	mov	w2, #34
ffff0000000019d0: 61 0c 80 52  	mov	w1, #99
ffff0000000019d4: 00 00 00 f0  	adrp	x0, #12288
ffff0000000019d8: 00 40 17 91  	add	x0, x0, #1488
ffff0000000019dc: 9d ff ff 97  	bl	0xffff000000001850 <kprintf>
;   kprintf("This is a string: %s\n", "...sample string...");
ffff0000000019e0: 00 00 00 f0  	adrp	x0, #12288
ffff0000000019e4: 01 00 18 91  	add	x1, x0, #1536
ffff0000000019e8: 00 00 00 f0  	adrp	x0, #12288
ffff0000000019ec: 00 60 18 91  	add	x0, x0, #1560
ffff0000000019f0: 98 ff ff 97  	bl	0xffff000000001850 <kprintf>
;   int a = 4;
ffff0000000019f4: 80 00 80 52  	mov	w0, #4
ffff0000000019f8: e0 1f 00 b9  	str	w0, [sp, #28]
;   int b = 5;
ffff0000000019fc: a0 00 80 52  	mov	w0, #5
ffff000000001a00: e0 1b 00 b9  	str	w0, [sp, #24]
;   kprintf("&a=%p\n&b=%p\n", &a, &b);
ffff000000001a04: e1 63 00 91  	add	x1, sp, #24
ffff000000001a08: e0 73 00 91  	add	x0, sp, #28
ffff000000001a0c: e2 03 01 aa  	mov	x2, x1
ffff000000001a10: e1 03 00 aa  	mov	x1, x0
ffff000000001a14: 00 00 00 f0  	adrp	x0, #12288
ffff000000001a18: 00 c0 18 91  	add	x0, x0, #1584
ffff000000001a1c: 8d ff ff 97  	bl	0xffff000000001850 <kprintf>
;   kprintf("Debug Line...\n");
ffff000000001a20: 00 00 00 f0  	adrp	x0, #12288
ffff000000001a24: 00 00 19 91  	add	x0, x0, #1600
ffff000000001a28: 8a ff ff 97  	bl	0xffff000000001850 <kprintf>
; }
ffff000000001a2c: 1f 20 03 d5  	nop
ffff000000001a30: fd 7b c2 a8  	ldp	x29, x30, [sp], #32
ffff000000001a34: c0 03 5f d6  	ret

ffff000000001a38 <kmain2>:
;   while (!shouldSecondCPUStart);
ffff000000001a38: 1f 20 03 d5  	nop
ffff000000001a3c: 20 00 00 90  	adrp	x0, #16384
ffff000000001a40: 00 00 17 91  	add	x0, x0, #1472
ffff000000001a44: 00 00 40 39  	ldrb	w0, [x0]
ffff000000001a48: 00 00 00 52  	eor	w0, w0, #0x1
ffff000000001a4c: 00 1c 00 12  	and	w0, w0, #0xff
ffff000000001a50: 1f 00 00 71  	cmp	w0, #0
ffff000000001a54: 41 ff ff 54  	b.ne	0xffff000000001a3c <kmain2+0x4>
; }
ffff000000001a58: 1f 20 03 d5  	nop
ffff000000001a5c: 1f 20 03 d5  	nop
ffff000000001a60: c0 03 5f d6  	ret

ffff000000001a64 <spinAndInc>:
; void spinAndInc (void * arg) {
ffff000000001a64: fd 7b bd a9  	stp	x29, x30, [sp, #-48]!
ffff000000001a68: fd 03 00 91  	mov	x29, sp
ffff000000001a6c: e0 0f 00 f9  	str	x0, [sp, #24]
;   char * prefix = (char *) arg;
ffff000000001a70: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff000000001a74: e0 17 00 f9  	str	x0, [sp, #40]
;   int i = 0;
ffff000000001a78: ff 27 00 b9  	str	wzr, [sp, #36]
;   kprintf("\nSP=~%p\n", &i);
ffff000000001a7c: e0 93 00 91  	add	x0, sp, #36
ffff000000001a80: e1 03 00 aa  	mov	x1, x0
ffff000000001a84: 00 00 00 f0  	adrp	x0, #12288
ffff000000001a88: 00 40 19 91  	add	x0, x0, #1616
ffff000000001a8c: 71 ff ff 97  	bl	0xffff000000001850 <kprintf>
;     i++;
ffff000000001a90: e0 27 40 b9  	ldr	w0, [sp, #36]
ffff000000001a94: 00 04 00 11  	add	w0, w0, #1
ffff000000001a98: e0 27 00 b9  	str	w0, [sp, #36]
;     kprintf("%s%d\n", prefix, i);
ffff000000001a9c: e0 27 40 b9  	ldr	w0, [sp, #36]
ffff000000001aa0: e2 03 00 2a  	mov	w2, w0
ffff000000001aa4: e1 17 40 f9  	ldr	x1, [sp, #40]
ffff000000001aa8: 00 00 00 f0  	adrp	x0, #12288
ffff000000001aac: 00 80 19 91  	add	x0, x0, #1632
ffff000000001ab0: 68 ff ff 97  	bl	0xffff000000001850 <kprintf>
;     i++;
ffff000000001ab4: f7 ff ff 17  	b	0xffff000000001a90 <spinAndInc+0x2c>

ffff000000001ab8 <userFunction>:
; void userFunction(char *arg) {
ffff000000001ab8: fd 7b be a9  	stp	x29, x30, [sp, #-32]!
ffff000000001abc: fd 03 00 91  	mov	x29, sp
ffff000000001ac0: e0 0f 00 f9  	str	x0, [sp, #24]
;   while (1) kprintf("%sIn user function\n", arg);
ffff000000001ac4: e1 0f 40 f9  	ldr	x1, [sp, #24]
ffff000000001ac8: 00 00 00 f0  	adrp	x0, #12288
ffff000000001acc: 00 a0 19 91  	add	x0, x0, #1640
ffff000000001ad0: 60 ff ff 97  	bl	0xffff000000001850 <kprintf>
ffff000000001ad4: fc ff ff 17  	b	0xffff000000001ac4 <userFunction+0xc>

ffff000000001ad8 <kmain>:
; void kmain(void) {
ffff000000001ad8: fd 7b bb a9  	stp	x29, x30, [sp, #-80]!
ffff000000001adc: fd 03 00 91  	mov	x29, sp
ffff000000001ae0: f3 0b 00 f9  	str	x19, [sp, #16]
;   uart_init();
ffff000000001ae4: 86 05 00 94  	bl	0xffff0000000030fc <uart_init>
;   kprintf("===============================================================================\n");
ffff000000001ae8: 00 00 00 f0  	adrp	x0, #12288
ffff000000001aec: 00 00 1a 91  	add	x0, x0, #1664
ffff000000001af0: 58 ff ff 97  	bl	0xffff000000001850 <kprintf>
;   kprintf("[time = %d] UART has been initialized...\n", get32(TIMER_CLO));
ffff000000001af4: 80 00 86 d2  	mov	x0, #12292
ffff000000001af8: 00 e0 a7 f2  	movk	x0, #16128, lsl #16
ffff000000001afc: 0c 0a 00 94  	bl	0xffff00000000432c <get32>
ffff000000001b00: e1 03 00 2a  	mov	w1, w0
ffff000000001b04: 00 00 00 f0  	adrp	x0, #12288
ffff000000001b08: 00 60 1b 91  	add	x0, x0, #1752
ffff000000001b0c: 51 ff ff 97  	bl	0xffff000000001850 <kprintf>
;   kprintf("[time = %d] Current Kernel Exception Level: %d\n", get32(TIMER_CLO), getExceptionLevel());
ffff000000001b10: 80 00 86 d2  	mov	x0, #12292
ffff000000001b14: 00 e0 a7 f2  	movk	x0, #16128, lsl #16
ffff000000001b18: 05 0a 00 94  	bl	0xffff00000000432c <get32>
ffff000000001b1c: f3 03 00 2a  	mov	w19, w0
ffff000000001b20: 83 f9 ff 97  	bl	0xffff00000000012c <getExceptionLevel>
ffff000000001b24: e2 03 00 2a  	mov	w2, w0
ffff000000001b28: e1 03 13 2a  	mov	w1, w19
ffff000000001b2c: 00 00 00 f0  	adrp	x0, #12288
ffff000000001b30: 00 20 1c 91  	add	x0, x0, #1800
ffff000000001b34: 47 ff ff 97  	bl	0xffff000000001850 <kprintf>
;   init_timer();
ffff000000001b38: 5f 04 00 94  	bl	0xffff000000002cb4 <init_timer>
;   kprintf("[time = %d] Raspberry Pi Hardware Timer Has been set up\n", get32(TIMER_CLO));
ffff000000001b3c: 80 00 86 d2  	mov	x0, #12292
ffff000000001b40: 00 e0 a7 f2  	movk	x0, #16128, lsl #16
ffff000000001b44: fa 09 00 94  	bl	0xffff00000000432c <get32>
ffff000000001b48: e1 03 00 2a  	mov	w1, w0
ffff000000001b4c: 00 00 00 f0  	adrp	x0, #12288
ffff000000001b50: 00 e0 1c 91  	add	x0, x0, #1848
ffff000000001b54: 3f ff ff 97  	bl	0xffff000000001850 <kprintf>
;   init_rpi_interrupt_handler();
ffff000000001b58: 67 fb ff 97  	bl	0xffff0000000008f4 <init_rpi_interrupt_handler>
;   kprintf("[time = %d] Raspberry Pi interrupt controller has been configured \n", get32(TIMER_CLO));
ffff000000001b5c: 80 00 86 d2  	mov	x0, #12292
ffff000000001b60: 00 e0 a7 f2  	movk	x0, #16128, lsl #16
ffff000000001b64: f2 09 00 94  	bl	0xffff00000000432c <get32>
ffff000000001b68: e1 03 00 2a  	mov	w1, w0
ffff000000001b6c: 00 00 00 f0  	adrp	x0, #12288
ffff000000001b70: 00 e0 1d 91  	add	x0, x0, #1912
ffff000000001b74: 37 ff ff 97  	bl	0xffff000000001850 <kprintf>
;   enable_irq();   
ffff000000001b78: dd 09 00 94  	bl	0xffff0000000042ec <enable_irq>
;   kprintf("[time = %d] Interrupt Requests Have Been Enabled\n", get32(TIMER_CLO));
ffff000000001b7c: 80 00 86 d2  	mov	x0, #12292
ffff000000001b80: 00 e0 a7 f2  	movk	x0, #16128, lsl #16
ffff000000001b84: ea 09 00 94  	bl	0xffff00000000432c <get32>
ffff000000001b88: e1 03 00 2a  	mov	w1, w0
ffff000000001b8c: 00 00 00 f0  	adrp	x0, #12288
ffff000000001b90: 00 00 1f 91  	add	x0, x0, #1984
ffff000000001b94: 2f ff ff 97  	bl	0xffff000000001850 <kprintf>
;   init_paging();
ffff000000001b98: 9b 00 00 94  	bl	0xffff000000001e04 <init_paging>
;   kprintf("[time = %d] Paging has been initialized\n", get32(TIMER_CLO));
ffff000000001b9c: 80 00 86 d2  	mov	x0, #12292
ffff000000001ba0: 00 e0 a7 f2  	movk	x0, #16128, lsl #16
ffff000000001ba4: e2 09 00 94  	bl	0xffff00000000432c <get32>
ffff000000001ba8: e1 03 00 2a  	mov	w1, w0
ffff000000001bac: 00 00 00 f0  	adrp	x0, #12288
ffff000000001bb0: 00 e0 1f 91  	add	x0, x0, #2040
ffff000000001bb4: 27 ff ff 97  	bl	0xffff000000001850 <kprintf>
;   init_scheduler();
ffff000000001bb8: 26 01 00 94  	bl	0xffff000000002050 <init_scheduler>
;   kprintf("[time = %d] Scheduler has been initialized\n", get32(TIMER_CLO));
ffff000000001bbc: 80 00 86 d2  	mov	x0, #12292
ffff000000001bc0: 00 e0 a7 f2  	movk	x0, #16128, lsl #16
ffff000000001bc4: da 09 00 94  	bl	0xffff00000000432c <get32>
ffff000000001bc8: e1 03 00 2a  	mov	w1, w0
ffff000000001bcc: 00 00 00 f0  	adrp	x0, #12288
ffff000000001bd0: 00 a0 20 91  	add	x0, x0, #2088
ffff000000001bd4: 1f ff ff 97  	bl	0xffff000000001850 <kprintf>
;   kprintf("[time = %d] The kernel is operating in exception level %d\n", get32(TIMER_CLO), getExceptionLevel());
ffff000000001bd8: 80 00 86 d2  	mov	x0, #12292
ffff000000001bdc: 00 e0 a7 f2  	movk	x0, #16128, lsl #16
ffff000000001be0: d3 09 00 94  	bl	0xffff00000000432c <get32>
ffff000000001be4: f3 03 00 2a  	mov	w19, w0
ffff000000001be8: 51 f9 ff 97  	bl	0xffff00000000012c <getExceptionLevel>
ffff000000001bec: e2 03 00 2a  	mov	w2, w0
ffff000000001bf0: e1 03 13 2a  	mov	w1, w19
ffff000000001bf4: 00 00 00 f0  	adrp	x0, #12288
ffff000000001bf8: 00 60 21 91  	add	x0, x0, #2136
ffff000000001bfc: 15 ff ff 97  	bl	0xffff000000001850 <kprintf>
;   kprintf("===============================================================================\n");
ffff000000001c00: 00 00 00 f0  	adrp	x0, #12288
ffff000000001c04: 00 00 1a 91  	add	x0, x0, #1664
ffff000000001c08: 12 ff ff 97  	bl	0xffff000000001850 <kprintf>
;   kprintf("Address of kernel pt: %p\n", &kernel_page_table_start);
ffff000000001c0c: 20 02 00 90  	adrp	x0, #278528
ffff000000001c10: 01 00 00 91  	add	x1, x0, #0
ffff000000001c14: 00 00 00 f0  	adrp	x0, #12288
ffff000000001c18: 00 60 22 91  	add	x0, x0, #2200
ffff000000001c1c: 0d ff ff 97  	bl	0xffff000000001850 <kprintf>
;   kprintf("This address should point to the base of the PGD table\n");
ffff000000001c20: 00 00 00 f0  	adrp	x0, #12288
ffff000000001c24: 00 e0 22 91  	add	x0, x0, #2232
ffff000000001c28: 0a ff ff 97  	bl	0xffff000000001850 <kprintf>
;   unsigned long *pgd = (unsigned long *) &kernel_page_table_start;
ffff000000001c2c: 20 02 00 90  	adrp	x0, #278528
ffff000000001c30: 00 00 00 91  	add	x0, x0, #0
ffff000000001c34: e0 1f 00 f9  	str	x0, [sp, #56]
;   kprintf("PGD Table Dump:\n");
ffff000000001c38: 00 00 00 f0  	adrp	x0, #12288
ffff000000001c3c: 00 c0 23 91  	add	x0, x0, #2288
ffff000000001c40: 04 ff ff 97  	bl	0xffff000000001850 <kprintf>
;   for (int i = 0; i < 512; i++) {
ffff000000001c44: ff 4f 00 b9  	str	wzr, [sp, #76]
ffff000000001c48: 0f 00 00 14  	b	0xffff000000001c84 <kmain+0x1ac>
;     unsigned long curr = *(pgd + i);
ffff000000001c4c: e0 4f 80 b9  	ldrsw	x0, [sp, #76]
ffff000000001c50: 00 f0 7d d3  	lsl	x0, x0, #3
ffff000000001c54: e1 1f 40 f9  	ldr	x1, [sp, #56]
ffff000000001c58: 20 00 00 8b  	add	x0, x1, x0
ffff000000001c5c: 00 00 40 f9  	ldr	x0, [x0]
ffff000000001c60: e0 13 00 f9  	str	x0, [sp, #32]
;     kprintf("[%d] %d\n", i, curr);
ffff000000001c64: e2 13 40 f9  	ldr	x2, [sp, #32]
ffff000000001c68: e1 4f 40 b9  	ldr	w1, [sp, #76]
ffff000000001c6c: 00 00 00 f0  	adrp	x0, #12288
ffff000000001c70: 00 20 24 91  	add	x0, x0, #2312
ffff000000001c74: f7 fe ff 97  	bl	0xffff000000001850 <kprintf>
;   for (int i = 0; i < 512; i++) {
ffff000000001c78: e0 4f 40 b9  	ldr	w0, [sp, #76]
ffff000000001c7c: 00 04 00 11  	add	w0, w0, #1
ffff000000001c80: e0 4f 00 b9  	str	w0, [sp, #76]
ffff000000001c84: e0 4f 40 b9  	ldr	w0, [sp, #76]
ffff000000001c88: 1f fc 07 71  	cmp	w0, #511
ffff000000001c8c: 0d fe ff 54  	b.le	0xffff000000001c4c <kmain+0x174>
;   pgd += 512;
ffff000000001c90: e0 1f 40 f9  	ldr	x0, [sp, #56]
ffff000000001c94: 00 04 40 91  	add	x0, x0, #1, lsl #12
ffff000000001c98: e0 1f 00 f9  	str	x0, [sp, #56]
;   kprintf("PUD Table Dump:\n");
ffff000000001c9c: 00 00 00 f0  	adrp	x0, #12288
ffff000000001ca0: 00 60 24 91  	add	x0, x0, #2328
ffff000000001ca4: eb fe ff 97  	bl	0xffff000000001850 <kprintf>
;   for (int i = 0; i < 512; i++) {
ffff000000001ca8: ff 4b 00 b9  	str	wzr, [sp, #72]
ffff000000001cac: 0f 00 00 14  	b	0xffff000000001ce8 <kmain+0x210>
;     unsigned long curr = *(pgd + i);
ffff000000001cb0: e0 4b 80 b9  	ldrsw	x0, [sp, #72]
ffff000000001cb4: 00 f0 7d d3  	lsl	x0, x0, #3
ffff000000001cb8: e1 1f 40 f9  	ldr	x1, [sp, #56]
ffff000000001cbc: 20 00 00 8b  	add	x0, x1, x0
ffff000000001cc0: 00 00 40 f9  	ldr	x0, [x0]
ffff000000001cc4: e0 17 00 f9  	str	x0, [sp, #40]
;     kprintf("[%d] %d\n", i, curr);
ffff000000001cc8: e2 17 40 f9  	ldr	x2, [sp, #40]
ffff000000001ccc: e1 4b 40 b9  	ldr	w1, [sp, #72]
ffff000000001cd0: 00 00 00 f0  	adrp	x0, #12288
ffff000000001cd4: 00 20 24 91  	add	x0, x0, #2312
ffff000000001cd8: de fe ff 97  	bl	0xffff000000001850 <kprintf>
;   for (int i = 0; i < 512; i++) {
ffff000000001cdc: e0 4b 40 b9  	ldr	w0, [sp, #72]
ffff000000001ce0: 00 04 00 11  	add	w0, w0, #1
ffff000000001ce4: e0 4b 00 b9  	str	w0, [sp, #72]
ffff000000001ce8: e0 4b 40 b9  	ldr	w0, [sp, #72]
ffff000000001cec: 1f fc 07 71  	cmp	w0, #511
ffff000000001cf0: 0d fe ff 54  	b.le	0xffff000000001cb0 <kmain+0x1d8>
;   pgd += 512;
ffff000000001cf4: e0 1f 40 f9  	ldr	x0, [sp, #56]
ffff000000001cf8: 00 04 40 91  	add	x0, x0, #1, lsl #12
ffff000000001cfc: e0 1f 00 f9  	str	x0, [sp, #56]
;   kprintf("PMD Table Dump:\n");
ffff000000001d00: 00 00 00 f0  	adrp	x0, #12288
ffff000000001d04: 00 c0 24 91  	add	x0, x0, #2352
ffff000000001d08: d2 fe ff 97  	bl	0xffff000000001850 <kprintf>
;   for (int i = 0; i < 512; i++) {
ffff000000001d0c: ff 47 00 b9  	str	wzr, [sp, #68]
ffff000000001d10: 12 00 00 14  	b	0xffff000000001d58 <kmain+0x280>
;     unsigned long curr = *(pgd + i);
ffff000000001d14: e0 47 80 b9  	ldrsw	x0, [sp, #68]
ffff000000001d18: 00 f0 7d d3  	lsl	x0, x0, #3
ffff000000001d1c: e1 1f 40 f9  	ldr	x1, [sp, #56]
ffff000000001d20: 20 00 00 8b  	add	x0, x1, x0
ffff000000001d24: 00 00 40 f9  	ldr	x0, [x0]
ffff000000001d28: e0 1b 00 f9  	str	x0, [sp, #48]
;     kprintf("[%d] %d (%d)\n", i, curr, (curr >> 12));
ffff000000001d2c: e0 1b 40 f9  	ldr	x0, [sp, #48]
ffff000000001d30: 00 fc 4c d3  	lsr	x0, x0, #12
ffff000000001d34: e3 03 00 aa  	mov	x3, x0
ffff000000001d38: e2 1b 40 f9  	ldr	x2, [sp, #48]
ffff000000001d3c: e1 47 40 b9  	ldr	w1, [sp, #68]
ffff000000001d40: 00 00 00 f0  	adrp	x0, #12288
ffff000000001d44: 00 20 25 91  	add	x0, x0, #2376
ffff000000001d48: c2 fe ff 97  	bl	0xffff000000001850 <kprintf>
;   for (int i = 0; i < 512; i++) {
ffff000000001d4c: e0 47 40 b9  	ldr	w0, [sp, #68]
ffff000000001d50: 00 04 00 11  	add	w0, w0, #1
ffff000000001d54: e0 47 00 b9  	str	w0, [sp, #68]
ffff000000001d58: e0 47 40 b9  	ldr	w0, [sp, #68]
ffff000000001d5c: 1f fc 07 71  	cmp	w0, #511
ffff000000001d60: ad fd ff 54  	b.le	0xffff000000001d14 <kmain+0x23c>
;   asm volatile ("ldr x0, =kmain");
ffff000000001d64: 20 01 00 58  	ldr	x0, 0xffff000000001d88 <$d>
;   asm volatile ("lsl x0, x0, #17");
ffff000000001d68: 00 b8 6f d3  	lsl	x0, x0, #17
;   asm volatile ("lsr x0, x0, #17");
ffff000000001d6c: 00 fc 51 d3  	lsr	x0, x0, #17
;   asm volatile ("br x0");
ffff000000001d70: 00 00 1f d6  	br	x0
;     kprintf("*");
ffff000000001d74: 00 00 00 f0  	adrp	x0, #12288
ffff000000001d78: 00 60 25 91  	add	x0, x0, #2392
ffff000000001d7c: b5 fe ff 97  	bl	0xffff000000001850 <kprintf>
ffff000000001d80: fd ff ff 17  	b	0xffff000000001d74 <kmain+0x29c>
ffff000000001d84: 00 00 00 00  	udf	#0

ffff000000001d88 <$d>:
ffff000000001d88:	d8 1a 00 00	.word	0x00001ad8
ffff000000001d8c:	00 00 ff ff	.word	0xffff0000

ffff000000001d90 <memcpy>:
; void memcpy(void *src, void *dest, size_t num_bytes) {
ffff000000001d90: ff 03 01 d1  	sub	sp, sp, #64
ffff000000001d94: e0 0f 00 f9  	str	x0, [sp, #24]
ffff000000001d98: e1 0b 00 f9  	str	x1, [sp, #16]
ffff000000001d9c: e2 07 00 f9  	str	x2, [sp, #8]
;     char *destPtr = (char *) dest;
ffff000000001da0: e0 0b 40 f9  	ldr	x0, [sp, #16]
ffff000000001da4: e0 1b 00 f9  	str	x0, [sp, #48]
;     char *srcPtr = (char *) src;
ffff000000001da8: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff000000001dac: e0 17 00 f9  	str	x0, [sp, #40]
;     for (int i = 0; i < num_bytes; ++i)
ffff000000001db0: ff 3f 00 b9  	str	wzr, [sp, #60]
ffff000000001db4: 0c 00 00 14  	b	0xffff000000001de4 <memcpy+0x54>
;         destPtr[i]=srcPtr[i];
ffff000000001db8: e0 3f 80 b9  	ldrsw	x0, [sp, #60]
ffff000000001dbc: e1 17 40 f9  	ldr	x1, [sp, #40]
ffff000000001dc0: 21 00 00 8b  	add	x1, x1, x0
ffff000000001dc4: e0 3f 80 b9  	ldrsw	x0, [sp, #60]
ffff000000001dc8: e2 1b 40 f9  	ldr	x2, [sp, #48]
ffff000000001dcc: 40 00 00 8b  	add	x0, x2, x0
ffff000000001dd0: 21 00 40 39  	ldrb	w1, [x1]
ffff000000001dd4: 01 00 00 39  	strb	w1, [x0]
;     for (int i = 0; i < num_bytes; ++i)
ffff000000001dd8: e0 3f 40 b9  	ldr	w0, [sp, #60]
ffff000000001ddc: 00 04 00 11  	add	w0, w0, #1
ffff000000001de0: e0 3f 00 b9  	str	w0, [sp, #60]
ffff000000001de4: e0 3f 80 b9  	ldrsw	x0, [sp, #60]
ffff000000001de8: e1 07 40 f9  	ldr	x1, [sp, #8]
ffff000000001dec: 3f 00 00 eb  	cmp	x1, x0
ffff000000001df0: 48 fe ff 54  	b.hi	0xffff000000001db8 <memcpy+0x28>
; }
ffff000000001df4: 1f 20 03 d5  	nop
ffff000000001df8: 1f 20 03 d5  	nop
ffff000000001dfc: ff 03 01 91  	add	sp, sp, #64
ffff000000001e00: c0 03 5f d6  	ret

ffff000000001e04 <init_paging>:
; void init_paging() {
ffff000000001e04: fd 7b bf a9  	stp	x29, x30, [sp, #-16]!
ffff000000001e08: fd 03 00 91  	mov	x29, sp
;     kprintf("Given that a page size is %d bytes and there are %d free bytes, there are %d free pages\n", PAGE_SIZE, NUM_FREE_BYTES, NUM_PAGES);
ffff000000001e0c: e3 7f 9d 52  	mov	w3, #60415
ffff000000001e10: 63 00 a0 72  	movk	w3, #3, lsl #16
ffff000000001e14: 02 00 9e 52  	mov	w2, #61440
ffff000000001e18: e2 d7 a7 72  	movk	w2, #16063, lsl #16
ffff000000001e1c: 01 00 82 52  	mov	w1, #4096
ffff000000001e20: 00 00 00 f0  	adrp	x0, #12288
ffff000000001e24: 00 80 25 91  	add	x0, x0, #2400
ffff000000001e28: 8a fe ff 97  	bl	0xffff000000001850 <kprintf>
;     kprintf("The calculation for NUM_FREE_BYTES is %d-%d=%d\n", MMIO_BASE, START_OF_KERNEL_STACK_CPU2, NUM_FREE_BYTES);
ffff000000001e2c: 03 00 9e 52  	mov	w3, #61440
ffff000000001e30: e3 d7 a7 72  	movk	w3, #16063, lsl #16
ffff000000001e34: 02 00 82 52  	mov	w2, #4096
ffff000000001e38: 02 08 a0 72  	movk	w2, #64, lsl #16
ffff000000001e3c: 01 e0 a7 52  	mov	w1, #1056964608
ffff000000001e40: 00 00 00 f0  	adrp	x0, #12288
ffff000000001e44: 00 00 27 91  	add	x0, x0, #2496
ffff000000001e48: 82 fe ff 97  	bl	0xffff000000001850 <kprintf>
;     kprintf("Paging Start Address: %d\n", &__paging_start);
ffff000000001e4c: 00 20 00 90  	adrp	x0, #4194304
ffff000000001e50: 01 00 00 91  	add	x1, x0, #0
ffff000000001e54: 00 00 00 f0  	adrp	x0, #12288
ffff000000001e58: 00 c0 27 91  	add	x0, x0, #2544
ffff000000001e5c: 7d fe ff 97  	bl	0xffff000000001850 <kprintf>
;     paging_map_arr[0].isAllocated = true;
ffff000000001e60: 20 00 00 90  	adrp	x0, #16384
ffff000000001e64: 00 20 17 91  	add	x0, x0, #1480
ffff000000001e68: 21 00 80 52  	mov	w1, #1
ffff000000001e6c: 01 00 00 39  	strb	w1, [x0]
; }
ffff000000001e70: 1f 20 03 d5  	nop
ffff000000001e74: fd 7b c1 a8  	ldp	x29, x30, [sp], #16
ffff000000001e78: c0 03 5f d6  	ret

ffff000000001e7c <alloc_page>:
; void *alloc_page() {
ffff000000001e7c: fd 7b be a9  	stp	x29, x30, [sp, #-32]!
ffff000000001e80: fd 03 00 91  	mov	x29, sp
;     kprintf("Alloc page called....");
ffff000000001e84: 00 00 00 f0  	adrp	x0, #12288
ffff000000001e88: 00 40 28 91  	add	x0, x0, #2576
ffff000000001e8c: 71 fe ff 97  	bl	0xffff000000001850 <kprintf>
;     for (int i = 0; i < NUM_PAGES; ++i) {
ffff000000001e90: ff 1f 00 b9  	str	wzr, [sp, #28]
ffff000000001e94: 22 00 00 14  	b	0xffff000000001f1c <alloc_page+0xa0>
;         if (paging_map_arr[i].isAllocated) {
ffff000000001e98: 20 00 00 90  	adrp	x0, #16384
ffff000000001e9c: 01 20 17 91  	add	x1, x0, #1480
ffff000000001ea0: e0 1f 80 b9  	ldrsw	x0, [sp, #28]
ffff000000001ea4: 20 68 60 38  	ldrb	w0, [x1, x0]
ffff000000001ea8: 1f 00 00 71  	cmp	w0, #0
ffff000000001eac: 01 03 00 54  	b.ne	0xffff000000001f0c <alloc_page+0x90>
;         kprintf("giving page %d to the caller with page address %p\n", i, (&__paging_start + i*PAGE_SIZE));
ffff000000001eb0: e0 1f 40 b9  	ldr	w0, [sp, #28]
ffff000000001eb4: 00 4c 14 53  	lsl	w0, w0, #12
ffff000000001eb8: 01 7c 40 93  	sxtw	x1, w0
ffff000000001ebc: 00 20 00 90  	adrp	x0, #4194304
ffff000000001ec0: 00 00 00 91  	add	x0, x0, #0
ffff000000001ec4: 20 00 00 8b  	add	x0, x1, x0
ffff000000001ec8: e2 03 00 aa  	mov	x2, x0
ffff000000001ecc: e1 1f 40 b9  	ldr	w1, [sp, #28]
ffff000000001ed0: 00 00 00 f0  	adrp	x0, #12288
ffff000000001ed4: 00 a0 28 91  	add	x0, x0, #2600
ffff000000001ed8: 5e fe ff 97  	bl	0xffff000000001850 <kprintf>
;         paging_map_arr[i].isAllocated = true;
ffff000000001edc: 20 00 00 90  	adrp	x0, #16384
ffff000000001ee0: 01 20 17 91  	add	x1, x0, #1480
ffff000000001ee4: e0 1f 80 b9  	ldrsw	x0, [sp, #28]
ffff000000001ee8: 22 00 80 52  	mov	w2, #1
ffff000000001eec: 22 68 20 38  	strb	w2, [x1, x0]
;         return (void *) &__paging_start + i*PAGE_SIZE;
ffff000000001ef0: e0 1f 40 b9  	ldr	w0, [sp, #28]
ffff000000001ef4: 00 4c 14 53  	lsl	w0, w0, #12
ffff000000001ef8: 01 7c 40 93  	sxtw	x1, w0
ffff000000001efc: 00 20 00 90  	adrp	x0, #4194304
ffff000000001f00: 00 00 00 91  	add	x0, x0, #0
ffff000000001f04: 20 00 00 8b  	add	x0, x1, x0
ffff000000001f08: 0b 00 00 14  	b	0xffff000000001f34 <alloc_page+0xb8>
;             continue;
ffff000000001f0c: 1f 20 03 d5  	nop
;     for (int i = 0; i < NUM_PAGES; ++i) {
ffff000000001f10: e0 1f 40 b9  	ldr	w0, [sp, #28]
ffff000000001f14: 00 04 00 11  	add	w0, w0, #1
ffff000000001f18: e0 1f 00 b9  	str	w0, [sp, #28]
ffff000000001f1c: e1 1f 40 b9  	ldr	w1, [sp, #28]
ffff000000001f20: c0 7f 9d 52  	mov	w0, #60414
ffff000000001f24: 60 00 a0 72  	movk	w0, #3, lsl #16
ffff000000001f28: 3f 00 00 6b  	cmp	w1, w0
ffff000000001f2c: 6d fb ff 54  	b.le	0xffff000000001e98 <alloc_page+0x1c>
;     return 0;
ffff000000001f30: 00 00 80 d2  	mov	x0, #0
; }
ffff000000001f34: fd 7b c2 a8  	ldp	x29, x30, [sp], #32
ffff000000001f38: c0 03 5f d6  	ret

ffff000000001f3c <free_page>:
; void free_page(void *page_adr) {
ffff000000001f3c: fd 7b bd a9  	stp	x29, x30, [sp, #-48]!
ffff000000001f40: fd 03 00 91  	mov	x29, sp
ffff000000001f44: e0 0f 00 f9  	str	x0, [sp, #24]
;     int idx = (page_adr - (void *) &__paging_start) / PAGE_SIZE;
ffff000000001f48: e1 0f 40 f9  	ldr	x1, [sp, #24]
ffff000000001f4c: 00 20 00 90  	adrp	x0, #4194304
ffff000000001f50: 00 00 00 91  	add	x0, x0, #0
ffff000000001f54: 20 00 00 cb  	sub	x0, x1, x0
ffff000000001f58: 01 fc 3f 91  	add	x1, x0, #4095
ffff000000001f5c: 1f 00 00 f1  	cmp	x0, #0
ffff000000001f60: 20 b0 80 9a  	csel	x0, x1, x0, lt
ffff000000001f64: 00 fc 4c 93  	asr	x0, x0, #12
ffff000000001f68: e0 2f 00 b9  	str	w0, [sp, #44]
;     kprintf("Free page called with page address %p, this seems to have been from index %d\n", page_adr, idx);
ffff000000001f6c: e2 2f 40 b9  	ldr	w2, [sp, #44]
ffff000000001f70: e1 0f 40 f9  	ldr	x1, [sp, #24]
ffff000000001f74: 00 00 00 f0  	adrp	x0, #12288
ffff000000001f78: 00 80 29 91  	add	x0, x0, #2656
ffff000000001f7c: 35 fe ff 97  	bl	0xffff000000001850 <kprintf>
;     paging_map_arr[idx].isAllocated = false;
ffff000000001f80: 20 00 00 90  	adrp	x0, #16384
ffff000000001f84: 01 20 17 91  	add	x1, x0, #1480
ffff000000001f88: e0 2f 80 b9  	ldrsw	x0, [sp, #44]
ffff000000001f8c: 3f 68 20 38  	strb	wzr, [x1, x0]
; }
ffff000000001f90: 1f 20 03 d5  	nop
ffff000000001f94: fd 7b c3 a8  	ldp	x29, x30, [sp], #48
ffff000000001f98: c0 03 5f d6  	ret

ffff000000001f9c <alloc_listNode>:
; struct pcb_list *alloc_listNode() {
ffff000000001f9c: fd 7b be a9  	stp	x29, x30, [sp, #-32]!
ffff000000001fa0: fd 03 00 91  	mov	x29, sp
;     void *ptr = kmalloc(sizeof(struct pcb_list));
ffff000000001fa4: 00 02 80 d2  	mov	x0, #16
ffff000000001fa8: 35 fb ff 97  	bl	0xffff000000000c7c <kmalloc>
ffff000000001fac: e0 0f 00 f9  	str	x0, [sp, #24]
;     klog("Allocated new pcb list node at address %p\n", ptr);
ffff000000001fb0: e1 0f 40 f9  	ldr	x1, [sp, #24]
ffff000000001fb4: 00 00 00 f0  	adrp	x0, #12288
ffff000000001fb8: 00 c0 2a 91  	add	x0, x0, #2736
ffff000000001fbc: 45 fe ff 97  	bl	0xffff0000000018d0 <klog>
;     memzero(ptr, sizeof(struct pcb_list));
ffff000000001fc0: 01 02 80 d2  	mov	x1, #16
ffff000000001fc4: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff000000001fc8: d2 08 00 94  	bl	0xffff000000004310 <memzero>
;     return ptr;
ffff000000001fcc: e0 0f 40 f9  	ldr	x0, [sp, #24]
; }
ffff000000001fd0: fd 7b c2 a8  	ldp	x29, x30, [sp], #32
ffff000000001fd4: c0 03 5f d6  	ret

ffff000000001fd8 <alloc_pcb>:
; struct pcb *alloc_pcb() {
ffff000000001fd8: fd 7b be a9  	stp	x29, x30, [sp, #-32]!
ffff000000001fdc: fd 03 00 91  	mov	x29, sp
;     void *ptr = kmalloc(sizeof(struct pcb));
ffff000000001fe0: 00 25 80 d2  	mov	x0, #296
ffff000000001fe4: 26 fb ff 97  	bl	0xffff000000000c7c <kmalloc>
ffff000000001fe8: e0 0f 00 f9  	str	x0, [sp, #24]
;     klog("Allocated new pcb entry at address %p\n", ptr);
ffff000000001fec: e1 0f 40 f9  	ldr	x1, [sp, #24]
ffff000000001ff0: 00 00 00 f0  	adrp	x0, #12288
ffff000000001ff4: 00 80 2b 91  	add	x0, x0, #2784
ffff000000001ff8: 36 fe ff 97  	bl	0xffff0000000018d0 <klog>
;     memzero(ptr, sizeof(struct pcb));
ffff000000001ffc: 01 25 80 d2  	mov	x1, #296
ffff000000002000: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff000000002004: c3 08 00 94  	bl	0xffff000000004310 <memzero>
;     return ptr;
ffff000000002008: e0 0f 40 f9  	ldr	x0, [sp, #24]
; }
ffff00000000200c: fd 7b c2 a8  	ldp	x29, x30, [sp], #32
ffff000000002010: c0 03 5f d6  	ret

ffff000000002014 <getNextPID>:
;     numProcesses++;
ffff000000002014: 00 02 00 d0  	adrp	x0, #270336
ffff000000002018: 00 60 07 91  	add	x0, x0, #472
ffff00000000201c: 00 00 40 b9  	ldr	w0, [x0]
ffff000000002020: 01 04 00 11  	add	w1, w0, #1
ffff000000002024: 00 02 00 d0  	adrp	x0, #270336
ffff000000002028: 00 60 07 91  	add	x0, x0, #472
ffff00000000202c: 01 00 00 b9  	str	w1, [x0]
;     return nextPID++;
ffff000000002030: 00 02 00 d0  	adrp	x0, #270336
ffff000000002034: 00 70 07 91  	add	x0, x0, #476
ffff000000002038: 00 00 40 b9  	ldr	w0, [x0]
ffff00000000203c: 02 04 00 11  	add	w2, w0, #1
ffff000000002040: 01 02 00 d0  	adrp	x1, #270336
ffff000000002044: 21 70 07 91  	add	x1, x1, #476
ffff000000002048: 22 00 00 b9  	str	w2, [x1]
; }
ffff00000000204c: c0 03 5f d6  	ret

ffff000000002050 <init_scheduler>:
; void init_scheduler() {
ffff000000002050: fd 7b be a9  	stp	x29, x30, [sp, #-32]!
ffff000000002054: fd 03 00 91  	mov	x29, sp
;     runqueue = alloc_listNode();
ffff000000002058: d1 ff ff 97  	bl	0xffff000000001f9c <alloc_listNode>
ffff00000000205c: e1 03 00 aa  	mov	x1, x0
ffff000000002060: 00 02 00 d0  	adrp	x0, #270336
ffff000000002064: 00 20 07 91  	add	x0, x0, #456
ffff000000002068: 01 00 00 f9  	str	x1, [x0]
;     struct pcb *main_pcb = alloc_pcb();
ffff00000000206c: db ff ff 97  	bl	0xffff000000001fd8 <alloc_pcb>
ffff000000002070: e0 0f 00 f9  	str	x0, [sp, #24]
;     main_pcb->pid = getNextPID();
ffff000000002074: e8 ff ff 97  	bl	0xffff000000002014 <getNextPID>
ffff000000002078: e1 03 00 2a  	mov	w1, w0
ffff00000000207c: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff000000002080: 01 10 01 b9  	str	w1, [x0, #272]
;     main_pcb->priority = 2;
ffff000000002084: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff000000002088: 41 00 80 52  	mov	w1, #2
ffff00000000208c: 01 84 04 39  	strb	w1, [x0, #289]
;     main_pcb->state = STATE_RUNNING;
ffff000000002090: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff000000002094: 21 00 80 52  	mov	w1, #1
ffff000000002098: 01 80 04 39  	strb	w1, [x0, #288]
;     runqueue->pcb = main_pcb;
ffff00000000209c: 00 02 00 d0  	adrp	x0, #270336
ffff0000000020a0: 00 20 07 91  	add	x0, x0, #456
ffff0000000020a4: 00 00 40 f9  	ldr	x0, [x0]
ffff0000000020a8: e1 0f 40 f9  	ldr	x1, [sp, #24]
ffff0000000020ac: 01 00 00 f9  	str	x1, [x0]
;     currProc = main_pcb;
ffff0000000020b0: 00 02 00 d0  	adrp	x0, #270336
ffff0000000020b4: 00 40 07 91  	add	x0, x0, #464
ffff0000000020b8: e1 0f 40 f9  	ldr	x1, [sp, #24]
ffff0000000020bc: 01 00 00 f9  	str	x1, [x0]
; }
ffff0000000020c0: 1f 20 03 d5  	nop
ffff0000000020c4: fd 7b c2 a8  	ldp	x29, x30, [sp], #32
ffff0000000020c8: c0 03 5f d6  	ret

ffff0000000020cc <do_switch_register_state>:
; void do_switch_register_state() {
ffff0000000020cc: ff 43 00 d1  	sub	sp, sp, #16
;     long *base = (long *) 4210688;
ffff0000000020d0: 00 00 88 d2  	mov	x0, #16384
ffff0000000020d4: 00 08 a0 f2  	movk	x0, #64, lsl #16
ffff0000000020d8: e0 07 00 f9  	str	x0, [sp, #8]
;     *(base + 0) = currProc->registers.x0;
ffff0000000020dc: 00 02 00 d0  	adrp	x0, #270336
ffff0000000020e0: 00 40 07 91  	add	x0, x0, #464
ffff0000000020e4: 00 00 40 f9  	ldr	x0, [x0]
ffff0000000020e8: 01 00 40 f9  	ldr	x1, [x0]
ffff0000000020ec: e0 07 40 f9  	ldr	x0, [sp, #8]
ffff0000000020f0: 01 00 00 f9  	str	x1, [x0]
;     *(base + 1) = currProc->registers.x1;
ffff0000000020f4: 00 02 00 d0  	adrp	x0, #270336
ffff0000000020f8: 00 40 07 91  	add	x0, x0, #464
ffff0000000020fc: 01 00 40 f9  	ldr	x1, [x0]
ffff000000002100: e0 07 40 f9  	ldr	x0, [sp, #8]
ffff000000002104: 00 20 00 91  	add	x0, x0, #8
ffff000000002108: 21 04 40 f9  	ldr	x1, [x1, #8]
ffff00000000210c: 01 00 00 f9  	str	x1, [x0]
;     *(base + 2) = currProc->registers.x2;
ffff000000002110: 00 02 00 d0  	adrp	x0, #270336
ffff000000002114: 00 40 07 91  	add	x0, x0, #464
ffff000000002118: 01 00 40 f9  	ldr	x1, [x0]
ffff00000000211c: e0 07 40 f9  	ldr	x0, [sp, #8]
ffff000000002120: 00 40 00 91  	add	x0, x0, #16
ffff000000002124: 21 08 40 f9  	ldr	x1, [x1, #16]
ffff000000002128: 01 00 00 f9  	str	x1, [x0]
;     *(base + 3) = currProc->registers.x3;
ffff00000000212c: 00 02 00 d0  	adrp	x0, #270336
ffff000000002130: 00 40 07 91  	add	x0, x0, #464
ffff000000002134: 01 00 40 f9  	ldr	x1, [x0]
ffff000000002138: e0 07 40 f9  	ldr	x0, [sp, #8]
ffff00000000213c: 00 60 00 91  	add	x0, x0, #24
ffff000000002140: 21 0c 40 f9  	ldr	x1, [x1, #24]
ffff000000002144: 01 00 00 f9  	str	x1, [x0]
;     *(base + 4) = currProc->registers.x4;
ffff000000002148: 00 02 00 d0  	adrp	x0, #270336
ffff00000000214c: 00 40 07 91  	add	x0, x0, #464
ffff000000002150: 01 00 40 f9  	ldr	x1, [x0]
ffff000000002154: e0 07 40 f9  	ldr	x0, [sp, #8]
ffff000000002158: 00 80 00 91  	add	x0, x0, #32
ffff00000000215c: 21 10 40 f9  	ldr	x1, [x1, #32]
ffff000000002160: 01 00 00 f9  	str	x1, [x0]
;     *(base + 5) = currProc->registers.x5;
ffff000000002164: 00 02 00 d0  	adrp	x0, #270336
ffff000000002168: 00 40 07 91  	add	x0, x0, #464
ffff00000000216c: 01 00 40 f9  	ldr	x1, [x0]
ffff000000002170: e0 07 40 f9  	ldr	x0, [sp, #8]
ffff000000002174: 00 a0 00 91  	add	x0, x0, #40
ffff000000002178: 21 14 40 f9  	ldr	x1, [x1, #40]
ffff00000000217c: 01 00 00 f9  	str	x1, [x0]
;     *(base + 6) = currProc->registers.x6;
ffff000000002180: 00 02 00 d0  	adrp	x0, #270336
ffff000000002184: 00 40 07 91  	add	x0, x0, #464
ffff000000002188: 01 00 40 f9  	ldr	x1, [x0]
ffff00000000218c: e0 07 40 f9  	ldr	x0, [sp, #8]
ffff000000002190: 00 c0 00 91  	add	x0, x0, #48
ffff000000002194: 21 18 40 f9  	ldr	x1, [x1, #48]
ffff000000002198: 01 00 00 f9  	str	x1, [x0]
;     *(base + 7) = currProc->registers.x7;
ffff00000000219c: 00 02 00 d0  	adrp	x0, #270336
ffff0000000021a0: 00 40 07 91  	add	x0, x0, #464
ffff0000000021a4: 01 00 40 f9  	ldr	x1, [x0]
ffff0000000021a8: e0 07 40 f9  	ldr	x0, [sp, #8]
ffff0000000021ac: 00 e0 00 91  	add	x0, x0, #56
ffff0000000021b0: 21 1c 40 f9  	ldr	x1, [x1, #56]
ffff0000000021b4: 01 00 00 f9  	str	x1, [x0]
;     *(base + 8) = currProc->registers.x8;
ffff0000000021b8: 00 02 00 d0  	adrp	x0, #270336
ffff0000000021bc: 00 40 07 91  	add	x0, x0, #464
ffff0000000021c0: 01 00 40 f9  	ldr	x1, [x0]
ffff0000000021c4: e0 07 40 f9  	ldr	x0, [sp, #8]
ffff0000000021c8: 00 00 01 91  	add	x0, x0, #64
ffff0000000021cc: 21 20 40 f9  	ldr	x1, [x1, #64]
ffff0000000021d0: 01 00 00 f9  	str	x1, [x0]
;     *(base + 9) = currProc->registers.x9;
ffff0000000021d4: 00 02 00 d0  	adrp	x0, #270336
ffff0000000021d8: 00 40 07 91  	add	x0, x0, #464
ffff0000000021dc: 01 00 40 f9  	ldr	x1, [x0]
ffff0000000021e0: e0 07 40 f9  	ldr	x0, [sp, #8]
ffff0000000021e4: 00 20 01 91  	add	x0, x0, #72
ffff0000000021e8: 21 24 40 f9  	ldr	x1, [x1, #72]
ffff0000000021ec: 01 00 00 f9  	str	x1, [x0]
;     *(base + 10) = currProc->registers.x10;
ffff0000000021f0: 00 02 00 d0  	adrp	x0, #270336
ffff0000000021f4: 00 40 07 91  	add	x0, x0, #464
ffff0000000021f8: 01 00 40 f9  	ldr	x1, [x0]
ffff0000000021fc: e0 07 40 f9  	ldr	x0, [sp, #8]
ffff000000002200: 00 40 01 91  	add	x0, x0, #80
ffff000000002204: 21 28 40 f9  	ldr	x1, [x1, #80]
ffff000000002208: 01 00 00 f9  	str	x1, [x0]
;     *(base + 11) = currProc->registers.x11;
ffff00000000220c: 00 02 00 d0  	adrp	x0, #270336
ffff000000002210: 00 40 07 91  	add	x0, x0, #464
ffff000000002214: 01 00 40 f9  	ldr	x1, [x0]
ffff000000002218: e0 07 40 f9  	ldr	x0, [sp, #8]
ffff00000000221c: 00 60 01 91  	add	x0, x0, #88
ffff000000002220: 21 2c 40 f9  	ldr	x1, [x1, #88]
ffff000000002224: 01 00 00 f9  	str	x1, [x0]
;     *(base + 12) = currProc->registers.x12;
ffff000000002228: 00 02 00 d0  	adrp	x0, #270336
ffff00000000222c: 00 40 07 91  	add	x0, x0, #464
ffff000000002230: 01 00 40 f9  	ldr	x1, [x0]
ffff000000002234: e0 07 40 f9  	ldr	x0, [sp, #8]
ffff000000002238: 00 80 01 91  	add	x0, x0, #96
ffff00000000223c: 21 30 40 f9  	ldr	x1, [x1, #96]
ffff000000002240: 01 00 00 f9  	str	x1, [x0]
;     *(base + 13) = currProc->registers.x13;
ffff000000002244: 00 02 00 d0  	adrp	x0, #270336
ffff000000002248: 00 40 07 91  	add	x0, x0, #464
ffff00000000224c: 01 00 40 f9  	ldr	x1, [x0]
ffff000000002250: e0 07 40 f9  	ldr	x0, [sp, #8]
ffff000000002254: 00 a0 01 91  	add	x0, x0, #104
ffff000000002258: 21 34 40 f9  	ldr	x1, [x1, #104]
ffff00000000225c: 01 00 00 f9  	str	x1, [x0]
;     *(base + 14) = currProc->registers.x14;
ffff000000002260: 00 02 00 d0  	adrp	x0, #270336
ffff000000002264: 00 40 07 91  	add	x0, x0, #464
ffff000000002268: 01 00 40 f9  	ldr	x1, [x0]
ffff00000000226c: e0 07 40 f9  	ldr	x0, [sp, #8]
ffff000000002270: 00 c0 01 91  	add	x0, x0, #112
ffff000000002274: 21 38 40 f9  	ldr	x1, [x1, #112]
ffff000000002278: 01 00 00 f9  	str	x1, [x0]
;     *(base + 15) = currProc->registers.x15;
ffff00000000227c: 00 02 00 d0  	adrp	x0, #270336
ffff000000002280: 00 40 07 91  	add	x0, x0, #464
ffff000000002284: 01 00 40 f9  	ldr	x1, [x0]
ffff000000002288: e0 07 40 f9  	ldr	x0, [sp, #8]
ffff00000000228c: 00 e0 01 91  	add	x0, x0, #120
ffff000000002290: 21 3c 40 f9  	ldr	x1, [x1, #120]
ffff000000002294: 01 00 00 f9  	str	x1, [x0]
;     *(base + 16) = currProc->registers.x16;
ffff000000002298: 00 02 00 d0  	adrp	x0, #270336
ffff00000000229c: 00 40 07 91  	add	x0, x0, #464
ffff0000000022a0: 01 00 40 f9  	ldr	x1, [x0]
ffff0000000022a4: e0 07 40 f9  	ldr	x0, [sp, #8]
ffff0000000022a8: 00 00 02 91  	add	x0, x0, #128
ffff0000000022ac: 21 40 40 f9  	ldr	x1, [x1, #128]
ffff0000000022b0: 01 00 00 f9  	str	x1, [x0]
;     *(base + 17) = currProc->registers.x17;
ffff0000000022b4: 00 02 00 d0  	adrp	x0, #270336
ffff0000000022b8: 00 40 07 91  	add	x0, x0, #464
ffff0000000022bc: 01 00 40 f9  	ldr	x1, [x0]
ffff0000000022c0: e0 07 40 f9  	ldr	x0, [sp, #8]
ffff0000000022c4: 00 20 02 91  	add	x0, x0, #136
ffff0000000022c8: 21 44 40 f9  	ldr	x1, [x1, #136]
ffff0000000022cc: 01 00 00 f9  	str	x1, [x0]
;     *(base + 18) = currProc->registers.x18;
ffff0000000022d0: 00 02 00 d0  	adrp	x0, #270336
ffff0000000022d4: 00 40 07 91  	add	x0, x0, #464
ffff0000000022d8: 01 00 40 f9  	ldr	x1, [x0]
ffff0000000022dc: e0 07 40 f9  	ldr	x0, [sp, #8]
ffff0000000022e0: 00 40 02 91  	add	x0, x0, #144
ffff0000000022e4: 21 48 40 f9  	ldr	x1, [x1, #144]
ffff0000000022e8: 01 00 00 f9  	str	x1, [x0]
;     *(base + 19) = currProc->registers.x19;
ffff0000000022ec: 00 02 00 d0  	adrp	x0, #270336
ffff0000000022f0: 00 40 07 91  	add	x0, x0, #464
ffff0000000022f4: 01 00 40 f9  	ldr	x1, [x0]
ffff0000000022f8: e0 07 40 f9  	ldr	x0, [sp, #8]
ffff0000000022fc: 00 60 02 91  	add	x0, x0, #152
ffff000000002300: 21 4c 40 f9  	ldr	x1, [x1, #152]
ffff000000002304: 01 00 00 f9  	str	x1, [x0]
;     *(base + 20) = currProc->registers.x20;
ffff000000002308: 00 02 00 d0  	adrp	x0, #270336
ffff00000000230c: 00 40 07 91  	add	x0, x0, #464
ffff000000002310: 01 00 40 f9  	ldr	x1, [x0]
ffff000000002314: e0 07 40 f9  	ldr	x0, [sp, #8]
ffff000000002318: 00 80 02 91  	add	x0, x0, #160
ffff00000000231c: 21 50 40 f9  	ldr	x1, [x1, #160]
ffff000000002320: 01 00 00 f9  	str	x1, [x0]
;     *(base + 21) = currProc->registers.x21;
ffff000000002324: 00 02 00 d0  	adrp	x0, #270336
ffff000000002328: 00 40 07 91  	add	x0, x0, #464
ffff00000000232c: 01 00 40 f9  	ldr	x1, [x0]
ffff000000002330: e0 07 40 f9  	ldr	x0, [sp, #8]
ffff000000002334: 00 a0 02 91  	add	x0, x0, #168
ffff000000002338: 21 54 40 f9  	ldr	x1, [x1, #168]
ffff00000000233c: 01 00 00 f9  	str	x1, [x0]
;     *(base + 22) = currProc->registers.x22;
ffff000000002340: 00 02 00 d0  	adrp	x0, #270336
ffff000000002344: 00 40 07 91  	add	x0, x0, #464
ffff000000002348: 01 00 40 f9  	ldr	x1, [x0]
ffff00000000234c: e0 07 40 f9  	ldr	x0, [sp, #8]
ffff000000002350: 00 c0 02 91  	add	x0, x0, #176
ffff000000002354: 21 58 40 f9  	ldr	x1, [x1, #176]
ffff000000002358: 01 00 00 f9  	str	x1, [x0]
;     *(base + 23) = currProc->registers.x23;
ffff00000000235c: 00 02 00 d0  	adrp	x0, #270336
ffff000000002360: 00 40 07 91  	add	x0, x0, #464
ffff000000002364: 01 00 40 f9  	ldr	x1, [x0]
ffff000000002368: e0 07 40 f9  	ldr	x0, [sp, #8]
ffff00000000236c: 00 e0 02 91  	add	x0, x0, #184
ffff000000002370: 21 5c 40 f9  	ldr	x1, [x1, #184]
ffff000000002374: 01 00 00 f9  	str	x1, [x0]
;     *(base + 24) = currProc->registers.x24;
ffff000000002378: 00 02 00 d0  	adrp	x0, #270336
ffff00000000237c: 00 40 07 91  	add	x0, x0, #464
ffff000000002380: 01 00 40 f9  	ldr	x1, [x0]
ffff000000002384: e0 07 40 f9  	ldr	x0, [sp, #8]
ffff000000002388: 00 00 03 91  	add	x0, x0, #192
ffff00000000238c: 21 60 40 f9  	ldr	x1, [x1, #192]
ffff000000002390: 01 00 00 f9  	str	x1, [x0]
;     *(base + 25) = currProc->registers.x25;
ffff000000002394: 00 02 00 d0  	adrp	x0, #270336
ffff000000002398: 00 40 07 91  	add	x0, x0, #464
ffff00000000239c: 01 00 40 f9  	ldr	x1, [x0]
ffff0000000023a0: e0 07 40 f9  	ldr	x0, [sp, #8]
ffff0000000023a4: 00 20 03 91  	add	x0, x0, #200
ffff0000000023a8: 21 64 40 f9  	ldr	x1, [x1, #200]
ffff0000000023ac: 01 00 00 f9  	str	x1, [x0]
;     *(base + 26) = currProc->registers.x26;
ffff0000000023b0: 00 02 00 d0  	adrp	x0, #270336
ffff0000000023b4: 00 40 07 91  	add	x0, x0, #464
ffff0000000023b8: 01 00 40 f9  	ldr	x1, [x0]
ffff0000000023bc: e0 07 40 f9  	ldr	x0, [sp, #8]
ffff0000000023c0: 00 40 03 91  	add	x0, x0, #208
ffff0000000023c4: 21 68 40 f9  	ldr	x1, [x1, #208]
ffff0000000023c8: 01 00 00 f9  	str	x1, [x0]
;     *(base + 27) = currProc->registers.x27;
ffff0000000023cc: 00 02 00 d0  	adrp	x0, #270336
ffff0000000023d0: 00 40 07 91  	add	x0, x0, #464
ffff0000000023d4: 01 00 40 f9  	ldr	x1, [x0]
ffff0000000023d8: e0 07 40 f9  	ldr	x0, [sp, #8]
ffff0000000023dc: 00 60 03 91  	add	x0, x0, #216
ffff0000000023e0: 21 6c 40 f9  	ldr	x1, [x1, #216]
ffff0000000023e4: 01 00 00 f9  	str	x1, [x0]
;     *(base + 28) = currProc->registers.x28;
ffff0000000023e8: 00 02 00 d0  	adrp	x0, #270336
ffff0000000023ec: 00 40 07 91  	add	x0, x0, #464
ffff0000000023f0: 01 00 40 f9  	ldr	x1, [x0]
ffff0000000023f4: e0 07 40 f9  	ldr	x0, [sp, #8]
ffff0000000023f8: 00 80 03 91  	add	x0, x0, #224
ffff0000000023fc: 21 70 40 f9  	ldr	x1, [x1, #224]
ffff000000002400: 01 00 00 f9  	str	x1, [x0]
;     *(base + 29) = currProc->registers.x29;
ffff000000002404: 00 02 00 d0  	adrp	x0, #270336
ffff000000002408: 00 40 07 91  	add	x0, x0, #464
ffff00000000240c: 01 00 40 f9  	ldr	x1, [x0]
ffff000000002410: e0 07 40 f9  	ldr	x0, [sp, #8]
ffff000000002414: 00 a0 03 91  	add	x0, x0, #232
ffff000000002418: 21 74 40 f9  	ldr	x1, [x1, #232]
ffff00000000241c: 01 00 00 f9  	str	x1, [x0]
;     *(base + 30) = currProc->registers.x30;
ffff000000002420: 00 02 00 d0  	adrp	x0, #270336
ffff000000002424: 00 40 07 91  	add	x0, x0, #464
ffff000000002428: 01 00 40 f9  	ldr	x1, [x0]
ffff00000000242c: e0 07 40 f9  	ldr	x0, [sp, #8]
ffff000000002430: 00 c0 03 91  	add	x0, x0, #240
ffff000000002434: 21 78 40 f9  	ldr	x1, [x1, #240]
ffff000000002438: 01 00 00 f9  	str	x1, [x0]
;     *(base + 31) = currProc->registers.exception_link_register;
ffff00000000243c: 00 02 00 d0  	adrp	x0, #270336
ffff000000002440: 00 40 07 91  	add	x0, x0, #464
ffff000000002444: 01 00 40 f9  	ldr	x1, [x0]
ffff000000002448: e0 07 40 f9  	ldr	x0, [sp, #8]
ffff00000000244c: 00 e0 03 91  	add	x0, x0, #248
ffff000000002450: 21 7c 40 f9  	ldr	x1, [x1, #248]
ffff000000002454: 01 00 00 f9  	str	x1, [x0]
;     *(base + 32) = currProc->registers.saved_program_status_register;
ffff000000002458: 00 02 00 d0  	adrp	x0, #270336
ffff00000000245c: 00 40 07 91  	add	x0, x0, #464
ffff000000002460: 01 00 40 f9  	ldr	x1, [x0]
ffff000000002464: e0 07 40 f9  	ldr	x0, [sp, #8]
ffff000000002468: 00 00 04 91  	add	x0, x0, #256
ffff00000000246c: 21 80 40 f9  	ldr	x1, [x1, #256]
ffff000000002470: 01 00 00 f9  	str	x1, [x0]
;     *(base + 33) = currProc->registers.stack_pointer;
ffff000000002474: 00 02 00 d0  	adrp	x0, #270336
ffff000000002478: 00 40 07 91  	add	x0, x0, #464
ffff00000000247c: 01 00 40 f9  	ldr	x1, [x0]
ffff000000002480: e0 07 40 f9  	ldr	x0, [sp, #8]
ffff000000002484: 00 20 04 91  	add	x0, x0, #264
ffff000000002488: 21 84 40 f9  	ldr	x1, [x1, #264]
ffff00000000248c: 01 00 00 f9  	str	x1, [x0]
; }
ffff000000002490: 1f 20 03 d5  	nop
ffff000000002494: ff 43 00 91  	add	sp, sp, #16
ffff000000002498: c0 03 5f d6  	ret

ffff00000000249c <schedule>:
; void schedule() {
ffff00000000249c: fd 7b be a9  	stp	x29, x30, [sp, #-32]!
ffff0000000024a0: fd 03 00 91  	mov	x29, sp
;     klog("Schedule has been called\n");
ffff0000000024a4: 00 00 00 d0  	adrp	x0, #8192
ffff0000000024a8: 00 20 2c 91  	add	x0, x0, #2824
ffff0000000024ac: 09 fd ff 97  	bl	0xffff0000000018d0 <klog>
;     schedule_dump_state();
ffff0000000024b0: 49 00 00 94  	bl	0xffff0000000025d4 <schedule_dump_state>
;     currProc->numSlicesUsed++;
ffff0000000024b4: 00 02 00 d0  	adrp	x0, #270336
ffff0000000024b8: 00 40 07 91  	add	x0, x0, #464
ffff0000000024bc: 00 00 40 f9  	ldr	x0, [x0]
ffff0000000024c0: 01 88 44 39  	ldrb	w1, [x0, #290]
ffff0000000024c4: 21 04 00 11  	add	w1, w1, #1
ffff0000000024c8: 21 1c 00 12  	and	w1, w1, #0xff
ffff0000000024cc: 01 88 04 39  	strb	w1, [x0, #290]
;     klog("The current running process (%d) has elapsed %d slices\n", currProc->pid, currProc->numSlicesUsed);
ffff0000000024d0: 00 02 00 d0  	adrp	x0, #270336
ffff0000000024d4: 00 40 07 91  	add	x0, x0, #464
ffff0000000024d8: 00 00 40 f9  	ldr	x0, [x0]
ffff0000000024dc: 01 10 41 b9  	ldr	w1, [x0, #272]
ffff0000000024e0: 00 02 00 d0  	adrp	x0, #270336
ffff0000000024e4: 00 40 07 91  	add	x0, x0, #464
ffff0000000024e8: 00 00 40 f9  	ldr	x0, [x0]
ffff0000000024ec: 00 88 44 39  	ldrb	w0, [x0, #290]
ffff0000000024f0: e2 03 00 2a  	mov	w2, w0
ffff0000000024f4: 00 00 00 d0  	adrp	x0, #8192
ffff0000000024f8: 00 a0 2c 91  	add	x0, x0, #2856
ffff0000000024fc: f5 fc ff 97  	bl	0xffff0000000018d0 <klog>
;     struct pcb_list *curr = runqueue;
ffff000000002500: 00 02 00 d0  	adrp	x0, #270336
ffff000000002504: 00 20 07 91  	add	x0, x0, #456
ffff000000002508: 00 00 40 f9  	ldr	x0, [x0]
ffff00000000250c: e0 0b 00 f9  	str	x0, [sp, #16]
;     if (numProcesses == 1) {
ffff000000002510: 00 02 00 d0  	adrp	x0, #270336
ffff000000002514: 00 60 07 91  	add	x0, x0, #472
ffff000000002518: 00 00 40 b9  	ldr	w0, [x0]
ffff00000000251c: 1f 04 00 71  	cmp	w0, #1
ffff000000002520: 40 05 00 54  	b.eq	0xffff0000000025c8 <schedule+0x12c>
;     runqueue = runqueue->next;
ffff000000002524: 00 02 00 d0  	adrp	x0, #270336
ffff000000002528: 00 20 07 91  	add	x0, x0, #456
ffff00000000252c: 00 00 40 f9  	ldr	x0, [x0]
ffff000000002530: 01 04 40 f9  	ldr	x1, [x0, #8]
ffff000000002534: 00 02 00 d0  	adrp	x0, #270336
ffff000000002538: 00 20 07 91  	add	x0, x0, #456
ffff00000000253c: 01 00 00 f9  	str	x1, [x0]
;     curr->next = 0x0;
ffff000000002540: e0 0b 40 f9  	ldr	x0, [sp, #16]
ffff000000002544: 1f 04 00 f9  	str	xzr, [x0, #8]
;     for (entry = runqueue; entry->next; entry = entry->next);
ffff000000002548: 00 02 00 d0  	adrp	x0, #270336
ffff00000000254c: 00 20 07 91  	add	x0, x0, #456
ffff000000002550: 00 00 40 f9  	ldr	x0, [x0]
ffff000000002554: e0 0f 00 f9  	str	x0, [sp, #24]
ffff000000002558: 04 00 00 14  	b	0xffff000000002568 <schedule+0xcc>
ffff00000000255c: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff000000002560: 00 04 40 f9  	ldr	x0, [x0, #8]
ffff000000002564: e0 0f 00 f9  	str	x0, [sp, #24]
ffff000000002568: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff00000000256c: 00 04 40 f9  	ldr	x0, [x0, #8]
ffff000000002570: 1f 00 00 f1  	cmp	x0, #0
ffff000000002574: 41 ff ff 54  	b.ne	0xffff00000000255c <schedule+0xc0>
;     entry->next = curr;
ffff000000002578: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff00000000257c: e1 0b 40 f9  	ldr	x1, [sp, #16]
ffff000000002580: 01 04 00 f9  	str	x1, [x0, #8]
;     currProc = runqueue->pcb;
ffff000000002584: 00 02 00 d0  	adrp	x0, #270336
ffff000000002588: 00 20 07 91  	add	x0, x0, #456
ffff00000000258c: 00 00 40 f9  	ldr	x0, [x0]
ffff000000002590: 01 00 40 f9  	ldr	x1, [x0]
ffff000000002594: 00 02 00 d0  	adrp	x0, #270336
ffff000000002598: 00 40 07 91  	add	x0, x0, #464
ffff00000000259c: 01 00 00 f9  	str	x1, [x0]
;     klog("The scheduler has decided to run process: %d\n", currProc->pid);
ffff0000000025a0: 00 02 00 d0  	adrp	x0, #270336
ffff0000000025a4: 00 40 07 91  	add	x0, x0, #464
ffff0000000025a8: 00 00 40 f9  	ldr	x0, [x0]
ffff0000000025ac: 00 10 41 b9  	ldr	w0, [x0, #272]
ffff0000000025b0: e1 03 00 2a  	mov	w1, w0
ffff0000000025b4: 00 00 00 d0  	adrp	x0, #8192
ffff0000000025b8: 00 80 2d 91  	add	x0, x0, #2912
ffff0000000025bc: c5 fc ff 97  	bl	0xffff0000000018d0 <klog>
;     do_switch_register_state();
ffff0000000025c0: c3 fe ff 97  	bl	0xffff0000000020cc <do_switch_register_state>
ffff0000000025c4: 02 00 00 14  	b	0xffff0000000025cc <schedule+0x130>
;         return;
ffff0000000025c8: 1f 20 03 d5  	nop
; }
ffff0000000025cc: fd 7b c2 a8  	ldp	x29, x30, [sp], #32
ffff0000000025d0: c0 03 5f d6  	ret

ffff0000000025d4 <schedule_dump_state>:
; void schedule_dump_state() {
ffff0000000025d4: fd 7b be a9  	stp	x29, x30, [sp, #-32]!
ffff0000000025d8: fd 03 00 91  	mov	x29, sp
;     klog("=========================SCHEDULER INFO=================\n");
ffff0000000025dc: 00 00 00 d0  	adrp	x0, #8192
ffff0000000025e0: 00 40 2e 91  	add	x0, x0, #2960
ffff0000000025e4: bb fc ff 97  	bl	0xffff0000000018d0 <klog>
;     klog("Current Proc Pid: %d\n", currProc->pid);
ffff0000000025e8: 00 02 00 d0  	adrp	x0, #270336
ffff0000000025ec: 00 40 07 91  	add	x0, x0, #464
ffff0000000025f0: 00 00 40 f9  	ldr	x0, [x0]
ffff0000000025f4: 00 10 41 b9  	ldr	w0, [x0, #272]
ffff0000000025f8: e1 03 00 2a  	mov	w1, w0
ffff0000000025fc: 00 00 00 d0  	adrp	x0, #8192
ffff000000002600: 00 40 2f 91  	add	x0, x0, #3024
ffff000000002604: b3 fc ff 97  	bl	0xffff0000000018d0 <klog>
;     klog("Run Queue: ");
ffff000000002608: 00 00 00 d0  	adrp	x0, #8192
ffff00000000260c: 00 a0 2f 91  	add	x0, x0, #3048
ffff000000002610: b0 fc ff 97  	bl	0xffff0000000018d0 <klog>
;     struct pcb_list *l = runqueue;
ffff000000002614: 00 02 00 d0  	adrp	x0, #270336
ffff000000002618: 00 20 07 91  	add	x0, x0, #456
ffff00000000261c: 00 00 40 f9  	ldr	x0, [x0]
ffff000000002620: e0 0f 00 f9  	str	x0, [sp, #24]
;     while (l) {
ffff000000002624: 11 00 00 14  	b	0xffff000000002668 <schedule_dump_state+0x94>
;         klog("%d", l->pcb->pid);
ffff000000002628: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff00000000262c: 00 00 40 f9  	ldr	x0, [x0]
ffff000000002630: 00 10 41 b9  	ldr	w0, [x0, #272]
ffff000000002634: e1 03 00 2a  	mov	w1, w0
ffff000000002638: 00 00 00 d0  	adrp	x0, #8192
ffff00000000263c: 00 e0 2f 91  	add	x0, x0, #3064
ffff000000002640: a4 fc ff 97  	bl	0xffff0000000018d0 <klog>
;         l = l->next;
ffff000000002644: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff000000002648: 00 04 40 f9  	ldr	x0, [x0, #8]
ffff00000000264c: e0 0f 00 f9  	str	x0, [sp, #24]
;         if (l) klog("->");
ffff000000002650: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff000000002654: 1f 00 00 f1  	cmp	x0, #0
ffff000000002658: 80 00 00 54  	b.eq	0xffff000000002668 <schedule_dump_state+0x94>
ffff00000000265c: 00 00 00 d0  	adrp	x0, #8192
ffff000000002660: 00 00 30 91  	add	x0, x0, #3072
ffff000000002664: 9b fc ff 97  	bl	0xffff0000000018d0 <klog>
;     while (l) {
ffff000000002668: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff00000000266c: 1f 00 00 f1  	cmp	x0, #0
ffff000000002670: c1 fd ff 54  	b.ne	0xffff000000002628 <schedule_dump_state+0x54>
;     klog("\n");
ffff000000002674: 00 00 00 d0  	adrp	x0, #8192
ffff000000002678: 00 20 30 91  	add	x0, x0, #3080
ffff00000000267c: 95 fc ff 97  	bl	0xffff0000000018d0 <klog>
;     l = runqueue;
ffff000000002680: 00 02 00 d0  	adrp	x0, #270336
ffff000000002684: 00 20 07 91  	add	x0, x0, #456
ffff000000002688: 00 00 40 f9  	ldr	x0, [x0]
ffff00000000268c: e0 0f 00 f9  	str	x0, [sp, #24]
;     while (l) {
ffff000000002690: 07 00 00 14  	b	0xffff0000000026ac <schedule_dump_state+0xd8>
;         print_pcb_state(l->pcb);
ffff000000002694: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff000000002698: 00 00 40 f9  	ldr	x0, [x0]
ffff00000000269c: 0d 00 00 94  	bl	0xffff0000000026d0 <print_pcb_state>
;         l = l->next;
ffff0000000026a0: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff0000000026a4: 00 04 40 f9  	ldr	x0, [x0, #8]
ffff0000000026a8: e0 0f 00 f9  	str	x0, [sp, #24]
;     while (l) {
ffff0000000026ac: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff0000000026b0: 1f 00 00 f1  	cmp	x0, #0
ffff0000000026b4: 01 ff ff 54  	b.ne	0xffff000000002694 <schedule_dump_state+0xc0>
;     klog("=========================SCHEDULER INFO=================\n");
ffff0000000026b8: 00 00 00 d0  	adrp	x0, #8192
ffff0000000026bc: 00 40 2e 91  	add	x0, x0, #2960
ffff0000000026c0: 84 fc ff 97  	bl	0xffff0000000018d0 <klog>
; }
ffff0000000026c4: 1f 20 03 d5  	nop
ffff0000000026c8: fd 7b c2 a8  	ldp	x29, x30, [sp], #32
ffff0000000026cc: c0 03 5f d6  	ret

ffff0000000026d0 <print_pcb_state>:
; void print_pcb_state(struct pcb *pcb) {
ffff0000000026d0: fd 7b be a9  	stp	x29, x30, [sp, #-32]!
ffff0000000026d4: fd 03 00 91  	mov	x29, sp
ffff0000000026d8: e0 0f 00 f9  	str	x0, [sp, #24]
;     klog("{\n\tPID=%d\n", pcb->pid);
ffff0000000026dc: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff0000000026e0: 00 10 41 b9  	ldr	w0, [x0, #272]
ffff0000000026e4: e1 03 00 2a  	mov	w1, w0
ffff0000000026e8: 00 00 00 d0  	adrp	x0, #8192
ffff0000000026ec: 00 40 30 91  	add	x0, x0, #3088
ffff0000000026f0: 78 fc ff 97  	bl	0xffff0000000018d0 <klog>
;     klog("\tStack Base=%p\n", pcb->stack);
ffff0000000026f4: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff0000000026f8: 00 8c 40 f9  	ldr	x0, [x0, #280]
ffff0000000026fc: e1 03 00 aa  	mov	x1, x0
ffff000000002700: 00 00 00 d0  	adrp	x0, #8192
ffff000000002704: 00 80 30 91  	add	x0, x0, #3104
ffff000000002708: 72 fc ff 97  	bl	0xffff0000000018d0 <klog>
;     klog("\tElapsed Time Slices=%d\n", pcb->numSlicesUsed);
ffff00000000270c: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff000000002710: 00 88 44 39  	ldrb	w0, [x0, #290]
ffff000000002714: e1 03 00 2a  	mov	w1, w0
ffff000000002718: 00 00 00 d0  	adrp	x0, #8192
ffff00000000271c: 00 c0 30 91  	add	x0, x0, #3120
ffff000000002720: 6c fc ff 97  	bl	0xffff0000000018d0 <klog>
;     klog("\tx0=%d\n", pcb->registers.x0);
ffff000000002724: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff000000002728: 00 00 40 f9  	ldr	x0, [x0]
ffff00000000272c: e1 03 00 aa  	mov	x1, x0
ffff000000002730: 00 00 00 d0  	adrp	x0, #8192
ffff000000002734: 00 40 31 91  	add	x0, x0, #3152
ffff000000002738: 66 fc ff 97  	bl	0xffff0000000018d0 <klog>
;     klog("\tx1=%d\n", pcb->registers.x1);
ffff00000000273c: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff000000002740: 00 04 40 f9  	ldr	x0, [x0, #8]
ffff000000002744: e1 03 00 aa  	mov	x1, x0
ffff000000002748: 00 00 00 d0  	adrp	x0, #8192
ffff00000000274c: 00 60 31 91  	add	x0, x0, #3160
ffff000000002750: 60 fc ff 97  	bl	0xffff0000000018d0 <klog>
;     klog("\tx2=%d\n", pcb->registers.x2);
ffff000000002754: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff000000002758: 00 08 40 f9  	ldr	x0, [x0, #16]
ffff00000000275c: e1 03 00 aa  	mov	x1, x0
ffff000000002760: 00 00 00 d0  	adrp	x0, #8192
ffff000000002764: 00 80 31 91  	add	x0, x0, #3168
ffff000000002768: 5a fc ff 97  	bl	0xffff0000000018d0 <klog>
;     klog("\tx3=%d\n", pcb->registers.x3);
ffff00000000276c: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff000000002770: 00 0c 40 f9  	ldr	x0, [x0, #24]
ffff000000002774: e1 03 00 aa  	mov	x1, x0
ffff000000002778: 00 00 00 d0  	adrp	x0, #8192
ffff00000000277c: 00 a0 31 91  	add	x0, x0, #3176
ffff000000002780: 54 fc ff 97  	bl	0xffff0000000018d0 <klog>
;     klog("\tx4=%d\n", pcb->registers.x4);
ffff000000002784: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff000000002788: 00 10 40 f9  	ldr	x0, [x0, #32]
ffff00000000278c: e1 03 00 aa  	mov	x1, x0
ffff000000002790: 00 00 00 d0  	adrp	x0, #8192
ffff000000002794: 00 c0 31 91  	add	x0, x0, #3184
ffff000000002798: 4e fc ff 97  	bl	0xffff0000000018d0 <klog>
;     klog("\tx5=%d\n", pcb->registers.x5);
ffff00000000279c: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff0000000027a0: 00 14 40 f9  	ldr	x0, [x0, #40]
ffff0000000027a4: e1 03 00 aa  	mov	x1, x0
ffff0000000027a8: 00 00 00 d0  	adrp	x0, #8192
ffff0000000027ac: 00 e0 31 91  	add	x0, x0, #3192
ffff0000000027b0: 48 fc ff 97  	bl	0xffff0000000018d0 <klog>
;     klog("\tx6=%d\n", pcb->registers.x6);
ffff0000000027b4: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff0000000027b8: 00 18 40 f9  	ldr	x0, [x0, #48]
ffff0000000027bc: e1 03 00 aa  	mov	x1, x0
ffff0000000027c0: 00 00 00 d0  	adrp	x0, #8192
ffff0000000027c4: 00 00 32 91  	add	x0, x0, #3200
ffff0000000027c8: 42 fc ff 97  	bl	0xffff0000000018d0 <klog>
;     klog("\tx7=%d\n", pcb->registers.x7);
ffff0000000027cc: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff0000000027d0: 00 1c 40 f9  	ldr	x0, [x0, #56]
ffff0000000027d4: e1 03 00 aa  	mov	x1, x0
ffff0000000027d8: 00 00 00 d0  	adrp	x0, #8192
ffff0000000027dc: 00 20 32 91  	add	x0, x0, #3208
ffff0000000027e0: 3c fc ff 97  	bl	0xffff0000000018d0 <klog>
;     klog("\tx8=%d\n", pcb->registers.x8);
ffff0000000027e4: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff0000000027e8: 00 20 40 f9  	ldr	x0, [x0, #64]
ffff0000000027ec: e1 03 00 aa  	mov	x1, x0
ffff0000000027f0: 00 00 00 d0  	adrp	x0, #8192
ffff0000000027f4: 00 40 32 91  	add	x0, x0, #3216
ffff0000000027f8: 36 fc ff 97  	bl	0xffff0000000018d0 <klog>
;     klog("\tx9=%d\n", pcb->registers.x9);
ffff0000000027fc: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff000000002800: 00 24 40 f9  	ldr	x0, [x0, #72]
ffff000000002804: e1 03 00 aa  	mov	x1, x0
ffff000000002808: 00 00 00 d0  	adrp	x0, #8192
ffff00000000280c: 00 60 32 91  	add	x0, x0, #3224
ffff000000002810: 30 fc ff 97  	bl	0xffff0000000018d0 <klog>
;     klog("\tx10=%d\n", pcb->registers.x10);
ffff000000002814: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff000000002818: 00 28 40 f9  	ldr	x0, [x0, #80]
ffff00000000281c: e1 03 00 aa  	mov	x1, x0
ffff000000002820: 00 00 00 d0  	adrp	x0, #8192
ffff000000002824: 00 80 32 91  	add	x0, x0, #3232
ffff000000002828: 2a fc ff 97  	bl	0xffff0000000018d0 <klog>
;     klog("\tx11=%d\n", pcb->registers.x11);
ffff00000000282c: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff000000002830: 00 2c 40 f9  	ldr	x0, [x0, #88]
ffff000000002834: e1 03 00 aa  	mov	x1, x0
ffff000000002838: 00 00 00 d0  	adrp	x0, #8192
ffff00000000283c: 00 c0 32 91  	add	x0, x0, #3248
ffff000000002840: 24 fc ff 97  	bl	0xffff0000000018d0 <klog>
;     klog("\tx12=%d\n", pcb->registers.x12);
ffff000000002844: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff000000002848: 00 30 40 f9  	ldr	x0, [x0, #96]
ffff00000000284c: e1 03 00 aa  	mov	x1, x0
ffff000000002850: 00 00 00 d0  	adrp	x0, #8192
ffff000000002854: 00 00 33 91  	add	x0, x0, #3264
ffff000000002858: 1e fc ff 97  	bl	0xffff0000000018d0 <klog>
;     klog("\tx13=%d\n", pcb->registers.x13);
ffff00000000285c: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff000000002860: 00 34 40 f9  	ldr	x0, [x0, #104]
ffff000000002864: e1 03 00 aa  	mov	x1, x0
ffff000000002868: 00 00 00 d0  	adrp	x0, #8192
ffff00000000286c: 00 40 33 91  	add	x0, x0, #3280
ffff000000002870: 18 fc ff 97  	bl	0xffff0000000018d0 <klog>
;     klog("\tx14=%d\n", pcb->registers.x14);
ffff000000002874: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff000000002878: 00 38 40 f9  	ldr	x0, [x0, #112]
ffff00000000287c: e1 03 00 aa  	mov	x1, x0
ffff000000002880: 00 00 00 d0  	adrp	x0, #8192
ffff000000002884: 00 80 33 91  	add	x0, x0, #3296
ffff000000002888: 12 fc ff 97  	bl	0xffff0000000018d0 <klog>
;     klog("\tx15=%d\n", pcb->registers.x15);
ffff00000000288c: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff000000002890: 00 3c 40 f9  	ldr	x0, [x0, #120]
ffff000000002894: e1 03 00 aa  	mov	x1, x0
ffff000000002898: 00 00 00 d0  	adrp	x0, #8192
ffff00000000289c: 00 c0 33 91  	add	x0, x0, #3312
ffff0000000028a0: 0c fc ff 97  	bl	0xffff0000000018d0 <klog>
;     klog("\tx16=%d\n", pcb->registers.x16);
ffff0000000028a4: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff0000000028a8: 00 40 40 f9  	ldr	x0, [x0, #128]
ffff0000000028ac: e1 03 00 aa  	mov	x1, x0
ffff0000000028b0: 00 00 00 d0  	adrp	x0, #8192
ffff0000000028b4: 00 00 34 91  	add	x0, x0, #3328
ffff0000000028b8: 06 fc ff 97  	bl	0xffff0000000018d0 <klog>
;     klog("\tx17=%d\n", pcb->registers.x17);
ffff0000000028bc: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff0000000028c0: 00 44 40 f9  	ldr	x0, [x0, #136]
ffff0000000028c4: e1 03 00 aa  	mov	x1, x0
ffff0000000028c8: 00 00 00 d0  	adrp	x0, #8192
ffff0000000028cc: 00 40 34 91  	add	x0, x0, #3344
ffff0000000028d0: 00 fc ff 97  	bl	0xffff0000000018d0 <klog>
;     klog("\tx18=%d\n", pcb->registers.x18);
ffff0000000028d4: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff0000000028d8: 00 48 40 f9  	ldr	x0, [x0, #144]
ffff0000000028dc: e1 03 00 aa  	mov	x1, x0
ffff0000000028e0: 00 00 00 d0  	adrp	x0, #8192
ffff0000000028e4: 00 80 34 91  	add	x0, x0, #3360
ffff0000000028e8: fa fb ff 97  	bl	0xffff0000000018d0 <klog>
;     klog("\tx19=%d\n", pcb->registers.x19);
ffff0000000028ec: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff0000000028f0: 00 4c 40 f9  	ldr	x0, [x0, #152]
ffff0000000028f4: e1 03 00 aa  	mov	x1, x0
ffff0000000028f8: 00 00 00 d0  	adrp	x0, #8192
ffff0000000028fc: 00 c0 34 91  	add	x0, x0, #3376
ffff000000002900: f4 fb ff 97  	bl	0xffff0000000018d0 <klog>
;     klog("\tx20=%d\n", pcb->registers.x20);
ffff000000002904: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff000000002908: 00 50 40 f9  	ldr	x0, [x0, #160]
ffff00000000290c: e1 03 00 aa  	mov	x1, x0
ffff000000002910: 00 00 00 d0  	adrp	x0, #8192
ffff000000002914: 00 00 35 91  	add	x0, x0, #3392
ffff000000002918: ee fb ff 97  	bl	0xffff0000000018d0 <klog>
;     klog("\tx21=%d\n", pcb->registers.x21);
ffff00000000291c: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff000000002920: 00 54 40 f9  	ldr	x0, [x0, #168]
ffff000000002924: e1 03 00 aa  	mov	x1, x0
ffff000000002928: 00 00 00 d0  	adrp	x0, #8192
ffff00000000292c: 00 40 35 91  	add	x0, x0, #3408
ffff000000002930: e8 fb ff 97  	bl	0xffff0000000018d0 <klog>
;     klog("\tx22=%d\n", pcb->registers.x22);
ffff000000002934: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff000000002938: 00 58 40 f9  	ldr	x0, [x0, #176]
ffff00000000293c: e1 03 00 aa  	mov	x1, x0
ffff000000002940: 00 00 00 d0  	adrp	x0, #8192
ffff000000002944: 00 80 35 91  	add	x0, x0, #3424
ffff000000002948: e2 fb ff 97  	bl	0xffff0000000018d0 <klog>
;     klog("\tx23=%d\n", pcb->registers.x23);
ffff00000000294c: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff000000002950: 00 5c 40 f9  	ldr	x0, [x0, #184]
ffff000000002954: e1 03 00 aa  	mov	x1, x0
ffff000000002958: 00 00 00 d0  	adrp	x0, #8192
ffff00000000295c: 00 c0 35 91  	add	x0, x0, #3440
ffff000000002960: dc fb ff 97  	bl	0xffff0000000018d0 <klog>
;     klog("\tx24=%d\n", pcb->registers.x24);
ffff000000002964: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff000000002968: 00 60 40 f9  	ldr	x0, [x0, #192]
ffff00000000296c: e1 03 00 aa  	mov	x1, x0
ffff000000002970: 00 00 00 d0  	adrp	x0, #8192
ffff000000002974: 00 00 36 91  	add	x0, x0, #3456
ffff000000002978: d6 fb ff 97  	bl	0xffff0000000018d0 <klog>
;     klog("\tx25=%d\n", pcb->registers.x25);
ffff00000000297c: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff000000002980: 00 64 40 f9  	ldr	x0, [x0, #200]
ffff000000002984: e1 03 00 aa  	mov	x1, x0
ffff000000002988: 00 00 00 d0  	adrp	x0, #8192
ffff00000000298c: 00 40 36 91  	add	x0, x0, #3472
ffff000000002990: d0 fb ff 97  	bl	0xffff0000000018d0 <klog>
;     klog("\tx26=%d\n", pcb->registers.x26);
ffff000000002994: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff000000002998: 00 68 40 f9  	ldr	x0, [x0, #208]
ffff00000000299c: e1 03 00 aa  	mov	x1, x0
ffff0000000029a0: 00 00 00 d0  	adrp	x0, #8192
ffff0000000029a4: 00 80 36 91  	add	x0, x0, #3488
ffff0000000029a8: ca fb ff 97  	bl	0xffff0000000018d0 <klog>
;     klog("\tx27=%d\n", pcb->registers.x27);
ffff0000000029ac: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff0000000029b0: 00 6c 40 f9  	ldr	x0, [x0, #216]
ffff0000000029b4: e1 03 00 aa  	mov	x1, x0
ffff0000000029b8: 00 00 00 d0  	adrp	x0, #8192
ffff0000000029bc: 00 c0 36 91  	add	x0, x0, #3504
ffff0000000029c0: c4 fb ff 97  	bl	0xffff0000000018d0 <klog>
;     klog("\tx28=%d\n", pcb->registers.x28);
ffff0000000029c4: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff0000000029c8: 00 70 40 f9  	ldr	x0, [x0, #224]
ffff0000000029cc: e1 03 00 aa  	mov	x1, x0
ffff0000000029d0: 00 00 00 d0  	adrp	x0, #8192
ffff0000000029d4: 00 00 37 91  	add	x0, x0, #3520
ffff0000000029d8: be fb ff 97  	bl	0xffff0000000018d0 <klog>
;     klog("\tx29=%d\n", pcb->registers.x29);
ffff0000000029dc: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff0000000029e0: 00 74 40 f9  	ldr	x0, [x0, #232]
ffff0000000029e4: e1 03 00 aa  	mov	x1, x0
ffff0000000029e8: 00 00 00 d0  	adrp	x0, #8192
ffff0000000029ec: 00 40 37 91  	add	x0, x0, #3536
ffff0000000029f0: b8 fb ff 97  	bl	0xffff0000000018d0 <klog>
;     klog("\tx30=%d\n", pcb->registers.x30);
ffff0000000029f4: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff0000000029f8: 00 78 40 f9  	ldr	x0, [x0, #240]
ffff0000000029fc: e1 03 00 aa  	mov	x1, x0
ffff000000002a00: 00 00 00 d0  	adrp	x0, #8192
ffff000000002a04: 00 80 37 91  	add	x0, x0, #3552
ffff000000002a08: b2 fb ff 97  	bl	0xffff0000000018d0 <klog>
;     klog("\tException Link Register=%d\n", pcb->registers.exception_link_register);
ffff000000002a0c: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff000000002a10: 00 7c 40 f9  	ldr	x0, [x0, #248]
ffff000000002a14: e1 03 00 aa  	mov	x1, x0
ffff000000002a18: 00 00 00 d0  	adrp	x0, #8192
ffff000000002a1c: 00 c0 37 91  	add	x0, x0, #3568
ffff000000002a20: ac fb ff 97  	bl	0xffff0000000018d0 <klog>
;     klog("\tSaved Program Status Register=%d\n", pcb->registers.saved_program_status_register);
ffff000000002a24: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff000000002a28: 00 80 40 f9  	ldr	x0, [x0, #256]
ffff000000002a2c: e1 03 00 aa  	mov	x1, x0
ffff000000002a30: 00 00 00 d0  	adrp	x0, #8192
ffff000000002a34: 00 40 38 91  	add	x0, x0, #3600
ffff000000002a38: a6 fb ff 97  	bl	0xffff0000000018d0 <klog>
;     klog("\tStack Pointer=%d\n", pcb->registers.stack_pointer);
ffff000000002a3c: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff000000002a40: 00 84 40 f9  	ldr	x0, [x0, #264]
ffff000000002a44: e1 03 00 aa  	mov	x1, x0
ffff000000002a48: 00 00 00 d0  	adrp	x0, #8192
ffff000000002a4c: 00 e0 38 91  	add	x0, x0, #3640
ffff000000002a50: a0 fb ff 97  	bl	0xffff0000000018d0 <klog>
;     klog("}\n");
ffff000000002a54: 00 00 00 d0  	adrp	x0, #8192
ffff000000002a58: 00 40 39 91  	add	x0, x0, #3664
ffff000000002a5c: 9d fb ff 97  	bl	0xffff0000000018d0 <klog>
; }
ffff000000002a60: 1f 20 03 d5  	nop
ffff000000002a64: fd 7b c2 a8  	ldp	x29, x30, [sp], #32
ffff000000002a68: c0 03 5f d6  	ret

ffff000000002a6c <new_thread>:
; int new_thread(void *function, void* arg, bool isKernel) {
ffff000000002a6c: fd 7b bb a9  	stp	x29, x30, [sp, #-80]!
ffff000000002a70: fd 03 00 91  	mov	x29, sp
ffff000000002a74: e0 17 00 f9  	str	x0, [sp, #40]
ffff000000002a78: e1 13 00 f9  	str	x1, [sp, #32]
ffff000000002a7c: e2 7f 00 39  	strb	w2, [sp, #31]
;     klog("A request to create a new %s thread has been made\n", (isKernel ? "Kernel" : "User"));
ffff000000002a80: e0 7f 40 39  	ldrb	w0, [sp, #31]
ffff000000002a84: 1f 00 00 71  	cmp	w0, #0
ffff000000002a88: 80 00 00 54  	b.eq	0xffff000000002a98 <new_thread+0x2c>
ffff000000002a8c: 00 00 00 d0  	adrp	x0, #8192
ffff000000002a90: 00 60 39 91  	add	x0, x0, #3672
ffff000000002a94: 03 00 00 14  	b	0xffff000000002aa0 <new_thread+0x34>
ffff000000002a98: 00 00 00 d0  	adrp	x0, #8192
ffff000000002a9c: 00 80 39 91  	add	x0, x0, #3680
ffff000000002aa0: e1 03 00 aa  	mov	x1, x0
ffff000000002aa4: 00 00 00 d0  	adrp	x0, #8192
ffff000000002aa8: 00 a0 39 91  	add	x0, x0, #3688
ffff000000002aac: 89 fb ff 97  	bl	0xffff0000000018d0 <klog>
;     void *stack = alloc_page();
ffff000000002ab0: f3 fc ff 97  	bl	0xffff000000001e7c <alloc_page>
ffff000000002ab4: e0 23 00 f9  	str	x0, [sp, #64]
;     struct pcb *pcb = alloc_pcb();
ffff000000002ab8: 48 fd ff 97  	bl	0xffff000000001fd8 <alloc_pcb>
ffff000000002abc: e0 1f 00 f9  	str	x0, [sp, #56]
;     pcb->pid = getNextPID();
ffff000000002ac0: 55 fd ff 97  	bl	0xffff000000002014 <getNextPID>
ffff000000002ac4: e1 03 00 2a  	mov	w1, w0
ffff000000002ac8: e0 1f 40 f9  	ldr	x0, [sp, #56]
ffff000000002acc: 01 10 01 b9  	str	w1, [x0, #272]
;     pcb->stack = stack;
ffff000000002ad0: e0 1f 40 f9  	ldr	x0, [sp, #56]
ffff000000002ad4: e1 23 40 f9  	ldr	x1, [sp, #64]
ffff000000002ad8: 01 8c 00 f9  	str	x1, [x0, #280]
;     pcb->priority = currProc->priority;
ffff000000002adc: 00 02 00 d0  	adrp	x0, #270336
ffff000000002ae0: 00 40 07 91  	add	x0, x0, #464
ffff000000002ae4: 00 00 40 f9  	ldr	x0, [x0]
ffff000000002ae8: 01 84 44 39  	ldrb	w1, [x0, #289]
ffff000000002aec: e0 1f 40 f9  	ldr	x0, [sp, #56]
ffff000000002af0: 01 84 04 39  	strb	w1, [x0, #289]
;     pcb->numSlicesUsed = 0;
ffff000000002af4: e0 1f 40 f9  	ldr	x0, [sp, #56]
ffff000000002af8: 1f 88 04 39  	strb	wzr, [x0, #290]
;     pcb->state = STATE_READY;
ffff000000002afc: e0 1f 40 f9  	ldr	x0, [sp, #56]
ffff000000002b00: 41 00 80 52  	mov	w1, #2
ffff000000002b04: 01 80 04 39  	strb	w1, [x0, #288]
;     pcb->registers.stack_pointer = (long) stack + PAGE_SIZE;
ffff000000002b08: e0 23 40 f9  	ldr	x0, [sp, #64]
ffff000000002b0c: 01 04 40 91  	add	x1, x0, #1, lsl #12
ffff000000002b10: e0 1f 40 f9  	ldr	x0, [sp, #56]
ffff000000002b14: 01 84 00 f9  	str	x1, [x0, #264]
;     pcb->registers.x30 = (long) function;
ffff000000002b18: e1 17 40 f9  	ldr	x1, [sp, #40]
ffff000000002b1c: e0 1f 40 f9  	ldr	x0, [sp, #56]
ffff000000002b20: 01 78 00 f9  	str	x1, [x0, #240]
;     pcb->registers.x0 = (long int) arg;
ffff000000002b24: e1 13 40 f9  	ldr	x1, [sp, #32]
ffff000000002b28: e0 1f 40 f9  	ldr	x0, [sp, #56]
ffff000000002b2c: 01 00 00 f9  	str	x1, [x0]
;     pcb->registers.exception_link_register = (long) function;
ffff000000002b30: e1 17 40 f9  	ldr	x1, [sp, #40]
ffff000000002b34: e0 1f 40 f9  	ldr	x0, [sp, #56]
ffff000000002b38: 01 7c 00 f9  	str	x1, [x0, #248]
;     pcb->registers.saved_program_status_register = DISABLE_FIQ | (isKernel ? RETURN_TO_EL1 : RETURN_TO_EL0);
ffff000000002b3c: e0 7f 40 39  	ldrb	w0, [sp, #31]
ffff000000002b40: 1f 00 00 71  	cmp	w0, #0
ffff000000002b44: 60 00 00 54  	b.eq	0xffff000000002b50 <new_thread+0xe4>
ffff000000002b48: a0 08 80 d2  	mov	x0, #69
ffff000000002b4c: 02 00 00 14  	b	0xffff000000002b54 <new_thread+0xe8>
ffff000000002b50: 00 08 80 d2  	mov	x0, #64
ffff000000002b54: e1 1f 40 f9  	ldr	x1, [sp, #56]
ffff000000002b58: 20 80 00 f9  	str	x0, [x1, #256]
;     struct pcb_list *node = alloc_listNode();
ffff000000002b5c: 10 fd ff 97  	bl	0xffff000000001f9c <alloc_listNode>
ffff000000002b60: e0 1b 00 f9  	str	x0, [sp, #48]
;     node->pcb = pcb;
ffff000000002b64: e0 1b 40 f9  	ldr	x0, [sp, #48]
ffff000000002b68: e1 1f 40 f9  	ldr	x1, [sp, #56]
ffff000000002b6c: 01 00 00 f9  	str	x1, [x0]
;     struct pcb_list *traversal_curr = runqueue;
ffff000000002b70: 00 02 00 d0  	adrp	x0, #270336
ffff000000002b74: 00 20 07 91  	add	x0, x0, #456
ffff000000002b78: 00 00 40 f9  	ldr	x0, [x0]
ffff000000002b7c: e0 27 00 f9  	str	x0, [sp, #72]
;     while (traversal_curr->next) {
ffff000000002b80: 04 00 00 14  	b	0xffff000000002b90 <new_thread+0x124>
;         traversal_curr = traversal_curr->next;
ffff000000002b84: e0 27 40 f9  	ldr	x0, [sp, #72]
ffff000000002b88: 00 04 40 f9  	ldr	x0, [x0, #8]
ffff000000002b8c: e0 27 00 f9  	str	x0, [sp, #72]
;     while (traversal_curr->next) {
ffff000000002b90: e0 27 40 f9  	ldr	x0, [sp, #72]
ffff000000002b94: 00 04 40 f9  	ldr	x0, [x0, #8]
ffff000000002b98: 1f 00 00 f1  	cmp	x0, #0
ffff000000002b9c: 41 ff ff 54  	b.ne	0xffff000000002b84 <new_thread+0x118>
;     traversal_curr->next = node;
ffff000000002ba0: e0 27 40 f9  	ldr	x0, [sp, #72]
ffff000000002ba4: e1 1b 40 f9  	ldr	x1, [sp, #48]
ffff000000002ba8: 01 04 00 f9  	str	x1, [x0, #8]
;     node->next = 0x0;
ffff000000002bac: e0 1b 40 f9  	ldr	x0, [sp, #48]
ffff000000002bb0: 1f 04 00 f9  	str	xzr, [x0, #8]
;     klog("New thread has been created and added to PCB list with pid=%d\n", pcb->pid);
ffff000000002bb4: e0 1f 40 f9  	ldr	x0, [sp, #56]
ffff000000002bb8: 00 10 41 b9  	ldr	w0, [x0, #272]
ffff000000002bbc: e1 03 00 2a  	mov	w1, w0
ffff000000002bc0: 00 00 00 d0  	adrp	x0, #8192
ffff000000002bc4: 00 80 3a 91  	add	x0, x0, #3744
ffff000000002bc8: 42 fb ff 97  	bl	0xffff0000000018d0 <klog>
;     print_pcb_state(pcb);
ffff000000002bcc: e0 1f 40 f9  	ldr	x0, [sp, #56]
ffff000000002bd0: c0 fe ff 97  	bl	0xffff0000000026d0 <print_pcb_state>
;     return pcb->pid;
ffff000000002bd4: e0 1f 40 f9  	ldr	x0, [sp, #56]
ffff000000002bd8: 00 10 41 b9  	ldr	w0, [x0, #272]
; }
ffff000000002bdc: fd 7b c5 a8  	ldp	x29, x30, [sp], #80
ffff000000002be0: c0 03 5f d6  	ret

ffff000000002be4 <new_user_thread>:
; int new_user_thread(void *function, void *arg) {
ffff000000002be4: fd 7b be a9  	stp	x29, x30, [sp, #-32]!
ffff000000002be8: fd 03 00 91  	mov	x29, sp
ffff000000002bec: e0 0f 00 f9  	str	x0, [sp, #24]
ffff000000002bf0: e1 0b 00 f9  	str	x1, [sp, #16]
;     return new_thread(function, arg, false);
ffff000000002bf4: 02 00 80 52  	mov	w2, #0
ffff000000002bf8: e1 0b 40 f9  	ldr	x1, [sp, #16]
ffff000000002bfc: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff000000002c00: 9b ff ff 97  	bl	0xffff000000002a6c <new_thread>
; }
ffff000000002c04: fd 7b c2 a8  	ldp	x29, x30, [sp], #32
ffff000000002c08: c0 03 5f d6  	ret

ffff000000002c0c <new_kernel_thread>:
; int new_kernel_thread(void *function, void *arg) {
ffff000000002c0c: fd 7b be a9  	stp	x29, x30, [sp, #-32]!
ffff000000002c10: fd 03 00 91  	mov	x29, sp
ffff000000002c14: e0 0f 00 f9  	str	x0, [sp, #24]
ffff000000002c18: e1 0b 00 f9  	str	x1, [sp, #16]
;     return new_thread(function, arg, true);
ffff000000002c1c: 22 00 80 52  	mov	w2, #1
ffff000000002c20: e1 0b 40 f9  	ldr	x1, [sp, #16]
ffff000000002c24: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff000000002c28: 91 ff ff 97  	bl	0xffff000000002a6c <new_thread>
; }
ffff000000002c2c: fd 7b c2 a8  	ldp	x29, x30, [sp], #32
ffff000000002c30: c0 03 5f d6  	ret

ffff000000002c34 <init_spinlock>:
; void init_spinlock(struct spinlock *lock) {
ffff000000002c34: ff 43 00 d1  	sub	sp, sp, #16
ffff000000002c38: e0 07 00 f9  	str	x0, [sp, #8]
;     lock->lockVal = 0;
ffff000000002c3c: e0 07 40 f9  	ldr	x0, [sp, #8]
ffff000000002c40: 1f 00 00 f9  	str	xzr, [x0]
; }
ffff000000002c44: 1f 20 03 d5  	nop
ffff000000002c48: ff 43 00 91  	add	sp, sp, #16
ffff000000002c4c: c0 03 5f d6  	ret

ffff000000002c50 <lock_spinlock>:
; void lock_spinlock(struct spinlock *lock) {
ffff000000002c50: fd 7b be a9  	stp	x29, x30, [sp, #-32]!
ffff000000002c54: fd 03 00 91  	mov	x29, sp
ffff000000002c58: e0 0f 00 f9  	str	x0, [sp, #24]
;     while (atomic_decrement(&lock->lockVal) != 0) {
ffff000000002c5c: 06 00 00 14  	b	0xffff000000002c74 <lock_spinlock+0x24>
;             __asm__("wfe");
ffff000000002c60: 5f 20 03 d5  	wfe
;         } while (lock->lockVal <= 0);
ffff000000002c64: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff000000002c68: 00 00 40 f9  	ldr	x0, [x0]
ffff000000002c6c: 1f 00 00 f1  	cmp	x0, #0
ffff000000002c70: 8d ff ff 54  	b.le	0xffff000000002c60 <lock_spinlock+0x10>
;     while (atomic_decrement(&lock->lockVal) != 0) {
ffff000000002c74: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff000000002c78: a1 05 00 94  	bl	0xffff0000000042fc <atomic_decrement>
ffff000000002c7c: 1f 00 00 f1  	cmp	x0, #0
ffff000000002c80: 01 ff ff 54  	b.ne	0xffff000000002c60 <lock_spinlock+0x10>
; }
ffff000000002c84: 1f 20 03 d5  	nop
ffff000000002c88: 1f 20 03 d5  	nop
ffff000000002c8c: fd 7b c2 a8  	ldp	x29, x30, [sp], #32
ffff000000002c90: c0 03 5f d6  	ret

ffff000000002c94 <unlock_spinlock>:
; void unlock_spinlock(struct spinlock *lock) {
ffff000000002c94: ff 43 00 d1  	sub	sp, sp, #16
ffff000000002c98: e0 07 00 f9  	str	x0, [sp, #8]
;     lock->lockVal = 1;
ffff000000002c9c: e0 07 40 f9  	ldr	x0, [sp, #8]
ffff000000002ca0: 21 00 80 d2  	mov	x1, #1
ffff000000002ca4: 01 00 00 f9  	str	x1, [x0]
; }
ffff000000002ca8: 1f 20 03 d5  	nop
ffff000000002cac: ff 43 00 91  	add	sp, sp, #16
ffff000000002cb0: c0 03 5f d6  	ret

ffff000000002cb4 <init_timer>:
; void init_timer() {
ffff000000002cb4: fd 7b be a9  	stp	x29, x30, [sp, #-32]!
ffff000000002cb8: fd 03 00 91  	mov	x29, sp
;     int firstInterruptTime = get32(TIMER_CLO) + init_interval;
ffff000000002cbc: 80 00 86 d2  	mov	x0, #12292
ffff000000002cc0: 00 e0 a7 f2  	movk	x0, #16128, lsl #16
ffff000000002cc4: 9a 05 00 94  	bl	0xffff00000000432c <get32>
ffff000000002cc8: e1 03 00 2a  	mov	w1, w0
ffff000000002ccc: 00 24 94 52  	mov	w0, #41248
ffff000000002cd0: e0 00 a0 72  	movk	w0, #7, lsl #16
ffff000000002cd4: 20 00 00 0b  	add	w0, w1, w0
ffff000000002cd8: e0 1f 00 b9  	str	w0, [sp, #28]
;     klog("Expect Next Timer Interrupt at: %d\n", firstInterruptTime);
ffff000000002cdc: e1 1f 40 b9  	ldr	w1, [sp, #28]
ffff000000002ce0: 00 00 00 d0  	adrp	x0, #8192
ffff000000002ce4: 00 a0 3b 91  	add	x0, x0, #3816
ffff000000002ce8: fa fa ff 97  	bl	0xffff0000000018d0 <klog>
;     put32(TIMER_C1, firstInterruptTime); 
ffff000000002cec: e0 1f 40 b9  	ldr	w0, [sp, #28]
ffff000000002cf0: e1 03 00 2a  	mov	w1, w0
ffff000000002cf4: 00 02 86 d2  	mov	x0, #12304
ffff000000002cf8: 00 e0 a7 f2  	movk	x0, #16128, lsl #16
ffff000000002cfc: 8e 05 00 94  	bl	0xffff000000004334 <put32>
; }
ffff000000002d00: 1f 20 03 d5  	nop
ffff000000002d04: fd 7b c2 a8  	ldp	x29, x30, [sp], #32
ffff000000002d08: c0 03 5f d6  	ret

ffff000000002d0c <handle_timer_irq>:
; void handle_timer_irq() {
ffff000000002d0c: fd 7b be a9  	stp	x29, x30, [sp, #-32]!
ffff000000002d10: fd 03 00 91  	mov	x29, sp
;     put32(TIMER_CS, PRIMARY_TIMER_IRQ); 
ffff000000002d14: 41 00 80 52  	mov	w1, #2
ffff000000002d18: 00 00 86 d2  	mov	x0, #12288
ffff000000002d1c: 00 e0 a7 f2  	movk	x0, #16128, lsl #16
ffff000000002d20: 85 05 00 94  	bl	0xffff000000004334 <put32>
;     klog("======REGISTER STATE OF CURRENTLY INTERRUPTED PROCESS=======\n{");
ffff000000002d24: 00 00 00 d0  	adrp	x0, #8192
ffff000000002d28: 00 40 3c 91  	add	x0, x0, #3856
ffff000000002d2c: e9 fa ff 97  	bl	0xffff0000000018d0 <klog>
;     long * base = (long *) 4210688;
ffff000000002d30: 00 00 88 d2  	mov	x0, #16384
ffff000000002d34: 00 08 a0 f2  	movk	x0, #64, lsl #16
ffff000000002d38: e0 0b 00 f9  	str	x0, [sp, #16]
;     for (int i = 0; i <= 30; ++i)
ffff000000002d3c: ff 1f 00 b9  	str	wzr, [sp, #28]
ffff000000002d40: 0e 00 00 14  	b	0xffff000000002d78 <handle_timer_irq+0x6c>
;         klog("\t[x%d=%d]\n", i, *(base + i));
ffff000000002d44: e0 1f 80 b9  	ldrsw	x0, [sp, #28]
ffff000000002d48: 00 f0 7d d3  	lsl	x0, x0, #3
ffff000000002d4c: e1 0b 40 f9  	ldr	x1, [sp, #16]
ffff000000002d50: 20 00 00 8b  	add	x0, x1, x0
ffff000000002d54: 00 00 40 f9  	ldr	x0, [x0]
ffff000000002d58: e2 03 00 aa  	mov	x2, x0
ffff000000002d5c: e1 1f 40 b9  	ldr	w1, [sp, #28]
ffff000000002d60: 00 00 00 d0  	adrp	x0, #8192
ffff000000002d64: 00 40 3d 91  	add	x0, x0, #3920
ffff000000002d68: da fa ff 97  	bl	0xffff0000000018d0 <klog>
;     for (int i = 0; i <= 30; ++i)
ffff000000002d6c: e0 1f 40 b9  	ldr	w0, [sp, #28]
ffff000000002d70: 00 04 00 11  	add	w0, w0, #1
ffff000000002d74: e0 1f 00 b9  	str	w0, [sp, #28]
ffff000000002d78: e0 1f 40 b9  	ldr	w0, [sp, #28]
ffff000000002d7c: 1f 78 00 71  	cmp	w0, #30
ffff000000002d80: 2d fe ff 54  	b.le	0xffff000000002d44 <handle_timer_irq+0x38>
;     klog("}\n======REGISTER STATE OF CURRENTLY INTERRUPTED PROCESS=======\n");
ffff000000002d84: 00 00 00 d0  	adrp	x0, #8192
ffff000000002d88: 00 80 3d 91  	add	x0, x0, #3936
ffff000000002d8c: d1 fa ff 97  	bl	0xffff0000000018d0 <klog>
;     currProc->registers.x0 = *(base + 0);
ffff000000002d90: 00 02 00 d0  	adrp	x0, #270336
ffff000000002d94: 00 40 07 91  	add	x0, x0, #464
ffff000000002d98: 00 00 40 f9  	ldr	x0, [x0]
ffff000000002d9c: e1 0b 40 f9  	ldr	x1, [sp, #16]
ffff000000002da0: 21 00 40 f9  	ldr	x1, [x1]
ffff000000002da4: 01 00 00 f9  	str	x1, [x0]
;     currProc->registers.x1 = *(base + 1); 
ffff000000002da8: 00 02 00 d0  	adrp	x0, #270336
ffff000000002dac: 00 40 07 91  	add	x0, x0, #464
ffff000000002db0: 00 00 40 f9  	ldr	x0, [x0]
ffff000000002db4: e1 0b 40 f9  	ldr	x1, [sp, #16]
ffff000000002db8: 21 04 40 f9  	ldr	x1, [x1, #8]
ffff000000002dbc: 01 04 00 f9  	str	x1, [x0, #8]
;     currProc->registers.x2 = *(base + 2);
ffff000000002dc0: 00 02 00 d0  	adrp	x0, #270336
ffff000000002dc4: 00 40 07 91  	add	x0, x0, #464
ffff000000002dc8: 00 00 40 f9  	ldr	x0, [x0]
ffff000000002dcc: e1 0b 40 f9  	ldr	x1, [sp, #16]
ffff000000002dd0: 21 08 40 f9  	ldr	x1, [x1, #16]
ffff000000002dd4: 01 08 00 f9  	str	x1, [x0, #16]
;     currProc->registers.x3 = *(base + 3);
ffff000000002dd8: 00 02 00 d0  	adrp	x0, #270336
ffff000000002ddc: 00 40 07 91  	add	x0, x0, #464
ffff000000002de0: 00 00 40 f9  	ldr	x0, [x0]
ffff000000002de4: e1 0b 40 f9  	ldr	x1, [sp, #16]
ffff000000002de8: 21 0c 40 f9  	ldr	x1, [x1, #24]
ffff000000002dec: 01 0c 00 f9  	str	x1, [x0, #24]
;     currProc->registers.x4 = *(base + 4);
ffff000000002df0: 00 02 00 d0  	adrp	x0, #270336
ffff000000002df4: 00 40 07 91  	add	x0, x0, #464
ffff000000002df8: 00 00 40 f9  	ldr	x0, [x0]
ffff000000002dfc: e1 0b 40 f9  	ldr	x1, [sp, #16]
ffff000000002e00: 21 10 40 f9  	ldr	x1, [x1, #32]
ffff000000002e04: 01 10 00 f9  	str	x1, [x0, #32]
;     currProc->registers.x5 = *(base + 5);
ffff000000002e08: 00 02 00 d0  	adrp	x0, #270336
ffff000000002e0c: 00 40 07 91  	add	x0, x0, #464
ffff000000002e10: 00 00 40 f9  	ldr	x0, [x0]
ffff000000002e14: e1 0b 40 f9  	ldr	x1, [sp, #16]
ffff000000002e18: 21 14 40 f9  	ldr	x1, [x1, #40]
ffff000000002e1c: 01 14 00 f9  	str	x1, [x0, #40]
;     currProc->registers.x6 = *(base + 6);
ffff000000002e20: 00 02 00 d0  	adrp	x0, #270336
ffff000000002e24: 00 40 07 91  	add	x0, x0, #464
ffff000000002e28: 00 00 40 f9  	ldr	x0, [x0]
ffff000000002e2c: e1 0b 40 f9  	ldr	x1, [sp, #16]
ffff000000002e30: 21 18 40 f9  	ldr	x1, [x1, #48]
ffff000000002e34: 01 18 00 f9  	str	x1, [x0, #48]
;     currProc->registers.x7 = *(base + 7);
ffff000000002e38: 00 02 00 d0  	adrp	x0, #270336
ffff000000002e3c: 00 40 07 91  	add	x0, x0, #464
ffff000000002e40: 00 00 40 f9  	ldr	x0, [x0]
ffff000000002e44: e1 0b 40 f9  	ldr	x1, [sp, #16]
ffff000000002e48: 21 1c 40 f9  	ldr	x1, [x1, #56]
ffff000000002e4c: 01 1c 00 f9  	str	x1, [x0, #56]
;     currProc->registers.x8 = *(base + 8);
ffff000000002e50: 00 02 00 d0  	adrp	x0, #270336
ffff000000002e54: 00 40 07 91  	add	x0, x0, #464
ffff000000002e58: 00 00 40 f9  	ldr	x0, [x0]
ffff000000002e5c: e1 0b 40 f9  	ldr	x1, [sp, #16]
ffff000000002e60: 21 20 40 f9  	ldr	x1, [x1, #64]
ffff000000002e64: 01 20 00 f9  	str	x1, [x0, #64]
;     currProc->registers.x9 = *(base + 9);
ffff000000002e68: 00 02 00 d0  	adrp	x0, #270336
ffff000000002e6c: 00 40 07 91  	add	x0, x0, #464
ffff000000002e70: 00 00 40 f9  	ldr	x0, [x0]
ffff000000002e74: e1 0b 40 f9  	ldr	x1, [sp, #16]
ffff000000002e78: 21 24 40 f9  	ldr	x1, [x1, #72]
ffff000000002e7c: 01 24 00 f9  	str	x1, [x0, #72]
;     currProc->registers.x10 = *(base + 10);
ffff000000002e80: 00 02 00 d0  	adrp	x0, #270336
ffff000000002e84: 00 40 07 91  	add	x0, x0, #464
ffff000000002e88: 00 00 40 f9  	ldr	x0, [x0]
ffff000000002e8c: e1 0b 40 f9  	ldr	x1, [sp, #16]
ffff000000002e90: 21 28 40 f9  	ldr	x1, [x1, #80]
ffff000000002e94: 01 28 00 f9  	str	x1, [x0, #80]
;     currProc->registers.x11 = *(base + 11);
ffff000000002e98: 00 02 00 d0  	adrp	x0, #270336
ffff000000002e9c: 00 40 07 91  	add	x0, x0, #464
ffff000000002ea0: 00 00 40 f9  	ldr	x0, [x0]
ffff000000002ea4: e1 0b 40 f9  	ldr	x1, [sp, #16]
ffff000000002ea8: 21 2c 40 f9  	ldr	x1, [x1, #88]
ffff000000002eac: 01 2c 00 f9  	str	x1, [x0, #88]
;     currProc->registers.x12 = *(base + 12);
ffff000000002eb0: 00 02 00 d0  	adrp	x0, #270336
ffff000000002eb4: 00 40 07 91  	add	x0, x0, #464
ffff000000002eb8: 00 00 40 f9  	ldr	x0, [x0]
ffff000000002ebc: e1 0b 40 f9  	ldr	x1, [sp, #16]
ffff000000002ec0: 21 30 40 f9  	ldr	x1, [x1, #96]
ffff000000002ec4: 01 30 00 f9  	str	x1, [x0, #96]
;     currProc->registers.x13 = *(base + 13);
ffff000000002ec8: 00 02 00 d0  	adrp	x0, #270336
ffff000000002ecc: 00 40 07 91  	add	x0, x0, #464
ffff000000002ed0: 00 00 40 f9  	ldr	x0, [x0]
ffff000000002ed4: e1 0b 40 f9  	ldr	x1, [sp, #16]
ffff000000002ed8: 21 34 40 f9  	ldr	x1, [x1, #104]
ffff000000002edc: 01 34 00 f9  	str	x1, [x0, #104]
;     currProc->registers.x14 = *(base + 14);
ffff000000002ee0: 00 02 00 d0  	adrp	x0, #270336
ffff000000002ee4: 00 40 07 91  	add	x0, x0, #464
ffff000000002ee8: 00 00 40 f9  	ldr	x0, [x0]
ffff000000002eec: e1 0b 40 f9  	ldr	x1, [sp, #16]
ffff000000002ef0: 21 38 40 f9  	ldr	x1, [x1, #112]
ffff000000002ef4: 01 38 00 f9  	str	x1, [x0, #112]
;     currProc->registers.x15 = *(base + 15);
ffff000000002ef8: 00 02 00 d0  	adrp	x0, #270336
ffff000000002efc: 00 40 07 91  	add	x0, x0, #464
ffff000000002f00: 00 00 40 f9  	ldr	x0, [x0]
ffff000000002f04: e1 0b 40 f9  	ldr	x1, [sp, #16]
ffff000000002f08: 21 3c 40 f9  	ldr	x1, [x1, #120]
ffff000000002f0c: 01 3c 00 f9  	str	x1, [x0, #120]
;     currProc->registers.x16 = *(base + 16);
ffff000000002f10: 00 02 00 d0  	adrp	x0, #270336
ffff000000002f14: 00 40 07 91  	add	x0, x0, #464
ffff000000002f18: 00 00 40 f9  	ldr	x0, [x0]
ffff000000002f1c: e1 0b 40 f9  	ldr	x1, [sp, #16]
ffff000000002f20: 21 40 40 f9  	ldr	x1, [x1, #128]
ffff000000002f24: 01 40 00 f9  	str	x1, [x0, #128]
;     currProc->registers.x17 = *(base + 17);
ffff000000002f28: 00 02 00 d0  	adrp	x0, #270336
ffff000000002f2c: 00 40 07 91  	add	x0, x0, #464
ffff000000002f30: 00 00 40 f9  	ldr	x0, [x0]
ffff000000002f34: e1 0b 40 f9  	ldr	x1, [sp, #16]
ffff000000002f38: 21 44 40 f9  	ldr	x1, [x1, #136]
ffff000000002f3c: 01 44 00 f9  	str	x1, [x0, #136]
;     currProc->registers.x18 = *(base + 18);
ffff000000002f40: 00 02 00 d0  	adrp	x0, #270336
ffff000000002f44: 00 40 07 91  	add	x0, x0, #464
ffff000000002f48: 00 00 40 f9  	ldr	x0, [x0]
ffff000000002f4c: e1 0b 40 f9  	ldr	x1, [sp, #16]
ffff000000002f50: 21 48 40 f9  	ldr	x1, [x1, #144]
ffff000000002f54: 01 48 00 f9  	str	x1, [x0, #144]
;     currProc->registers.x19 = *(base + 19);
ffff000000002f58: 00 02 00 d0  	adrp	x0, #270336
ffff000000002f5c: 00 40 07 91  	add	x0, x0, #464
ffff000000002f60: 00 00 40 f9  	ldr	x0, [x0]
ffff000000002f64: e1 0b 40 f9  	ldr	x1, [sp, #16]
ffff000000002f68: 21 4c 40 f9  	ldr	x1, [x1, #152]
ffff000000002f6c: 01 4c 00 f9  	str	x1, [x0, #152]
;     currProc->registers.x20 = *(base + 20);
ffff000000002f70: 00 02 00 d0  	adrp	x0, #270336
ffff000000002f74: 00 40 07 91  	add	x0, x0, #464
ffff000000002f78: 00 00 40 f9  	ldr	x0, [x0]
ffff000000002f7c: e1 0b 40 f9  	ldr	x1, [sp, #16]
ffff000000002f80: 21 50 40 f9  	ldr	x1, [x1, #160]
ffff000000002f84: 01 50 00 f9  	str	x1, [x0, #160]
;     currProc->registers.x21 = *(base + 21);
ffff000000002f88: 00 02 00 d0  	adrp	x0, #270336
ffff000000002f8c: 00 40 07 91  	add	x0, x0, #464
ffff000000002f90: 00 00 40 f9  	ldr	x0, [x0]
ffff000000002f94: e1 0b 40 f9  	ldr	x1, [sp, #16]
ffff000000002f98: 21 54 40 f9  	ldr	x1, [x1, #168]
ffff000000002f9c: 01 54 00 f9  	str	x1, [x0, #168]
;     currProc->registers.x22 = *(base + 22);
ffff000000002fa0: 00 02 00 d0  	adrp	x0, #270336
ffff000000002fa4: 00 40 07 91  	add	x0, x0, #464
ffff000000002fa8: 00 00 40 f9  	ldr	x0, [x0]
ffff000000002fac: e1 0b 40 f9  	ldr	x1, [sp, #16]
ffff000000002fb0: 21 58 40 f9  	ldr	x1, [x1, #176]
ffff000000002fb4: 01 58 00 f9  	str	x1, [x0, #176]
;     currProc->registers.x23 = *(base + 23);
ffff000000002fb8: 00 02 00 d0  	adrp	x0, #270336
ffff000000002fbc: 00 40 07 91  	add	x0, x0, #464
ffff000000002fc0: 00 00 40 f9  	ldr	x0, [x0]
ffff000000002fc4: e1 0b 40 f9  	ldr	x1, [sp, #16]
ffff000000002fc8: 21 5c 40 f9  	ldr	x1, [x1, #184]
ffff000000002fcc: 01 5c 00 f9  	str	x1, [x0, #184]
;     currProc->registers.x24 = *(base + 24);
ffff000000002fd0: 00 02 00 d0  	adrp	x0, #270336
ffff000000002fd4: 00 40 07 91  	add	x0, x0, #464
ffff000000002fd8: 00 00 40 f9  	ldr	x0, [x0]
ffff000000002fdc: e1 0b 40 f9  	ldr	x1, [sp, #16]
ffff000000002fe0: 21 60 40 f9  	ldr	x1, [x1, #192]
ffff000000002fe4: 01 60 00 f9  	str	x1, [x0, #192]
;     currProc->registers.x25 = *(base + 25);
ffff000000002fe8: 00 02 00 d0  	adrp	x0, #270336
ffff000000002fec: 00 40 07 91  	add	x0, x0, #464
ffff000000002ff0: 00 00 40 f9  	ldr	x0, [x0]
ffff000000002ff4: e1 0b 40 f9  	ldr	x1, [sp, #16]
ffff000000002ff8: 21 64 40 f9  	ldr	x1, [x1, #200]
ffff000000002ffc: 01 64 00 f9  	str	x1, [x0, #200]
;     currProc->registers.x26 = *(base + 26);
ffff000000003000: 00 02 00 b0  	adrp	x0, #266240
ffff000000003004: 00 40 07 91  	add	x0, x0, #464
ffff000000003008: 00 00 40 f9  	ldr	x0, [x0]
ffff00000000300c: e1 0b 40 f9  	ldr	x1, [sp, #16]
ffff000000003010: 21 68 40 f9  	ldr	x1, [x1, #208]
ffff000000003014: 01 68 00 f9  	str	x1, [x0, #208]
;     currProc->registers.x27 = *(base + 27);
ffff000000003018: 00 02 00 b0  	adrp	x0, #266240
ffff00000000301c: 00 40 07 91  	add	x0, x0, #464
ffff000000003020: 00 00 40 f9  	ldr	x0, [x0]
ffff000000003024: e1 0b 40 f9  	ldr	x1, [sp, #16]
ffff000000003028: 21 6c 40 f9  	ldr	x1, [x1, #216]
ffff00000000302c: 01 6c 00 f9  	str	x1, [x0, #216]
;     currProc->registers.x28 = *(base + 28);
ffff000000003030: 00 02 00 b0  	adrp	x0, #266240
ffff000000003034: 00 40 07 91  	add	x0, x0, #464
ffff000000003038: 00 00 40 f9  	ldr	x0, [x0]
ffff00000000303c: e1 0b 40 f9  	ldr	x1, [sp, #16]
ffff000000003040: 21 70 40 f9  	ldr	x1, [x1, #224]
ffff000000003044: 01 70 00 f9  	str	x1, [x0, #224]
;     currProc->registers.x29 = *(base + 29);
ffff000000003048: 00 02 00 b0  	adrp	x0, #266240
ffff00000000304c: 00 40 07 91  	add	x0, x0, #464
ffff000000003050: 00 00 40 f9  	ldr	x0, [x0]
ffff000000003054: e1 0b 40 f9  	ldr	x1, [sp, #16]
ffff000000003058: 21 74 40 f9  	ldr	x1, [x1, #232]
ffff00000000305c: 01 74 00 f9  	str	x1, [x0, #232]
;     currProc->registers.x30 = *(base + 30);
ffff000000003060: 00 02 00 b0  	adrp	x0, #266240
ffff000000003064: 00 40 07 91  	add	x0, x0, #464
ffff000000003068: 00 00 40 f9  	ldr	x0, [x0]
ffff00000000306c: e1 0b 40 f9  	ldr	x1, [sp, #16]
ffff000000003070: 21 78 40 f9  	ldr	x1, [x1, #240]
ffff000000003074: 01 78 00 f9  	str	x1, [x0, #240]
;     currProc->registers.exception_link_register = *(base + 31);
ffff000000003078: 00 02 00 b0  	adrp	x0, #266240
ffff00000000307c: 00 40 07 91  	add	x0, x0, #464
ffff000000003080: 00 00 40 f9  	ldr	x0, [x0]
ffff000000003084: e1 0b 40 f9  	ldr	x1, [sp, #16]
ffff000000003088: 21 7c 40 f9  	ldr	x1, [x1, #248]
ffff00000000308c: 01 7c 00 f9  	str	x1, [x0, #248]
;     currProc->registers.saved_program_status_register = *(base + 32);
ffff000000003090: 00 02 00 b0  	adrp	x0, #266240
ffff000000003094: 00 40 07 91  	add	x0, x0, #464
ffff000000003098: 00 00 40 f9  	ldr	x0, [x0]
ffff00000000309c: e1 0b 40 f9  	ldr	x1, [sp, #16]
ffff0000000030a0: 21 80 40 f9  	ldr	x1, [x1, #256]
ffff0000000030a4: 01 80 00 f9  	str	x1, [x0, #256]
;     currProc->registers.stack_pointer = *(base + 33);
ffff0000000030a8: 00 02 00 b0  	adrp	x0, #266240
ffff0000000030ac: 00 40 07 91  	add	x0, x0, #464
ffff0000000030b0: 00 00 40 f9  	ldr	x0, [x0]
ffff0000000030b4: e1 0b 40 f9  	ldr	x1, [sp, #16]
ffff0000000030b8: 21 84 40 f9  	ldr	x1, [x1, #264]
ffff0000000030bc: 01 84 00 f9  	str	x1, [x0, #264]
;     schedule();
ffff0000000030c0: f7 fc ff 97  	bl	0xffff00000000249c <schedule>
;     put32(TIMER_C1, get32(TIMER_CLO) + interval);
ffff0000000030c4: 80 00 86 d2  	mov	x0, #12292
ffff0000000030c8: 00 e0 a7 f2  	movk	x0, #16128, lsl #16
ffff0000000030cc: 98 04 00 94  	bl	0xffff00000000432c <get32>
ffff0000000030d0: e1 03 00 2a  	mov	w1, w0
ffff0000000030d4: 00 48 88 52  	mov	w0, #16960
ffff0000000030d8: e0 01 a0 72  	movk	w0, #15, lsl #16
ffff0000000030dc: 20 00 00 0b  	add	w0, w1, w0
ffff0000000030e0: e1 03 00 2a  	mov	w1, w0
ffff0000000030e4: 00 02 86 d2  	mov	x0, #12304
ffff0000000030e8: 00 e0 a7 f2  	movk	x0, #16128, lsl #16
ffff0000000030ec: 92 04 00 94  	bl	0xffff000000004334 <put32>
; }
ffff0000000030f0: 1f 20 03 d5  	nop
ffff0000000030f4: fd 7b c2 a8  	ldp	x29, x30, [sp], #32
ffff0000000030f8: c0 03 5f d6  	ret

ffff0000000030fc <uart_init>:
; void uart_init (void) {
ffff0000000030fc: fd 7b be a9  	stp	x29, x30, [sp, #-32]!
ffff000000003100: fd 03 00 91  	mov	x29, sp
; 	selector = get32(GPFSEL1);
ffff000000003104: 80 00 80 d2  	mov	x0, #4
ffff000000003108: 00 e4 a7 f2  	movk	x0, #16160, lsl #16
ffff00000000310c: 88 04 00 94  	bl	0xffff00000000432c <get32>
ffff000000003110: e0 1f 00 b9  	str	w0, [sp, #28]
; 	selector &= ~(7<<12);                   // clean gpio14
ffff000000003114: e0 1f 40 b9  	ldr	w0, [sp, #28]
ffff000000003118: 00 70 11 12  	and	w0, w0, #0xffff8fff
ffff00000000311c: e0 1f 00 b9  	str	w0, [sp, #28]
; 	selector |= 2<<12;                      // set alt5 for gpio14
ffff000000003120: e0 1f 40 b9  	ldr	w0, [sp, #28]
ffff000000003124: 00 00 13 32  	orr	w0, w0, #0x2000
ffff000000003128: e0 1f 00 b9  	str	w0, [sp, #28]
; 	selector &= ~(7<<15);                   // clean gpio15
ffff00000000312c: e0 1f 40 b9  	ldr	w0, [sp, #28]
ffff000000003130: 00 70 0e 12  	and	w0, w0, #0xfffc7fff
ffff000000003134: e0 1f 00 b9  	str	w0, [sp, #28]
; 	selector |= 2<<15;                      // set alt5 for gpio15
ffff000000003138: e0 1f 40 b9  	ldr	w0, [sp, #28]
ffff00000000313c: 00 00 10 32  	orr	w0, w0, #0x10000
ffff000000003140: e0 1f 00 b9  	str	w0, [sp, #28]
; 	put32(GPFSEL1,selector);
ffff000000003144: e1 1f 40 b9  	ldr	w1, [sp, #28]
ffff000000003148: 80 00 80 d2  	mov	x0, #4
ffff00000000314c: 00 e4 a7 f2  	movk	x0, #16160, lsl #16
ffff000000003150: 79 04 00 94  	bl	0xffff000000004334 <put32>
; 	put32(GPPUD,0);
ffff000000003154: 01 00 80 52  	mov	w1, #0
ffff000000003158: 80 12 80 d2  	mov	x0, #148
ffff00000000315c: 00 e4 a7 f2  	movk	x0, #16160, lsl #16
ffff000000003160: 75 04 00 94  	bl	0xffff000000004334 <put32>
; 	delay(150);
ffff000000003164: c0 12 80 d2  	mov	x0, #150
ffff000000003168: 6e 04 00 94  	bl	0xffff000000004320 <delay>
; 	put32(GPPUDCLK0,(1<<14)|(1<<15));
ffff00000000316c: 01 00 98 52  	mov	w1, #49152
ffff000000003170: 00 13 80 d2  	mov	x0, #152
ffff000000003174: 00 e4 a7 f2  	movk	x0, #16160, lsl #16
ffff000000003178: 6f 04 00 94  	bl	0xffff000000004334 <put32>
; 	delay(150);
ffff00000000317c: c0 12 80 d2  	mov	x0, #150
ffff000000003180: 68 04 00 94  	bl	0xffff000000004320 <delay>
; 	put32(GPPUDCLK0,0);
ffff000000003184: 01 00 80 52  	mov	w1, #0
ffff000000003188: 00 13 80 d2  	mov	x0, #152
ffff00000000318c: 00 e4 a7 f2  	movk	x0, #16160, lsl #16
ffff000000003190: 69 04 00 94  	bl	0xffff000000004334 <put32>
; 	put32(AUX_ENABLES,1);                   //Enable mini uart (this also enables access to its registers)
ffff000000003194: 21 00 80 52  	mov	w1, #1
ffff000000003198: 80 00 8a d2  	mov	x0, #20484
ffff00000000319c: 20 e4 a7 f2  	movk	x0, #16161, lsl #16
ffff0000000031a0: 65 04 00 94  	bl	0xffff000000004334 <put32>
; 	put32(AUX_MU_CNTL_REG,0);               //Disable auto flow control and disable receiver and transmitter (for now)
ffff0000000031a4: 01 00 80 52  	mov	w1, #0
ffff0000000031a8: 00 0c 8a d2  	mov	x0, #20576
ffff0000000031ac: 20 e4 a7 f2  	movk	x0, #16161, lsl #16
ffff0000000031b0: 61 04 00 94  	bl	0xffff000000004334 <put32>
; 	put32(AUX_MU_IER_REG,0);                //Disable receive and transmit interrupts
ffff0000000031b4: 01 00 80 52  	mov	w1, #0
ffff0000000031b8: 80 08 8a d2  	mov	x0, #20548
ffff0000000031bc: 20 e4 a7 f2  	movk	x0, #16161, lsl #16
ffff0000000031c0: 5d 04 00 94  	bl	0xffff000000004334 <put32>
; 	put32(AUX_MU_LCR_REG,3);                //Enable 8 bit mode
ffff0000000031c4: 61 00 80 52  	mov	w1, #3
ffff0000000031c8: 80 09 8a d2  	mov	x0, #20556
ffff0000000031cc: 20 e4 a7 f2  	movk	x0, #16161, lsl #16
ffff0000000031d0: 59 04 00 94  	bl	0xffff000000004334 <put32>
; 	put32(AUX_MU_MCR_REG,0);                //Set RTS line to be always high
ffff0000000031d4: 01 00 80 52  	mov	w1, #0
ffff0000000031d8: 00 0a 8a d2  	mov	x0, #20560
ffff0000000031dc: 20 e4 a7 f2  	movk	x0, #16161, lsl #16
ffff0000000031e0: 55 04 00 94  	bl	0xffff000000004334 <put32>
; 	put32(AUX_MU_BAUD_REG,270);             //Set baud rate to 115200
ffff0000000031e4: c1 21 80 52  	mov	w1, #270
ffff0000000031e8: 00 0d 8a d2  	mov	x0, #20584
ffff0000000031ec: 20 e4 a7 f2  	movk	x0, #16161, lsl #16
ffff0000000031f0: 51 04 00 94  	bl	0xffff000000004334 <put32>
; 	put32(AUX_MU_CNTL_REG,3);  
ffff0000000031f4: 61 00 80 52  	mov	w1, #3
ffff0000000031f8: 00 0c 8a d2  	mov	x0, #20576
ffff0000000031fc: 20 e4 a7 f2  	movk	x0, #16161, lsl #16
ffff000000003200: 4d 04 00 94  	bl	0xffff000000004334 <put32>
; }
ffff000000003204: 1f 20 03 d5  	nop
ffff000000003208: fd 7b c2 a8  	ldp	x29, x30, [sp], #32
ffff00000000320c: c0 03 5f d6  	ret

ffff000000003210 <uart_send>:
; {
ffff000000003210: fd 7b be a9  	stp	x29, x30, [sp, #-32]!
ffff000000003214: fd 03 00 91  	mov	x29, sp
ffff000000003218: e0 7f 00 39  	strb	w0, [sp, #31]
; 		if(get32(AUX_MU_LSR_REG)&0x20) 
ffff00000000321c: 80 0a 8a d2  	mov	x0, #20564
ffff000000003220: 20 e4 a7 f2  	movk	x0, #16161, lsl #16
ffff000000003224: 42 04 00 94  	bl	0xffff00000000432c <get32>
ffff000000003228: 00 00 1b 12  	and	w0, w0, #0x20
ffff00000000322c: 1f 00 00 71  	cmp	w0, #0
ffff000000003230: 41 00 00 54  	b.ne	0xffff000000003238 <uart_send+0x28>
ffff000000003234: fa ff ff 17  	b	0xffff00000000321c <uart_send+0xc>
; 			break;
ffff000000003238: 1f 20 03 d5  	nop
; 	put32(AUX_MU_IO_REG,c);
ffff00000000323c: e0 7f 40 39  	ldrb	w0, [sp, #31]
ffff000000003240: e1 03 00 2a  	mov	w1, w0
ffff000000003244: 00 08 8a d2  	mov	x0, #20544
ffff000000003248: 20 e4 a7 f2  	movk	x0, #16161, lsl #16
ffff00000000324c: 3a 04 00 94  	bl	0xffff000000004334 <put32>
; }
ffff000000003250: 1f 20 03 d5  	nop
ffff000000003254: fd 7b c2 a8  	ldp	x29, x30, [sp], #32
ffff000000003258: c0 03 5f d6  	ret

ffff00000000325c <uart_recv>:
; {
ffff00000000325c: fd 7b bf a9  	stp	x29, x30, [sp, #-16]!
ffff000000003260: fd 03 00 91  	mov	x29, sp
; 		if(get32(AUX_MU_LSR_REG)&0x01) 
ffff000000003264: 80 0a 8a d2  	mov	x0, #20564
ffff000000003268: 20 e4 a7 f2  	movk	x0, #16161, lsl #16
ffff00000000326c: 30 04 00 94  	bl	0xffff00000000432c <get32>
ffff000000003270: 00 00 00 12  	and	w0, w0, #0x1
ffff000000003274: 1f 00 00 71  	cmp	w0, #0
ffff000000003278: 41 00 00 54  	b.ne	0xffff000000003280 <uart_recv+0x24>
ffff00000000327c: fa ff ff 17  	b	0xffff000000003264 <uart_recv+0x8>
; 			break;
ffff000000003280: 1f 20 03 d5  	nop
; 	return(get32(AUX_MU_IO_REG)&0xFF);
ffff000000003284: 00 08 8a d2  	mov	x0, #20544
ffff000000003288: 20 e4 a7 f2  	movk	x0, #16161, lsl #16
ffff00000000328c: 28 04 00 94  	bl	0xffff00000000432c <get32>
ffff000000003290: 00 1c 00 12  	and	w0, w0, #0xff
; }
ffff000000003294: fd 7b c1 a8  	ldp	x29, x30, [sp], #16
ffff000000003298: c0 03 5f d6  	ret

ffff00000000329c <uart_send_string>:
; void uart_send_string(char* str) {
ffff00000000329c: fd 7b be a9  	stp	x29, x30, [sp, #-32]!
ffff0000000032a0: fd 03 00 91  	mov	x29, sp
ffff0000000032a4: e0 0f 00 f9  	str	x0, [sp, #24]
;     while (*str != '\0')
ffff0000000032a8: 06 00 00 14  	b	0xffff0000000032c0 <uart_send_string+0x24>
;         uart_send(*(str++));
ffff0000000032ac: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff0000000032b0: 01 04 00 91  	add	x1, x0, #1
ffff0000000032b4: e1 0f 00 f9  	str	x1, [sp, #24]
ffff0000000032b8: 00 00 40 39  	ldrb	w0, [x0]
ffff0000000032bc: d5 ff ff 97  	bl	0xffff000000003210 <uart_send>
;     while (*str != '\0')
ffff0000000032c0: e0 0f 40 f9  	ldr	x0, [sp, #24]
ffff0000000032c4: 00 00 40 39  	ldrb	w0, [x0]
ffff0000000032c8: 1f 00 00 71  	cmp	w0, #0
ffff0000000032cc: 01 ff ff 54  	b.ne	0xffff0000000032ac <uart_send_string+0x10>
; }
ffff0000000032d0: 1f 20 03 d5  	nop
ffff0000000032d4: 1f 20 03 d5  	nop
ffff0000000032d8: fd 7b c2 a8  	ldp	x29, x30, [sp], #32
ffff0000000032dc: c0 03 5f d6  	ret
		...

ffff000000003800 <exception_vector_list>:
;     handle_invalid_entry SYNCHRONOUS_EL1_SP_EL0
ffff000000003800: 00 00 80 d2  	mov	x0, #0
ffff000000003804: 01 52 38 d5  	mrs	x1, ESR_EL1
ffff000000003808: 22 40 38 d5  	mrs	x2, ELR_EL1
ffff00000000380c: fd f3 ff 97  	bl	0xffff000000000800 <show_unknown_interrupt_msg>
ffff000000003810: 07 f2 ff 17  	b	0xffff00000000002c <proc_hang>
ffff000000003814: 1f 20 03 d5  	nop
ffff000000003818: 1f 20 03 d5  	nop
ffff00000000381c: 1f 20 03 d5  	nop
ffff000000003820: 1f 20 03 d5  	nop
ffff000000003824: 1f 20 03 d5  	nop
ffff000000003828: 1f 20 03 d5  	nop
ffff00000000382c: 1f 20 03 d5  	nop
ffff000000003830: 1f 20 03 d5  	nop
ffff000000003834: 1f 20 03 d5  	nop
ffff000000003838: 1f 20 03 d5  	nop
ffff00000000383c: 1f 20 03 d5  	nop
ffff000000003840: 1f 20 03 d5  	nop
ffff000000003844: 1f 20 03 d5  	nop
ffff000000003848: 1f 20 03 d5  	nop
ffff00000000384c: 1f 20 03 d5  	nop
ffff000000003850: 1f 20 03 d5  	nop
ffff000000003854: 1f 20 03 d5  	nop
ffff000000003858: 1f 20 03 d5  	nop
ffff00000000385c: 1f 20 03 d5  	nop
ffff000000003860: 1f 20 03 d5  	nop
ffff000000003864: 1f 20 03 d5  	nop
ffff000000003868: 1f 20 03 d5  	nop
ffff00000000386c: 1f 20 03 d5  	nop
ffff000000003870: 1f 20 03 d5  	nop
ffff000000003874: 1f 20 03 d5  	nop
ffff000000003878: 1f 20 03 d5  	nop
ffff00000000387c: 1f 20 03 d5  	nop
;     handle_invalid_entry IRQ_EL1_SP_EL0 
ffff000000003880: 20 00 80 d2  	mov	x0, #1
ffff000000003884: 01 52 38 d5  	mrs	x1, ESR_EL1
ffff000000003888: 22 40 38 d5  	mrs	x2, ELR_EL1
ffff00000000388c: dd f3 ff 97  	bl	0xffff000000000800 <show_unknown_interrupt_msg>
ffff000000003890: e7 f1 ff 17  	b	0xffff00000000002c <proc_hang>
ffff000000003894: 1f 20 03 d5  	nop
ffff000000003898: 1f 20 03 d5  	nop
ffff00000000389c: 1f 20 03 d5  	nop
ffff0000000038a0: 1f 20 03 d5  	nop
ffff0000000038a4: 1f 20 03 d5  	nop
ffff0000000038a8: 1f 20 03 d5  	nop
ffff0000000038ac: 1f 20 03 d5  	nop
ffff0000000038b0: 1f 20 03 d5  	nop
ffff0000000038b4: 1f 20 03 d5  	nop
ffff0000000038b8: 1f 20 03 d5  	nop
ffff0000000038bc: 1f 20 03 d5  	nop
ffff0000000038c0: 1f 20 03 d5  	nop
ffff0000000038c4: 1f 20 03 d5  	nop
ffff0000000038c8: 1f 20 03 d5  	nop
ffff0000000038cc: 1f 20 03 d5  	nop
ffff0000000038d0: 1f 20 03 d5  	nop
ffff0000000038d4: 1f 20 03 d5  	nop
ffff0000000038d8: 1f 20 03 d5  	nop
ffff0000000038dc: 1f 20 03 d5  	nop
ffff0000000038e0: 1f 20 03 d5  	nop
ffff0000000038e4: 1f 20 03 d5  	nop
ffff0000000038e8: 1f 20 03 d5  	nop
ffff0000000038ec: 1f 20 03 d5  	nop
ffff0000000038f0: 1f 20 03 d5  	nop
ffff0000000038f4: 1f 20 03 d5  	nop
ffff0000000038f8: 1f 20 03 d5  	nop
ffff0000000038fc: 1f 20 03 d5  	nop
;     handle_invalid_entry FIQ_EL1_SP_EL0
ffff000000003900: 40 00 80 d2  	mov	x0, #2
ffff000000003904: 01 52 38 d5  	mrs	x1, ESR_EL1
ffff000000003908: 22 40 38 d5  	mrs	x2, ELR_EL1
ffff00000000390c: bd f3 ff 97  	bl	0xffff000000000800 <show_unknown_interrupt_msg>
ffff000000003910: c7 f1 ff 17  	b	0xffff00000000002c <proc_hang>
ffff000000003914: 1f 20 03 d5  	nop
ffff000000003918: 1f 20 03 d5  	nop
ffff00000000391c: 1f 20 03 d5  	nop
ffff000000003920: 1f 20 03 d5  	nop
ffff000000003924: 1f 20 03 d5  	nop
ffff000000003928: 1f 20 03 d5  	nop
ffff00000000392c: 1f 20 03 d5  	nop
ffff000000003930: 1f 20 03 d5  	nop
ffff000000003934: 1f 20 03 d5  	nop
ffff000000003938: 1f 20 03 d5  	nop
ffff00000000393c: 1f 20 03 d5  	nop
ffff000000003940: 1f 20 03 d5  	nop
ffff000000003944: 1f 20 03 d5  	nop
ffff000000003948: 1f 20 03 d5  	nop
ffff00000000394c: 1f 20 03 d5  	nop
ffff000000003950: 1f 20 03 d5  	nop
ffff000000003954: 1f 20 03 d5  	nop
ffff000000003958: 1f 20 03 d5  	nop
ffff00000000395c: 1f 20 03 d5  	nop
ffff000000003960: 1f 20 03 d5  	nop
ffff000000003964: 1f 20 03 d5  	nop
ffff000000003968: 1f 20 03 d5  	nop
ffff00000000396c: 1f 20 03 d5  	nop
ffff000000003970: 1f 20 03 d5  	nop
ffff000000003974: 1f 20 03 d5  	nop
ffff000000003978: 1f 20 03 d5  	nop
ffff00000000397c: 1f 20 03 d5  	nop
;     handle_invalid_entry SERROR_EL1_SP_EL0
ffff000000003980: 60 00 80 d2  	mov	x0, #3
ffff000000003984: 01 52 38 d5  	mrs	x1, ESR_EL1
ffff000000003988: 22 40 38 d5  	mrs	x2, ELR_EL1
ffff00000000398c: 9d f3 ff 97  	bl	0xffff000000000800 <show_unknown_interrupt_msg>
ffff000000003990: a7 f1 ff 17  	b	0xffff00000000002c <proc_hang>
ffff000000003994: 1f 20 03 d5  	nop
ffff000000003998: 1f 20 03 d5  	nop
ffff00000000399c: 1f 20 03 d5  	nop
ffff0000000039a0: 1f 20 03 d5  	nop
ffff0000000039a4: 1f 20 03 d5  	nop
ffff0000000039a8: 1f 20 03 d5  	nop
ffff0000000039ac: 1f 20 03 d5  	nop
ffff0000000039b0: 1f 20 03 d5  	nop
ffff0000000039b4: 1f 20 03 d5  	nop
ffff0000000039b8: 1f 20 03 d5  	nop
ffff0000000039bc: 1f 20 03 d5  	nop
ffff0000000039c0: 1f 20 03 d5  	nop
ffff0000000039c4: 1f 20 03 d5  	nop
ffff0000000039c8: 1f 20 03 d5  	nop
ffff0000000039cc: 1f 20 03 d5  	nop
ffff0000000039d0: 1f 20 03 d5  	nop
ffff0000000039d4: 1f 20 03 d5  	nop
ffff0000000039d8: 1f 20 03 d5  	nop
ffff0000000039dc: 1f 20 03 d5  	nop
ffff0000000039e0: 1f 20 03 d5  	nop
ffff0000000039e4: 1f 20 03 d5  	nop
ffff0000000039e8: 1f 20 03 d5  	nop
ffff0000000039ec: 1f 20 03 d5  	nop
ffff0000000039f0: 1f 20 03 d5  	nop
ffff0000000039f4: 1f 20 03 d5  	nop
ffff0000000039f8: 1f 20 03 d5  	nop
ffff0000000039fc: 1f 20 03 d5  	nop
;     handle_invalid_entry SYNCHRONOUS_EL1_SP_EL1
ffff000000003a00: 80 00 80 d2  	mov	x0, #4
ffff000000003a04: 01 52 38 d5  	mrs	x1, ESR_EL1
ffff000000003a08: 22 40 38 d5  	mrs	x2, ELR_EL1
ffff000000003a0c: 7d f3 ff 97  	bl	0xffff000000000800 <show_unknown_interrupt_msg>
ffff000000003a10: 87 f1 ff 17  	b	0xffff00000000002c <proc_hang>
ffff000000003a14: 1f 20 03 d5  	nop
ffff000000003a18: 1f 20 03 d5  	nop
ffff000000003a1c: 1f 20 03 d5  	nop
ffff000000003a20: 1f 20 03 d5  	nop
ffff000000003a24: 1f 20 03 d5  	nop
ffff000000003a28: 1f 20 03 d5  	nop
ffff000000003a2c: 1f 20 03 d5  	nop
ffff000000003a30: 1f 20 03 d5  	nop
ffff000000003a34: 1f 20 03 d5  	nop
ffff000000003a38: 1f 20 03 d5  	nop
ffff000000003a3c: 1f 20 03 d5  	nop
ffff000000003a40: 1f 20 03 d5  	nop
ffff000000003a44: 1f 20 03 d5  	nop
ffff000000003a48: 1f 20 03 d5  	nop
ffff000000003a4c: 1f 20 03 d5  	nop
ffff000000003a50: 1f 20 03 d5  	nop
ffff000000003a54: 1f 20 03 d5  	nop
ffff000000003a58: 1f 20 03 d5  	nop
ffff000000003a5c: 1f 20 03 d5  	nop
ffff000000003a60: 1f 20 03 d5  	nop
ffff000000003a64: 1f 20 03 d5  	nop
ffff000000003a68: 1f 20 03 d5  	nop
ffff000000003a6c: 1f 20 03 d5  	nop
ffff000000003a70: 1f 20 03 d5  	nop
ffff000000003a74: 1f 20 03 d5  	nop
ffff000000003a78: 1f 20 03 d5  	nop
ffff000000003a7c: 1f 20 03 d5  	nop
;     b handle_el1_irq
ffff000000003a80: 9b 01 00 14  	b	0xffff0000000040ec <handle_el1_irq>
ffff000000003a84: 1f 20 03 d5  	nop
ffff000000003a88: 1f 20 03 d5  	nop
ffff000000003a8c: 1f 20 03 d5  	nop
ffff000000003a90: 1f 20 03 d5  	nop
ffff000000003a94: 1f 20 03 d5  	nop
ffff000000003a98: 1f 20 03 d5  	nop
ffff000000003a9c: 1f 20 03 d5  	nop
ffff000000003aa0: 1f 20 03 d5  	nop
ffff000000003aa4: 1f 20 03 d5  	nop
ffff000000003aa8: 1f 20 03 d5  	nop
ffff000000003aac: 1f 20 03 d5  	nop
ffff000000003ab0: 1f 20 03 d5  	nop
ffff000000003ab4: 1f 20 03 d5  	nop
ffff000000003ab8: 1f 20 03 d5  	nop
ffff000000003abc: 1f 20 03 d5  	nop
ffff000000003ac0: 1f 20 03 d5  	nop
ffff000000003ac4: 1f 20 03 d5  	nop
ffff000000003ac8: 1f 20 03 d5  	nop
ffff000000003acc: 1f 20 03 d5  	nop
ffff000000003ad0: 1f 20 03 d5  	nop
ffff000000003ad4: 1f 20 03 d5  	nop
ffff000000003ad8: 1f 20 03 d5  	nop
ffff000000003adc: 1f 20 03 d5  	nop
ffff000000003ae0: 1f 20 03 d5  	nop
ffff000000003ae4: 1f 20 03 d5  	nop
ffff000000003ae8: 1f 20 03 d5  	nop
ffff000000003aec: 1f 20 03 d5  	nop
ffff000000003af0: 1f 20 03 d5  	nop
ffff000000003af4: 1f 20 03 d5  	nop
ffff000000003af8: 1f 20 03 d5  	nop
ffff000000003afc: 1f 20 03 d5  	nop
;     handle_invalid_entry FIQ_EL1_SP_EL1
ffff000000003b00: c0 00 80 d2  	mov	x0, #6
ffff000000003b04: 01 52 38 d5  	mrs	x1, ESR_EL1
ffff000000003b08: 22 40 38 d5  	mrs	x2, ELR_EL1
ffff000000003b0c: 3d f3 ff 97  	bl	0xffff000000000800 <show_unknown_interrupt_msg>
ffff000000003b10: 47 f1 ff 17  	b	0xffff00000000002c <proc_hang>
ffff000000003b14: 1f 20 03 d5  	nop
ffff000000003b18: 1f 20 03 d5  	nop
ffff000000003b1c: 1f 20 03 d5  	nop
ffff000000003b20: 1f 20 03 d5  	nop
ffff000000003b24: 1f 20 03 d5  	nop
ffff000000003b28: 1f 20 03 d5  	nop
ffff000000003b2c: 1f 20 03 d5  	nop
ffff000000003b30: 1f 20 03 d5  	nop
ffff000000003b34: 1f 20 03 d5  	nop
ffff000000003b38: 1f 20 03 d5  	nop
ffff000000003b3c: 1f 20 03 d5  	nop
ffff000000003b40: 1f 20 03 d5  	nop
ffff000000003b44: 1f 20 03 d5  	nop
ffff000000003b48: 1f 20 03 d5  	nop
ffff000000003b4c: 1f 20 03 d5  	nop
ffff000000003b50: 1f 20 03 d5  	nop
ffff000000003b54: 1f 20 03 d5  	nop
ffff000000003b58: 1f 20 03 d5  	nop
ffff000000003b5c: 1f 20 03 d5  	nop
ffff000000003b60: 1f 20 03 d5  	nop
ffff000000003b64: 1f 20 03 d5  	nop
ffff000000003b68: 1f 20 03 d5  	nop
ffff000000003b6c: 1f 20 03 d5  	nop
ffff000000003b70: 1f 20 03 d5  	nop
ffff000000003b74: 1f 20 03 d5  	nop
ffff000000003b78: 1f 20 03 d5  	nop
ffff000000003b7c: 1f 20 03 d5  	nop
;     handle_invalid_entry SERROR_EL1_SP_EL1
ffff000000003b80: e0 00 80 d2  	mov	x0, #7
ffff000000003b84: 01 52 38 d5  	mrs	x1, ESR_EL1
ffff000000003b88: 22 40 38 d5  	mrs	x2, ELR_EL1
ffff000000003b8c: 1d f3 ff 97  	bl	0xffff000000000800 <show_unknown_interrupt_msg>
ffff000000003b90: 27 f1 ff 17  	b	0xffff00000000002c <proc_hang>
ffff000000003b94: 1f 20 03 d5  	nop
ffff000000003b98: 1f 20 03 d5  	nop
ffff000000003b9c: 1f 20 03 d5  	nop
ffff000000003ba0: 1f 20 03 d5  	nop
ffff000000003ba4: 1f 20 03 d5  	nop
ffff000000003ba8: 1f 20 03 d5  	nop
ffff000000003bac: 1f 20 03 d5  	nop
ffff000000003bb0: 1f 20 03 d5  	nop
ffff000000003bb4: 1f 20 03 d5  	nop
ffff000000003bb8: 1f 20 03 d5  	nop
ffff000000003bbc: 1f 20 03 d5  	nop
ffff000000003bc0: 1f 20 03 d5  	nop
ffff000000003bc4: 1f 20 03 d5  	nop
ffff000000003bc8: 1f 20 03 d5  	nop
ffff000000003bcc: 1f 20 03 d5  	nop
ffff000000003bd0: 1f 20 03 d5  	nop
ffff000000003bd4: 1f 20 03 d5  	nop
ffff000000003bd8: 1f 20 03 d5  	nop
ffff000000003bdc: 1f 20 03 d5  	nop
ffff000000003be0: 1f 20 03 d5  	nop
ffff000000003be4: 1f 20 03 d5  	nop
ffff000000003be8: 1f 20 03 d5  	nop
ffff000000003bec: 1f 20 03 d5  	nop
ffff000000003bf0: 1f 20 03 d5  	nop
ffff000000003bf4: 1f 20 03 d5  	nop
ffff000000003bf8: 1f 20 03 d5  	nop
ffff000000003bfc: 1f 20 03 d5  	nop
;     handle_invalid_entry SYNCHRONOUS_EL0_AARCH64
ffff000000003c00: 00 01 80 d2  	mov	x0, #8
ffff000000003c04: 01 52 38 d5  	mrs	x1, ESR_EL1
ffff000000003c08: 22 40 38 d5  	mrs	x2, ELR_EL1
ffff000000003c0c: fd f2 ff 97  	bl	0xffff000000000800 <show_unknown_interrupt_msg>
ffff000000003c10: 07 f1 ff 17  	b	0xffff00000000002c <proc_hang>
ffff000000003c14: 1f 20 03 d5  	nop
ffff000000003c18: 1f 20 03 d5  	nop
ffff000000003c1c: 1f 20 03 d5  	nop
ffff000000003c20: 1f 20 03 d5  	nop
ffff000000003c24: 1f 20 03 d5  	nop
ffff000000003c28: 1f 20 03 d5  	nop
ffff000000003c2c: 1f 20 03 d5  	nop
ffff000000003c30: 1f 20 03 d5  	nop
ffff000000003c34: 1f 20 03 d5  	nop
ffff000000003c38: 1f 20 03 d5  	nop
ffff000000003c3c: 1f 20 03 d5  	nop
ffff000000003c40: 1f 20 03 d5  	nop
ffff000000003c44: 1f 20 03 d5  	nop
ffff000000003c48: 1f 20 03 d5  	nop
ffff000000003c4c: 1f 20 03 d5  	nop
ffff000000003c50: 1f 20 03 d5  	nop
ffff000000003c54: 1f 20 03 d5  	nop
ffff000000003c58: 1f 20 03 d5  	nop
ffff000000003c5c: 1f 20 03 d5  	nop
ffff000000003c60: 1f 20 03 d5  	nop
ffff000000003c64: 1f 20 03 d5  	nop
ffff000000003c68: 1f 20 03 d5  	nop
ffff000000003c6c: 1f 20 03 d5  	nop
ffff000000003c70: 1f 20 03 d5  	nop
ffff000000003c74: 1f 20 03 d5  	nop
ffff000000003c78: 1f 20 03 d5  	nop
ffff000000003c7c: 1f 20 03 d5  	nop
;     b handle_el0_synch
ffff000000003c80: c5 00 00 14  	b	0xffff000000003f94 <handle_el0_synch>
ffff000000003c84: 1f 20 03 d5  	nop
ffff000000003c88: 1f 20 03 d5  	nop
ffff000000003c8c: 1f 20 03 d5  	nop
ffff000000003c90: 1f 20 03 d5  	nop
ffff000000003c94: 1f 20 03 d5  	nop
ffff000000003c98: 1f 20 03 d5  	nop
ffff000000003c9c: 1f 20 03 d5  	nop
ffff000000003ca0: 1f 20 03 d5  	nop
ffff000000003ca4: 1f 20 03 d5  	nop
ffff000000003ca8: 1f 20 03 d5  	nop
ffff000000003cac: 1f 20 03 d5  	nop
ffff000000003cb0: 1f 20 03 d5  	nop
ffff000000003cb4: 1f 20 03 d5  	nop
ffff000000003cb8: 1f 20 03 d5  	nop
ffff000000003cbc: 1f 20 03 d5  	nop
ffff000000003cc0: 1f 20 03 d5  	nop
ffff000000003cc4: 1f 20 03 d5  	nop
ffff000000003cc8: 1f 20 03 d5  	nop
ffff000000003ccc: 1f 20 03 d5  	nop
ffff000000003cd0: 1f 20 03 d5  	nop
ffff000000003cd4: 1f 20 03 d5  	nop
ffff000000003cd8: 1f 20 03 d5  	nop
ffff000000003cdc: 1f 20 03 d5  	nop
ffff000000003ce0: 1f 20 03 d5  	nop
ffff000000003ce4: 1f 20 03 d5  	nop
ffff000000003ce8: 1f 20 03 d5  	nop
ffff000000003cec: 1f 20 03 d5  	nop
ffff000000003cf0: 1f 20 03 d5  	nop
ffff000000003cf4: 1f 20 03 d5  	nop
ffff000000003cf8: 1f 20 03 d5  	nop
ffff000000003cfc: 1f 20 03 d5  	nop
;     handle_invalid_entry FIQ_EL0_AARCH64
ffff000000003d00: 40 01 80 d2  	mov	x0, #10
ffff000000003d04: 01 52 38 d5  	mrs	x1, ESR_EL1
ffff000000003d08: 22 40 38 d5  	mrs	x2, ELR_EL1
ffff000000003d0c: bd f2 ff 97  	bl	0xffff000000000800 <show_unknown_interrupt_msg>
ffff000000003d10: c7 f0 ff 17  	b	0xffff00000000002c <proc_hang>
ffff000000003d14: 1f 20 03 d5  	nop
ffff000000003d18: 1f 20 03 d5  	nop
ffff000000003d1c: 1f 20 03 d5  	nop
ffff000000003d20: 1f 20 03 d5  	nop
ffff000000003d24: 1f 20 03 d5  	nop
ffff000000003d28: 1f 20 03 d5  	nop
ffff000000003d2c: 1f 20 03 d5  	nop
ffff000000003d30: 1f 20 03 d5  	nop
ffff000000003d34: 1f 20 03 d5  	nop
ffff000000003d38: 1f 20 03 d5  	nop
ffff000000003d3c: 1f 20 03 d5  	nop
ffff000000003d40: 1f 20 03 d5  	nop
ffff000000003d44: 1f 20 03 d5  	nop
ffff000000003d48: 1f 20 03 d5  	nop
ffff000000003d4c: 1f 20 03 d5  	nop
ffff000000003d50: 1f 20 03 d5  	nop
ffff000000003d54: 1f 20 03 d5  	nop
ffff000000003d58: 1f 20 03 d5  	nop
ffff000000003d5c: 1f 20 03 d5  	nop
ffff000000003d60: 1f 20 03 d5  	nop
ffff000000003d64: 1f 20 03 d5  	nop
ffff000000003d68: 1f 20 03 d5  	nop
ffff000000003d6c: 1f 20 03 d5  	nop
ffff000000003d70: 1f 20 03 d5  	nop
ffff000000003d74: 1f 20 03 d5  	nop
ffff000000003d78: 1f 20 03 d5  	nop
ffff000000003d7c: 1f 20 03 d5  	nop
;     handle_invalid_entry SERROR_EL0_AARCH64
ffff000000003d80: 60 01 80 d2  	mov	x0, #11
ffff000000003d84: 01 52 38 d5  	mrs	x1, ESR_EL1
ffff000000003d88: 22 40 38 d5  	mrs	x2, ELR_EL1
ffff000000003d8c: 9d f2 ff 97  	bl	0xffff000000000800 <show_unknown_interrupt_msg>
ffff000000003d90: a7 f0 ff 17  	b	0xffff00000000002c <proc_hang>
ffff000000003d94: 1f 20 03 d5  	nop
ffff000000003d98: 1f 20 03 d5  	nop
ffff000000003d9c: 1f 20 03 d5  	nop
ffff000000003da0: 1f 20 03 d5  	nop
ffff000000003da4: 1f 20 03 d5  	nop
ffff000000003da8: 1f 20 03 d5  	nop
ffff000000003dac: 1f 20 03 d5  	nop
ffff000000003db0: 1f 20 03 d5  	nop
ffff000000003db4: 1f 20 03 d5  	nop
ffff000000003db8: 1f 20 03 d5  	nop
ffff000000003dbc: 1f 20 03 d5  	nop
ffff000000003dc0: 1f 20 03 d5  	nop
ffff000000003dc4: 1f 20 03 d5  	nop
ffff000000003dc8: 1f 20 03 d5  	nop
ffff000000003dcc: 1f 20 03 d5  	nop
ffff000000003dd0: 1f 20 03 d5  	nop
ffff000000003dd4: 1f 20 03 d5  	nop
ffff000000003dd8: 1f 20 03 d5  	nop
ffff000000003ddc: 1f 20 03 d5  	nop
ffff000000003de0: 1f 20 03 d5  	nop
ffff000000003de4: 1f 20 03 d5  	nop
ffff000000003de8: 1f 20 03 d5  	nop
ffff000000003dec: 1f 20 03 d5  	nop
ffff000000003df0: 1f 20 03 d5  	nop
ffff000000003df4: 1f 20 03 d5  	nop
ffff000000003df8: 1f 20 03 d5  	nop
ffff000000003dfc: 1f 20 03 d5  	nop
;     handle_invalid_entry SYNCHRONOUS_EL0_AARCH32
ffff000000003e00: 80 01 80 d2  	mov	x0, #12
ffff000000003e04: 01 52 38 d5  	mrs	x1, ESR_EL1
ffff000000003e08: 22 40 38 d5  	mrs	x2, ELR_EL1
ffff000000003e0c: 7d f2 ff 97  	bl	0xffff000000000800 <show_unknown_interrupt_msg>
ffff000000003e10: 87 f0 ff 17  	b	0xffff00000000002c <proc_hang>
ffff000000003e14: 1f 20 03 d5  	nop
ffff000000003e18: 1f 20 03 d5  	nop
ffff000000003e1c: 1f 20 03 d5  	nop
ffff000000003e20: 1f 20 03 d5  	nop
ffff000000003e24: 1f 20 03 d5  	nop
ffff000000003e28: 1f 20 03 d5  	nop
ffff000000003e2c: 1f 20 03 d5  	nop
ffff000000003e30: 1f 20 03 d5  	nop
ffff000000003e34: 1f 20 03 d5  	nop
ffff000000003e38: 1f 20 03 d5  	nop
ffff000000003e3c: 1f 20 03 d5  	nop
ffff000000003e40: 1f 20 03 d5  	nop
ffff000000003e44: 1f 20 03 d5  	nop
ffff000000003e48: 1f 20 03 d5  	nop
ffff000000003e4c: 1f 20 03 d5  	nop
ffff000000003e50: 1f 20 03 d5  	nop
ffff000000003e54: 1f 20 03 d5  	nop
ffff000000003e58: 1f 20 03 d5  	nop
ffff000000003e5c: 1f 20 03 d5  	nop
ffff000000003e60: 1f 20 03 d5  	nop
ffff000000003e64: 1f 20 03 d5  	nop
ffff000000003e68: 1f 20 03 d5  	nop
ffff000000003e6c: 1f 20 03 d5  	nop
ffff000000003e70: 1f 20 03 d5  	nop
ffff000000003e74: 1f 20 03 d5  	nop
ffff000000003e78: 1f 20 03 d5  	nop
ffff000000003e7c: 1f 20 03 d5  	nop
;     handle_invalid_entry IRQ_EL0_AARCH32
ffff000000003e80: a0 01 80 d2  	mov	x0, #13
ffff000000003e84: 01 52 38 d5  	mrs	x1, ESR_EL1
ffff000000003e88: 22 40 38 d5  	mrs	x2, ELR_EL1
ffff000000003e8c: 5d f2 ff 97  	bl	0xffff000000000800 <show_unknown_interrupt_msg>
ffff000000003e90: 67 f0 ff 17  	b	0xffff00000000002c <proc_hang>
ffff000000003e94: 1f 20 03 d5  	nop
ffff000000003e98: 1f 20 03 d5  	nop
ffff000000003e9c: 1f 20 03 d5  	nop
ffff000000003ea0: 1f 20 03 d5  	nop
ffff000000003ea4: 1f 20 03 d5  	nop
ffff000000003ea8: 1f 20 03 d5  	nop
ffff000000003eac: 1f 20 03 d5  	nop
ffff000000003eb0: 1f 20 03 d5  	nop
ffff000000003eb4: 1f 20 03 d5  	nop
ffff000000003eb8: 1f 20 03 d5  	nop
ffff000000003ebc: 1f 20 03 d5  	nop
ffff000000003ec0: 1f 20 03 d5  	nop
ffff000000003ec4: 1f 20 03 d5  	nop
ffff000000003ec8: 1f 20 03 d5  	nop
ffff000000003ecc: 1f 20 03 d5  	nop
ffff000000003ed0: 1f 20 03 d5  	nop
ffff000000003ed4: 1f 20 03 d5  	nop
ffff000000003ed8: 1f 20 03 d5  	nop
ffff000000003edc: 1f 20 03 d5  	nop
ffff000000003ee0: 1f 20 03 d5  	nop
ffff000000003ee4: 1f 20 03 d5  	nop
ffff000000003ee8: 1f 20 03 d5  	nop
ffff000000003eec: 1f 20 03 d5  	nop
ffff000000003ef0: 1f 20 03 d5  	nop
ffff000000003ef4: 1f 20 03 d5  	nop
ffff000000003ef8: 1f 20 03 d5  	nop
ffff000000003efc: 1f 20 03 d5  	nop
;     handle_invalid_entry FIQ_EL0_AARCH32 
ffff000000003f00: c0 01 80 d2  	mov	x0, #14
ffff000000003f04: 01 52 38 d5  	mrs	x1, ESR_EL1
ffff000000003f08: 22 40 38 d5  	mrs	x2, ELR_EL1
ffff000000003f0c: 3d f2 ff 97  	bl	0xffff000000000800 <show_unknown_interrupt_msg>
ffff000000003f10: 47 f0 ff 17  	b	0xffff00000000002c <proc_hang>
ffff000000003f14: 1f 20 03 d5  	nop
ffff000000003f18: 1f 20 03 d5  	nop
ffff000000003f1c: 1f 20 03 d5  	nop
ffff000000003f20: 1f 20 03 d5  	nop
ffff000000003f24: 1f 20 03 d5  	nop
ffff000000003f28: 1f 20 03 d5  	nop
ffff000000003f2c: 1f 20 03 d5  	nop
ffff000000003f30: 1f 20 03 d5  	nop
ffff000000003f34: 1f 20 03 d5  	nop
ffff000000003f38: 1f 20 03 d5  	nop
ffff000000003f3c: 1f 20 03 d5  	nop
ffff000000003f40: 1f 20 03 d5  	nop
ffff000000003f44: 1f 20 03 d5  	nop
ffff000000003f48: 1f 20 03 d5  	nop
ffff000000003f4c: 1f 20 03 d5  	nop
ffff000000003f50: 1f 20 03 d5  	nop
ffff000000003f54: 1f 20 03 d5  	nop
ffff000000003f58: 1f 20 03 d5  	nop
ffff000000003f5c: 1f 20 03 d5  	nop
ffff000000003f60: 1f 20 03 d5  	nop
ffff000000003f64: 1f 20 03 d5  	nop
ffff000000003f68: 1f 20 03 d5  	nop
ffff000000003f6c: 1f 20 03 d5  	nop
ffff000000003f70: 1f 20 03 d5  	nop
ffff000000003f74: 1f 20 03 d5  	nop
ffff000000003f78: 1f 20 03 d5  	nop
ffff000000003f7c: 1f 20 03 d5  	nop
;     handle_invalid_entry SERROR_EL0_AARCH32
ffff000000003f80: e0 01 80 d2  	mov	x0, #15
ffff000000003f84: 01 52 38 d5  	mrs	x1, ESR_EL1
ffff000000003f88: 22 40 38 d5  	mrs	x2, ELR_EL1
ffff000000003f8c: 1d f2 ff 97  	bl	0xffff000000000800 <show_unknown_interrupt_msg>
ffff000000003f90: 27 f0 ff 17  	b	0xffff00000000002c <proc_hang>

ffff000000003f94 <handle_el0_synch>:
;      push_kernel_state_onto_stack 0 
ffff000000003f94: e1 8f 1f f8  	str	x1, [sp, #-8]!
ffff000000003f98: 01 08 88 d2  	mov	x1, #16448
ffff000000003f9c: 21 dc 78 d3  	lsl	x1, x1, #8
ffff000000003fa0: 20 00 00 f9  	str	x0, [x1]
ffff000000003fa4: e0 87 40 f8  	ldr	x0, [sp], #8
ffff000000003fa8: 20 04 00 f9  	str	x0, [x1, #8]
ffff000000003fac: 22 08 00 f9  	str	x2, [x1, #16]
ffff000000003fb0: 23 0c 00 f9  	str	x3, [x1, #24]
ffff000000003fb4: 24 10 00 f9  	str	x4, [x1, #32]
ffff000000003fb8: 25 14 00 f9  	str	x5, [x1, #40]
ffff000000003fbc: 26 18 00 f9  	str	x6, [x1, #48]
ffff000000003fc0: 27 1c 00 f9  	str	x7, [x1, #56]
ffff000000003fc4: 28 20 00 f9  	str	x8, [x1, #64]
ffff000000003fc8: 29 24 00 f9  	str	x9, [x1, #72]
ffff000000003fcc: 2a 28 00 f9  	str	x10, [x1, #80]
ffff000000003fd0: 2b 2c 00 f9  	str	x11, [x1, #88]
ffff000000003fd4: 2c 30 00 f9  	str	x12, [x1, #96]
ffff000000003fd8: 2d 34 00 f9  	str	x13, [x1, #104]
ffff000000003fdc: 2e 38 00 f9  	str	x14, [x1, #112]
ffff000000003fe0: 2f 3c 00 f9  	str	x15, [x1, #120]
ffff000000003fe4: 30 40 00 f9  	str	x16, [x1, #128]
ffff000000003fe8: 31 44 00 f9  	str	x17, [x1, #136]
ffff000000003fec: 32 48 00 f9  	str	x18, [x1, #144]
ffff000000003ff0: 33 4c 00 f9  	str	x19, [x1, #152]
ffff000000003ff4: 34 50 00 f9  	str	x20, [x1, #160]
ffff000000003ff8: 35 54 00 f9  	str	x21, [x1, #168]
ffff000000003ffc: 36 58 00 f9  	str	x22, [x1, #176]
ffff000000004000: 37 5c 00 f9  	str	x23, [x1, #184]
ffff000000004004: 38 60 00 f9  	str	x24, [x1, #192]
ffff000000004008: 39 64 00 f9  	str	x25, [x1, #200]
ffff00000000400c: 3a 68 00 f9  	str	x26, [x1, #208]
ffff000000004010: 3b 6c 00 f9  	str	x27, [x1, #216]
ffff000000004014: 3c 70 00 f9  	str	x28, [x1, #224]
ffff000000004018: 3d 74 00 f9  	str	x29, [x1, #232]
ffff00000000401c: 3e 78 00 f9  	str	x30, [x1, #240]
ffff000000004020: 23 40 38 d5  	mrs	x3, ELR_EL1
ffff000000004024: 04 40 38 d5  	mrs	x4, SPSR_EL1
ffff000000004028: 23 7c 00 f9  	str	x3, [x1, #248]
ffff00000000402c: 24 80 00 f9  	str	x4, [x1, #256]
ffff000000004030: 03 41 38 d5  	mrs	x3, SP_EL0
ffff000000004034: 7f 00 00 91  	mov	sp, x3
ffff000000004038: 23 84 00 f9  	str	x3, [x1, #264]
ffff00000000403c: 23 40 38 d5  	mrs	x3, ELR_EL1
ffff000000004040: 03 3e fe b4  	cbz	x3, 0xffff000000000800 <show_unknown_interrupt_msg>
;      bl handle_irq
ffff000000004044: fd f1 ff 97  	bl	0xffff000000000838 <handle_irq>
;      restore_kernel_state_from_stack_and_exit
ffff000000004048: 01 08 88 d2  	mov	x1, #16448
ffff00000000404c: 21 dc 78 d3  	lsl	x1, x1, #8
ffff000000004050: 23 7c 40 f9  	ldr	x3, [x1, #248]
ffff000000004054: 24 80 40 f9  	ldr	x4, [x1, #256]
ffff000000004058: 23 40 18 d5  	msr	ELR_EL1, x3
ffff00000000405c: 04 40 18 d5  	msr	SPSR_EL1, x4
ffff000000004060: 23 84 40 f9  	ldr	x3, [x1, #264]
ffff000000004064: 7f 00 00 91  	mov	sp, x3
ffff000000004068: 03 41 18 d5  	msr	SP_EL0, x3
ffff00000000406c: 20 00 40 f9  	ldr	x0, [x1]
ffff000000004070: 22 08 40 f9  	ldr	x2, [x1, #16]
ffff000000004074: 23 0c 40 f9  	ldr	x3, [x1, #24]
ffff000000004078: 24 10 40 f9  	ldr	x4, [x1, #32]
ffff00000000407c: 25 14 40 f9  	ldr	x5, [x1, #40]
ffff000000004080: 26 18 40 f9  	ldr	x6, [x1, #48]
ffff000000004084: 27 1c 40 f9  	ldr	x7, [x1, #56]
ffff000000004088: 28 20 40 f9  	ldr	x8, [x1, #64]
ffff00000000408c: 29 24 40 f9  	ldr	x9, [x1, #72]
ffff000000004090: 2a 28 40 f9  	ldr	x10, [x1, #80]
ffff000000004094: 2b 2c 40 f9  	ldr	x11, [x1, #88]
ffff000000004098: 2c 30 40 f9  	ldr	x12, [x1, #96]
ffff00000000409c: 2d 34 40 f9  	ldr	x13, [x1, #104]
ffff0000000040a0: 2e 38 40 f9  	ldr	x14, [x1, #112]
ffff0000000040a4: 2f 3c 40 f9  	ldr	x15, [x1, #120]
ffff0000000040a8: 30 40 40 f9  	ldr	x16, [x1, #128]
ffff0000000040ac: 31 44 40 f9  	ldr	x17, [x1, #136]
ffff0000000040b0: 32 48 40 f9  	ldr	x18, [x1, #144]
ffff0000000040b4: 33 4c 40 f9  	ldr	x19, [x1, #152]
ffff0000000040b8: 34 50 40 f9  	ldr	x20, [x1, #160]
ffff0000000040bc: 35 54 40 f9  	ldr	x21, [x1, #168]
ffff0000000040c0: 36 58 40 f9  	ldr	x22, [x1, #176]
ffff0000000040c4: 37 5c 40 f9  	ldr	x23, [x1, #184]
ffff0000000040c8: 38 60 40 f9  	ldr	x24, [x1, #192]
ffff0000000040cc: 39 64 40 f9  	ldr	x25, [x1, #200]
ffff0000000040d0: 3a 68 40 f9  	ldr	x26, [x1, #208]
ffff0000000040d4: 3b 6c 40 f9  	ldr	x27, [x1, #216]
ffff0000000040d8: 3c 70 40 f9  	ldr	x28, [x1, #224]
ffff0000000040dc: 3d 74 40 f9  	ldr	x29, [x1, #232]
ffff0000000040e0: 3e 78 40 f9  	ldr	x30, [x1, #240]
ffff0000000040e4: 21 04 40 f9  	ldr	x1, [x1, #8]
ffff0000000040e8: e0 03 9f d6  	eret

ffff0000000040ec <handle_el1_irq>:
;      push_kernel_state_onto_stack 1
ffff0000000040ec: e1 8f 1f f8  	str	x1, [sp, #-8]!
ffff0000000040f0: 01 08 88 d2  	mov	x1, #16448
ffff0000000040f4: 21 dc 78 d3  	lsl	x1, x1, #8
ffff0000000040f8: 20 00 00 f9  	str	x0, [x1]
ffff0000000040fc: e0 87 40 f8  	ldr	x0, [sp], #8
ffff000000004100: 20 04 00 f9  	str	x0, [x1, #8]
ffff000000004104: 22 08 00 f9  	str	x2, [x1, #16]
ffff000000004108: 23 0c 00 f9  	str	x3, [x1, #24]
ffff00000000410c: 24 10 00 f9  	str	x4, [x1, #32]
ffff000000004110: 25 14 00 f9  	str	x5, [x1, #40]
ffff000000004114: 26 18 00 f9  	str	x6, [x1, #48]
ffff000000004118: 27 1c 00 f9  	str	x7, [x1, #56]
ffff00000000411c: 28 20 00 f9  	str	x8, [x1, #64]
ffff000000004120: 29 24 00 f9  	str	x9, [x1, #72]
ffff000000004124: 2a 28 00 f9  	str	x10, [x1, #80]
ffff000000004128: 2b 2c 00 f9  	str	x11, [x1, #88]
ffff00000000412c: 2c 30 00 f9  	str	x12, [x1, #96]
ffff000000004130: 2d 34 00 f9  	str	x13, [x1, #104]
ffff000000004134: 2e 38 00 f9  	str	x14, [x1, #112]
ffff000000004138: 2f 3c 00 f9  	str	x15, [x1, #120]
ffff00000000413c: 30 40 00 f9  	str	x16, [x1, #128]
ffff000000004140: 31 44 00 f9  	str	x17, [x1, #136]
ffff000000004144: 32 48 00 f9  	str	x18, [x1, #144]
ffff000000004148: 33 4c 00 f9  	str	x19, [x1, #152]
ffff00000000414c: 34 50 00 f9  	str	x20, [x1, #160]
ffff000000004150: 35 54 00 f9  	str	x21, [x1, #168]
ffff000000004154: 36 58 00 f9  	str	x22, [x1, #176]
ffff000000004158: 37 5c 00 f9  	str	x23, [x1, #184]
ffff00000000415c: 38 60 00 f9  	str	x24, [x1, #192]
ffff000000004160: 39 64 00 f9  	str	x25, [x1, #200]
ffff000000004164: 3a 68 00 f9  	str	x26, [x1, #208]
ffff000000004168: 3b 6c 00 f9  	str	x27, [x1, #216]
ffff00000000416c: 3c 70 00 f9  	str	x28, [x1, #224]
ffff000000004170: 3d 74 00 f9  	str	x29, [x1, #232]
ffff000000004174: 3e 78 00 f9  	str	x30, [x1, #240]
ffff000000004178: 23 40 38 d5  	mrs	x3, ELR_EL1
ffff00000000417c: 04 40 38 d5  	mrs	x4, SPSR_EL1
ffff000000004180: 23 7c 00 f9  	str	x3, [x1, #248]
ffff000000004184: 24 80 00 f9  	str	x4, [x1, #256]
ffff000000004188: e3 03 00 91  	mov	x3, sp
ffff00000000418c: 23 84 00 f9  	str	x3, [x1, #264]
ffff000000004190: 23 40 38 d5  	mrs	x3, ELR_EL1
ffff000000004194: 63 33 fe b4  	cbz	x3, 0xffff000000000800 <show_unknown_interrupt_msg>
;      bl handle_irq
ffff000000004198: a8 f1 ff 97  	bl	0xffff000000000838 <handle_irq>
;      restore_kernel_state_from_stack_and_exit
ffff00000000419c: 01 08 88 d2  	mov	x1, #16448
ffff0000000041a0: 21 dc 78 d3  	lsl	x1, x1, #8
ffff0000000041a4: 23 7c 40 f9  	ldr	x3, [x1, #248]
ffff0000000041a8: 24 80 40 f9  	ldr	x4, [x1, #256]
ffff0000000041ac: 23 40 18 d5  	msr	ELR_EL1, x3
ffff0000000041b0: 04 40 18 d5  	msr	SPSR_EL1, x4
ffff0000000041b4: 23 84 40 f9  	ldr	x3, [x1, #264]
ffff0000000041b8: 7f 00 00 91  	mov	sp, x3
ffff0000000041bc: 03 41 18 d5  	msr	SP_EL0, x3
ffff0000000041c0: 20 00 40 f9  	ldr	x0, [x1]
ffff0000000041c4: 22 08 40 f9  	ldr	x2, [x1, #16]
ffff0000000041c8: 23 0c 40 f9  	ldr	x3, [x1, #24]
ffff0000000041cc: 24 10 40 f9  	ldr	x4, [x1, #32]
ffff0000000041d0: 25 14 40 f9  	ldr	x5, [x1, #40]
ffff0000000041d4: 26 18 40 f9  	ldr	x6, [x1, #48]
ffff0000000041d8: 27 1c 40 f9  	ldr	x7, [x1, #56]
ffff0000000041dc: 28 20 40 f9  	ldr	x8, [x1, #64]
ffff0000000041e0: 29 24 40 f9  	ldr	x9, [x1, #72]
ffff0000000041e4: 2a 28 40 f9  	ldr	x10, [x1, #80]
ffff0000000041e8: 2b 2c 40 f9  	ldr	x11, [x1, #88]
ffff0000000041ec: 2c 30 40 f9  	ldr	x12, [x1, #96]
ffff0000000041f0: 2d 34 40 f9  	ldr	x13, [x1, #104]
ffff0000000041f4: 2e 38 40 f9  	ldr	x14, [x1, #112]
ffff0000000041f8: 2f 3c 40 f9  	ldr	x15, [x1, #120]
ffff0000000041fc: 30 40 40 f9  	ldr	x16, [x1, #128]
ffff000000004200: 31 44 40 f9  	ldr	x17, [x1, #136]
ffff000000004204: 32 48 40 f9  	ldr	x18, [x1, #144]
ffff000000004208: 33 4c 40 f9  	ldr	x19, [x1, #152]
ffff00000000420c: 34 50 40 f9  	ldr	x20, [x1, #160]
ffff000000004210: 35 54 40 f9  	ldr	x21, [x1, #168]
ffff000000004214: 36 58 40 f9  	ldr	x22, [x1, #176]
ffff000000004218: 37 5c 40 f9  	ldr	x23, [x1, #184]
ffff00000000421c: 38 60 40 f9  	ldr	x24, [x1, #192]
ffff000000004220: 39 64 40 f9  	ldr	x25, [x1, #200]
ffff000000004224: 3a 68 40 f9  	ldr	x26, [x1, #208]
ffff000000004228: 3b 6c 40 f9  	ldr	x27, [x1, #216]
ffff00000000422c: 3c 70 40 f9  	ldr	x28, [x1, #224]
ffff000000004230: 3d 74 40 f9  	ldr	x29, [x1, #232]
ffff000000004234: 3e 78 40 f9  	ldr	x30, [x1, #240]
ffff000000004238: 21 04 40 f9  	ldr	x1, [x1, #8]
ffff00000000423c: e0 03 9f d6  	eret

ffff000000004240 <terminate_interrupt>:
;     restore_kernel_state_from_stack_and_exit
ffff000000004240: 01 08 88 d2  	mov	x1, #16448
ffff000000004244: 21 dc 78 d3  	lsl	x1, x1, #8
ffff000000004248: 23 7c 40 f9  	ldr	x3, [x1, #248]
ffff00000000424c: 24 80 40 f9  	ldr	x4, [x1, #256]
ffff000000004250: 23 40 18 d5  	msr	ELR_EL1, x3
ffff000000004254: 04 40 18 d5  	msr	SPSR_EL1, x4
ffff000000004258: 23 84 40 f9  	ldr	x3, [x1, #264]
ffff00000000425c: 7f 00 00 91  	mov	sp, x3
ffff000000004260: 03 41 18 d5  	msr	SP_EL0, x3
ffff000000004264: 20 00 40 f9  	ldr	x0, [x1]
ffff000000004268: 22 08 40 f9  	ldr	x2, [x1, #16]
ffff00000000426c: 23 0c 40 f9  	ldr	x3, [x1, #24]
ffff000000004270: 24 10 40 f9  	ldr	x4, [x1, #32]
ffff000000004274: 25 14 40 f9  	ldr	x5, [x1, #40]
ffff000000004278: 26 18 40 f9  	ldr	x6, [x1, #48]
ffff00000000427c: 27 1c 40 f9  	ldr	x7, [x1, #56]
ffff000000004280: 28 20 40 f9  	ldr	x8, [x1, #64]
ffff000000004284: 29 24 40 f9  	ldr	x9, [x1, #72]
ffff000000004288: 2a 28 40 f9  	ldr	x10, [x1, #80]
ffff00000000428c: 2b 2c 40 f9  	ldr	x11, [x1, #88]
ffff000000004290: 2c 30 40 f9  	ldr	x12, [x1, #96]
ffff000000004294: 2d 34 40 f9  	ldr	x13, [x1, #104]
ffff000000004298: 2e 38 40 f9  	ldr	x14, [x1, #112]
ffff00000000429c: 2f 3c 40 f9  	ldr	x15, [x1, #120]
ffff0000000042a0: 30 40 40 f9  	ldr	x16, [x1, #128]
ffff0000000042a4: 31 44 40 f9  	ldr	x17, [x1, #136]
ffff0000000042a8: 32 48 40 f9  	ldr	x18, [x1, #144]
ffff0000000042ac: 33 4c 40 f9  	ldr	x19, [x1, #152]
ffff0000000042b0: 34 50 40 f9  	ldr	x20, [x1, #160]
ffff0000000042b4: 35 54 40 f9  	ldr	x21, [x1, #168]
ffff0000000042b8: 36 58 40 f9  	ldr	x22, [x1, #176]
ffff0000000042bc: 37 5c 40 f9  	ldr	x23, [x1, #184]
ffff0000000042c0: 38 60 40 f9  	ldr	x24, [x1, #192]
ffff0000000042c4: 39 64 40 f9  	ldr	x25, [x1, #200]
ffff0000000042c8: 3a 68 40 f9  	ldr	x26, [x1, #208]
ffff0000000042cc: 3b 6c 40 f9  	ldr	x27, [x1, #216]
ffff0000000042d0: 3c 70 40 f9  	ldr	x28, [x1, #224]
ffff0000000042d4: 3d 74 40 f9  	ldr	x29, [x1, #232]
ffff0000000042d8: 3e 78 40 f9  	ldr	x30, [x1, #240]
ffff0000000042dc: 21 04 40 f9  	ldr	x1, [x1, #8]
ffff0000000042e0: e0 03 9f d6  	eret

ffff0000000042e4 <init_interrupt_request_table>:
;     adr x0, exception_vector_list
ffff0000000042e4: e0 a8 ff 10  	adr	x0, #-2788
;     msr vbar_el1, x0
ffff0000000042e8: 00 c0 18 d5  	msr	VBAR_EL1, x0

ffff0000000042ec <enable_irq>:
;     msr    daifclr, #2
ffff0000000042ec: ff 42 03 d5  	msr	DAIFClr, #2
;     ret
ffff0000000042f0: c0 03 5f d6  	ret

ffff0000000042f4 <disable_irq>:
;     msr    daifset, #2
ffff0000000042f4: df 42 03 d5  	msr	DAIFSet, #2
;     ret
ffff0000000042f8: c0 03 5f d6  	ret

ffff0000000042fc <atomic_decrement>:
;   ldxr x0, [x0]
ffff0000000042fc: 00 7c 5f c8  	ldxr	x0, [x0]
;   sub x0, x0, #1
ffff000000004300: 00 04 00 d1  	sub	x0, x0, #1
;   stlxr w1, x0, [x0]
ffff000000004304: 00 fc 01 c8  	stlxr	w1, x0, [x0]
;   cbnz w1, atomic_decrement
ffff000000004308: a1 ff ff 35  	cbnz	w1, 0xffff0000000042fc <atomic_decrement>
;   ret
ffff00000000430c: c0 03 5f d6  	ret

ffff000000004310 <memzero>:
; 	str xzr, [x0], #8
ffff000000004310: 1f 84 00 f8  	str	xzr, [x0], #8
; 	subs x1, x1, #8
ffff000000004314: 21 20 00 f1  	subs	x1, x1, #8
; 	b.gt memzero
ffff000000004318: cc ff ff 54  	b.gt	0xffff000000004310 <memzero>
; 	ret
ffff00000000431c: c0 03 5f d6  	ret

ffff000000004320 <delay>:
;     sub x0, x0, #1
ffff000000004320: 00 04 00 d1  	sub	x0, x0, #1
;     cbnz x0, delay
ffff000000004324: e0 ff ff b5  	cbnz	x0, 0xffff000000004320 <delay>
;     ret
ffff000000004328: c0 03 5f d6  	ret

ffff00000000432c <get32>:
;     ldr w0, [x0]
ffff00000000432c: 00 00 40 b9  	ldr	w0, [x0]
;     ret
ffff000000004330: c0 03 5f d6  	ret

ffff000000004334 <put32>:
;     str w1, [x0], #1
ffff000000004334: 01 14 00 b8  	str	w1, [x0], #1
;     ret
ffff000000004338: c0 03 5f d6  	ret
